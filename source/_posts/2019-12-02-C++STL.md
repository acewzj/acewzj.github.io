---
title:  "C++ && STL 知识点"
date:   2019-12-02 10:16:18 +0800
categories:
- C++
tags:
- STL 
- C++
---

这篇文章主要记述了STL和一些C++的知识点。
<!--more-->



![P6150569](https://i.loli.net/2020/04/08/EBwdnzF3LA8M2Js.jpg)






# const

```cpp
const int& fun(int& a); //修饰返回值
int& fun(const int& a); //修饰形参
int& fun(int& a) const{} //const成员函数
```

如果写的函数需要传入一个指针，面试官可能会问是否需要为该指针加上const，把const加在指针不同的位置是否有区别？（左定值右定向）

如果写的函数需要传入的参数是一个复杂类型的实例，面试官可能会问传入值参数和传入引用参数有什么区别，什么时候需要为传入的引用参数加上const?

- 如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数。如果你把复制构造函数的传入参数设置为实例，这样会导致复制构造函数内调用复制构造函数，形成无休止的递归调用从而导致堆栈溢出。同时，如果我们在函数内部不改变传入的实例的状态，应该在传入的引用参数前加上const。

![4D76BDE38E95CF045BB00DF2851C9DC4](https://i.loli.net/2020/04/08/LOWJmhx9GfaZ2Si.png)

## 1、const返回值

这种多是修饰返回值是引用类型的情况下，为了避免返回值被修改的情况。

解释下：返回值是引用的函数， 可以肯定的是这个引用必然不是临时对象的引用（栈上的对象在返回后就消失了，自然也就不存在临时对象的引用这么一说了）， 因此一定是成员变量或者是函数参数（对象new出来是在堆上，成员变量也在堆上）， 所以在返回的时候为了避免其成为左值（下面这个例子很好的说明了什么是左值被修改）被修改，就需要加上const关键字来修饰。

举个例子：

```cpp
#include<iostream>

using namespace std;

class A
{
private:
    int data;
public:
    A(int num):data(num){}
    ~A(){};
    int& get_data()
    {
        return data;
    }
};

int main()
{
    A a(1);
    a.get_data()=3;
    cout<<a.get_data()<<endl; //data=3
    return 0;
}
```

那么这个时候为了避免成员函数被修改就需要加上const关键字，这个时候如果试图改变返回值是不允许的：

```text
error: cannot assign to return value because function 'get_data' returns a const value
```

需要指出的是，如果函数的返回类型是内置类型，比如 int char 等，修改返回值本身就是不合法的！所以 const 返回值是处理返回类型为用户定义类型的情况。

## 2、const 修饰实参

多数情况下，我们都会选择 pass by reference，这样可以节省内存，并且可以起到改变实参的目的。不过有的时候我们并不希望改变实参的值，就要加上const关键字。

这个不仔细说了，很容易理解。不过在构造接口之前一定要思考函数是否会修改参数，如果不会修改的话一定要加上const，这个是代码写的是否大气的一个标准（侯捷大师原话）

## 3、const 成员函数

首先，面向对象程序设计中，为了体现封装性，通常不允许直接修改类对象的数据成员。

若要修改类对象，应调用公有成员函数来完成。

为了保证const对象的常量性，编译器区分不安全和安全的成员函数（即区分试图修改类对象与不修改类对象的函数），例如：

```C++
const Person man;
man.eat();	//对象的读操作
man.set(age = 34);	//错误：const 类对象不允许修改
```

**在C++中，只有被声明为const的成员函数才能被一个const类对象调用。**

 要声明一个const类型的类成员函数，只需要在成员函数参数列表后加上关键字const，例如，



```cpp
class Person{
    public:
    bool set(int age) const;    
}
```

const 修饰成员函数， 根本上是修饰了 this 指针。

在成员函数参数列表后面加上const修饰，表示函数内this指针是一个指向常量对象的指针，**不能修改成员变量**。

```C++
void Person::setName(string name) const
{
    this->name = name;
} //错误，const成员函数不能修改成员变量
```



> 补充this指针：
> 每个对象拥有一个this指针，通过this指针来访问自己的地址。
>
> this指针并不是对象的一部分，this指针所占的内存大小是不会反应在sizeof操作符上的。
>
> 在普通成员函数中，this是一个指向非const对象的const指针（如类类型为Student，那么this就是Student *const类型的指针）;
> 在const成员函数中，this指针是一个指向const对象的const指针（如类类型为Student，那么this就是const Student * const类型的指针)
>
> 对于const对象或者const对象的引用和指针，对象内的成员变量是不能修改的，因此只能调用const成员函数，不会修改成员变量
> 对于非const对象，既可以调用const成员函数，也可以调用非const成员函数。

![A171910534B481CF8D7F8866CDF1FB32](https://i.loli.net/2020/04/08/Twn25A1GWfD7izu.png)









# 向上/下强制转换

- 将派生类引用或指针转换为基类引用或指针被称为向上强制转换。

- 将基类引用或指针转换为派生类引用或指针被称为向下强制转换。

如果不使用显示类型转换，向下强制转换是不允许的，因为is-a关系是不可逆的。

比如香蕉是水果，但是水果不是香蕉。派生类香蕉可以新增数据成员，因此这些数据成员不能应用于基类水果，比如香蕉中有黄色，但是不是所有水果都是黄色的。



# STL

STL有六种序列容器类型：

- 1 Vector:相当于一个数组，在内存中分配一块连续的内存空间进行存储；STL内部实现时首先分配一个非常大的内存空间预备进行存储（可以通过capacity()函数返回其大小）
- 2 List：双向链表
- 3 Deque:双端队列
  人们习惯上把程序员分三个等级，知其然，知其所以然，造其所以然

## hash

hash也称散列，哈希。基本原理就是将**任意长度**的输入变成**固定长度**的输出。这个映射的规则就是哈希算法，而原始数据经过映射形成的二进制字符串就是哈希值。开发中的MD5和SHA都是历史悠久的哈希算法。

```python
echo md5("This is a test md5!");
//output 2124968af757ed51e7abecd04f98e
```



### hash的优点

1 不能从hash值反向推导出原始的数据

2 输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值

3 哈希算法的执行效率要高效，长的文本也能快速的计算出哈希值

4 哈希算法的冲突概率要小

由于哈希的原理就是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间，根据鸽笼原理，一定会存在不同的输入被映射成相同输出的情况。

### hash碰撞的解决方案

前面提到了哈希算法是一定会有碰撞的，那么如果我们遇到了hash冲突需要解决的时候该怎么处理呢？常用的方法就是 **链地址法**和**开放地址法**。

开放地址法就是构造一个M的数组保存N个键值对（M>N)。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所以方法统称为“开放地址法”。线性探测法，就是比较常见的一种实现方式。它的核心思想是当冲突发生时，顺序查看表的下一个单元，直到找到一个空单元或查遍全表。只要散列表足够大，空的散列地址总能找到。

## Array

就是个数组，不能扩充。

## Vector

vector的增长是2倍2倍的扩充容量（capacity）,注意这里不是在原来的基础上成长：它是在另外的地方找一个两倍的空间然后一个一个元素搬过去。。。。。。所以vector的size是元素的数量，但是capacity却是扩充 的2的倍数。补充：容器的data指的是在内存中首元素的地址。

vector初始化：

    int aa[8] = {9,6,2,8,4,3,7,5};
    
    vector<int> a(aa, aa + 8);
    vector<int> a = {1,2,3,4};
## List

list与vector不同，它是采用的环状双向链表

某些容器（如list）自带sort，这个要比全局的sort要快

![](https://i.loli.net/2019/12/06/2eK3CMPjGTDgvmX.png)

![](https://i.loli.net/2019/12/08/fK1yzJdoSA7VRWg.png)

c++中箭头运算符->，相当于把解引用和成员访问符两个操作符结合在一起，换句话说，

p->func()和(*p).func()所表示的意思一样。

地址->一个东西   *ite去解引用了ite这个地址
&（*ite）又取回来这个地址

## Deque

分段连续，类似于二维指针：由一个指针指向一个缓冲区

![](https://i.loli.net/2019/12/02/G4CH2ypvqLIKT9M.png)

![](https://i.loli.net/2019/12/08/qOHBIDR8TVUbaGp.png)

- 这里：node指向deque的控制大脑，first指向某一段的开头，last指向某一段的结尾，前闭后开区间，cur指向当前的这一段里面的节点。当走到头时，会由node进行段的切换；

- 控制中心是一个vector。如果你想在前面插入的话，且前面空间不够了，你依旧也是需要开辟一个2倍原来空间的控制中心区域一个一个的拷贝构造一下。但是它很狡猾的拷贝到2倍区域的中段来，这样可以让首尾控制中心的扩充更为均衡一些；

- start与finish指向的是deque中所有元素的首跟尾；

![](https://i.loli.net/2019/12/08/mDnCTt48ZzyhaXF.png)

- 区分前++与后++的方法是：后++会传int的形参，这是规定

- 后++会生成一个临时的tmp对象，然后对原对象进行前++操作，再把tmp对象返回

- ### self的用处是？？？？？

![](https://i.loli.net/2019/12/08/wAq2eMDOSRUjl5a.png)

![](https://i.loli.net/2019/12/08/VQPYsLJjzCTWnfr.png)

![4.9](https://i.loli.net/2019/12/08/aKpUckOP2NVDQJl.png)

![](https://i.loli.net/2019/12/08/TQuPz1cew8p6atl.png)

![](https://i.loli.net/2019/12/08/1ntR6YcLUVMK7WO.png)

## Map

multimap<key,value>//multi允许重复

snprintf(buf,10,"%d",rand（）)；//如果格式化后的字符串长度 >= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符('\0')，返回值为欲写入的字符串长度

```c
#include <stdio.h>
 
int main () {
  char a[16];
  size_t i;
 
  i = snprintf(a, 13, "%012d", 12345);  // 第 1 种情况 12位宽
  printf("i = %lu, a = %s\n", i, a);    // 输出：i = 12, a = 000000012345
 
  i = snprintf(a, 9, "%012d", 12345);   // 第 2 种情况 0000 0001 2345
  printf("i = %lu, a = %s\n", i, a);    // 输出：i = 12, a = 00000001
 
  return 0;
}
```



c.insert(pair<long,string>(i,buf))

- multimap不可以用[作Insertion,map却可以，注意重复与不重复.

## OOP：&GP：Generic Programming

Object-Oriented-Programming

GP 可以使得两个团队可以专注于闭门造车

OOP相当于菜谱（数据相当于原材料，方法相当于烹饪步骤）

标准库用的全局的：：sort排序需要的是RandomAccessIterator，随机的迭代器，而list不能随意的像数组那样一下子蹦5个单元，所以List不能使用全局的：：sort排序。

## Template

类模板与函数模板

![](https://i.loli.net/2019/12/03/caYW31lkdThB7qR.jpg)

![](https://i.loli.net/2019/12/03/NKdZD8fH1anhATQ.jpg)

类模板如果不进行<double> <int>的绑定，它不知道该给T初始化为多少？毕竟2.5初始化为float也行，初始化为double也行。

但是函数模板就不一样了，因为编译器可以进行类型推导，从r1那个Stone r1就可以推出T的类型，进而重载Stone类的<操作符。

```c++
template<class T>和下面相同  
template<typename T>
class complex{};
```



## 泛化与特化

- 类模板中我可以通过T来形成各种各样的类的蓝图。但是如果你是一种特定的类型比如int，我可以提供给你一种更为有效的做法，这就叫做特化。

![特化](https://i.loli.net/2019/12/03/KFsXC3H18rieR4S.png)

- template<>有时候是__STL_TEMPLATE_NULL

- 以上是FULL 特化，还有偏特化    Partial Specialization

  <img src="https://i.loli.net/2019/12/03/w2KsNOf4ypomkzG.png" style="zoom:75%;" />
  
  
  
  
  
  
  
## traits

  萃取，特征，一种人为制造的萃取机器：我丢给它一些东西，它可以萃取出我想要的特征

  iterator_category：描述了迭代器的性质：有的迭代器可以一往无前的向前冲++，有的还可以后退--，有的可以跳着走......

  diffrence_type：两个迭代器之间的距离用啥来表示？比如int表示你的容器的两个迭代器的距离范围最大是2^32。一般设为ptrdiff_t，是一个Unsigned long类型的

  value_type：迭代器所指的容器里面的元素的类型

```c
template<typename _Tp> inline
Mat_<_Tp>::Mat_(int _rows, int _cols)
    : Mat(_rows, _cols, traits::Type<_Tp>::value)
{
}
```

   traits::Type<_Tp>::value

我对这段话的理解是，cv::DataType<>是一个模板类，当OpenCV中库函数需要传递特定数据类型的某些概念信息时，那么就可以通过创建cv::DataType<> 类型的对象来实现。我们使用的不是它本身，而是它特定的实例化对象。C++中这种用法叫做Traits。

  说实话，第一次看这一篇章，我也没有看懂cv::DataType<>到底是做什么用的，不过下面讲解一下Traits后，就能明白上面说意思了。

  简单来说，如果我们封装了一个算法，这个算法可能会由于输入数据类型的不同导致算法内部处理逻辑的不同（比如说传入的是int类型我们做一种操作，而传入的是double类型我们将进行另外一种操作），而我们并不想由于这种原因修改算法的封装时，Traits就派上用场了，它可以帮我们很方便的实现功能，而又不破坏函数的封装。
  Traits在开发者中运用特别多，主要也就是为了解决用户的负担，让一些复杂逻辑处理留给开发者来做，用户只需要根据要求调用API函数即可。

  https://blog.csdn.net/XiangJiaoJun_/article/details/84843194![](https://i.loli.net/2019/12/06/5FO9TWbmznukGlx.png)

## RB_Tree

关联式容器。红黑树。散列表。

- 红黑树的++操作类似于中序遍历，它是按照元素增大的顺序进行遍历的
- 我们不应该使用红黑树的迭代器进行修改值的操作：因为会破坏严谨的红黑树的平衡

## C++编程技巧Tips

- 定义变量的时候可以不用缩进然后避免在开头集中定义，又方便查找----侯捷

- 抽空研究一下快速排序，红黑树

- ：：find是循序查找， 

- 关键字typedef在编译阶段有效，由于是在编译阶段，因此typedef有类型检查的功能。

  \#define则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。

  typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。

  \#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。

  \#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。

  而typedef有自己的作用域。
  
  
  
- c++的一个语法：
  
  
  
  将typedef和typename关键字联用。
  
  ```
  template <class T,class Alloc=alloc>class vector{public://...typedef size_t size_type;//...};
  ```
  
  从vector的类定义可以看出，`vector::size_type`是`vector`嵌套类型定义，其实际等价于 `size_t`类型。
  
  ```
  vector<int>::size_type ssize;//就等价于size_t ssize;
  ```
  
  为什么要在typedef后面加上typename关键字？
  
  原因：
  
  实际上，模板类型在实例化之前，编译器并不知道`vector<T>::size_type`是什么东西，事实上一共有三种可能：
  
  > 静态数据成员
  > 静态成员函数
  > 嵌套类型
  
  那么此时`typename`的作用就在此时体现出来了——定义就不再模棱两可。
  
  `typedef`创建了存在类型的别名，而`typename`告诉编译器`std::vector<T>::size_type`是一个类型而不是一个成员。
  
  
  

## C++ string 成员函数 length() size() 和 strlen() 的区别

sizeof()是运算符，在编译期间就计算好了，所以对于字符串来说会统计到‘\0’的个数。（这都是早期落后的C故意设计的--字符串后面加一个\0，之后先进的length等函数都不用统计\0的个数了）

而size()是由于string 毕竟也是一个容器，容器会为了统一都有一个size()函数

size()、length()是c++中string的类的方法，只有string类的对象才可以用该方法，而字符串数组不可用，而strlen、strcpy等源于C语言的字符串处理函数库，需要include<string.h>,同时也只有字符串数组才可以用
size()与length()完全等同，遇到空字符不会被截断，可以返回字符串真实长度
strlen(),源于C语言，遇到空字符会截断，从而无法返回字符串真实长度
strlen同样也可以用于C++的string。但是需要用c_str()将C++ string转换为char*类型。

## 拷贝构造

**拷贝构造函数必须以引用的方式传递参数**。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。

## 拷贝赋值

首先返回值得是一个引用哈，是为了：p1 = p2 = p3的这种递归赋值的情况；

然后注意形参是一个常量引用，成员函数后面加不加const呢？由于要修改this类的成员变量，所以不能加const

进入函数要先判断this指针的p1 = p1这种情况；

最后要把this类的原指针指向的内存释放一下，防止内存泄露

delete []m_pData;  m_pData = nullptr;

```c++
CMyString& CMyString::operator = (const CMyString& str)
{
    if(this == &str)
        return *this;

    delete []m_pData;
    m_pData = nullptr;

    m_pData = new char[strlen(str.m_pData) + 1];
    strcpy(m_pData, str.m_pData);

    return *this;
}
```





# 关于命名空间

命名空间是可以不断进行扩充的，并不是一次就定义好命名空间里所有的东西。

尽量少的使用Using namespace std;等全局的引入，因为这样的引入多了之后，还是会产生命名污染。最好是你用哪里的变量，在前面写上命名空间。

`error C2872: ACCESS_MASK: 不明确的符号。`
有点懵，来不及懵。

当一个函数没有在编译头文件中找到定义时，一般就会报错：未标识的符号。
至于报错不明确的符号，那可能是因为，工程的编译文件里有多个该符号定义。
笔者没那么聪明，是在前辈基础经验上总结的。
opencv3.0的cv “ACCESS_MASK”冲突

不想打开链接可以直接看原文截图：


瞧见没？是因为winnt.h里边定义了cv，它的cv空间里有一个符号叫ACCESS_MASK；
opencv函数里边也定义了命名空间cv，它的cv空间里也有一个符号叫ACCESS_MASK。
那么我的项目如果同时包含这两个头文件，计算机是否知道我要调用哪个ACCESS_MASK吗？

回想平时写代码习惯性的：

using namespace std;
using namespace cv;
1
2
因为opencv里边很多函数，诸如imread，imshow，waitkey，Rect，Point，在使用频率上比较高，每次把它所在的命名空间书写有点麻烦，所以就习惯性的一次性了。
可惜懒人没懒福，这样的报错遇到过很多次，一直在回避。
改完这六百多个报错，以后还是一次性写清楚吧，不要给自己留隐患了。

