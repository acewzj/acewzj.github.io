---
title:  "C++ && STL 知识点"
date:   2019-12-02 10:16:18 +0800
categories:
- C++
tags:
- STL C++
---

这篇文章主要记述了STL和一些算法和知识点。
<!--more-->






## An Overview of Programs and Programming Languages

**Compiled languages** are translated to the target machine's native language by a program called a compiler. This can result in very fast code, especially if the compiler is effective at optimizing, however the resulting code may not port well across operating systems and the compilation process may take a while.
**Interpreted languages** are read by a program called an interpreter and are executed by that program. While they are as portable as their interpreter and have no long compile times, interpreted languages are usually *much* slower than an equivalent compiled program.
Finally, **just-in-time compiled** (or JIT-compiled) languages are languages that are quickly compiled when programs written in them need to be run (usually with very little optimization), offering a balance between performance and portability.



## The Features of C++ as a Language

Now that all the necessary theory has been covered, now it is possible to explain what C++ has to offer as a programming language. C++...

- ...is an open ISO-standardized language.
  For a time, C++ had no official standard and was maintained by a de-facto standard, however since 1998, C++ is standardized by a committee of the ISO. Their page may be accessed [here](http://www.open-std.org/jtc1/sc22/wg21/).

  

- ...is a compiled language.
  C++ compiles directly to a machine's native code, allowing it to be one of the fastest languages in the world, if optimized.

  

- ...is a strongly-typed unsafe language.
  C++ is a language that expects the programmer to know what he or she is doing, but allows for incredible amounts of control as a result.

  

- ...supports both manifest and inferred typing.
  As of the latest C++ standard, C++ supports both manifest and inferred typing, allowing flexibility and a means of avoiding verbosity where desired.

  

- ...supports both static and dynamic type checking.
  C++ allows type conversions to be checked either at compile-time or at run-time, again offering another degree of flexibility. Most C++ type checking is, however, static.

  

- ...offers many paradigm choices.
  C++ offers remarkable support for procedural, generic, and object-oriented programming paradigms, with many other paradigms being possible as well.

  

- ...is *portable.*
  As one of the most frequently used languages in the world and as an open language, C++ has a wide range of [compilers](http://www2.research.att.com/~bs/compilers.html) that run on many different platforms that support it. Code that exclusively uses C++'s standard library will run on many platforms with few to no changes.

  

- ...is upwards compatible with C
  C++, being a language that directly builds off C, is compatible with almost all C code. C++ can use C libraries with few to no modifications of the libraries' code.

  

- ...has incredible library support.
  A search for "library" on the popular project-management website [SourceForge](http://www.sourceforge.net/) will yield over 3000 results for C++ libraries. A link to the results of the search may be found [here](http://sourceforge.net/directory/language:C%2B%2B/?q=library).

STL有六种序列容器类型：

- 1 Vector:相当于一个数组，在内存中分配一块连续的内存空间进行存储；STL内部实现时首先分配一个非常大的内存空间预备进行存储（可以通过capacity()函数返回其大小）
- 2 List：双向链表
- 3 Deque:双端队列
  人们习惯上把程序员分三个等级，知其然，知其所以然，造其所以然

## hash

hash也称散列，哈希。基本原理就是将**任意长度**的输入变成**固定长度**的输出。这个映射的规则就是哈希算法，而原始数据经过映射形成的二进制字符串就是哈希值。开发中的MD5和SHA都是历史悠久的哈希算法。

```python
echo md5("This is a test md5!");
//output 2124968af757ed51e7abecd04f98e
```



### hash的优点

1 不能从hash值反向推导出原始的数据

2 输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值

3 哈希算法的执行效率要高效，长的文本也能快速的计算出哈希值

4 哈希算法的冲突概率要小

由于哈希的原理就是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间，根据鸽笼原理，一定会存在不同的输入被映射成相同输出的情况。

### hash碰撞的解决方案

前面提到了哈希算法是一定会有碰撞的，那么如果我们遇到了hash冲突需要解决的时候该怎么处理呢？常用的方法就是 **链地址法**和**开放地址法**。

开放地址法就是构造一个M的数组保存N个键值对（M>N)。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所以方法统称为“开放地址法”。线性探测法，就是比较常见的一种实现方式。它的核心思想是当冲突发生时，顺序查看表的下一个单元，直到找到一个空单元或查遍全表。只要散列表足够大，空的散列地址总能找到。

## Array

就是个数组，不能扩充。

## Vector

vector的增长是2倍2倍的扩充容量（capacity）,注意这里不是在原来的基础上成长：它是在另外的地方找一个两倍的空间然后一个一个元素搬过去。。。。。。所以vector的size是元素的数量，但是capacity却是扩充 的2的倍数。补充：容器的data指的是在内存中首元素的地址。

## List

list与vector不同，它是采用的环状双向链表

某些容器（如list）自带sort，这个要比全局的sort要快

![](https://i.loli.net/2019/12/06/2eK3CMPjGTDgvmX.png)

![](https://i.loli.net/2019/12/08/fK1yzJdoSA7VRWg.png)

c++中箭头运算符->，相当于把解引用和成员访问符两个操作符结合在一起，换句话说，

p->func()和(*p).func()所表示的意思一样。

地址->一个东西   *ite去解引用了ite这个地址
&（*ite）又取回来这个地址

## Deque

分段连续，类似于二维指针：由一个指针指向一个缓冲区

![](https://i.loli.net/2019/12/02/G4CH2ypvqLIKT9M.png)

![](https://i.loli.net/2019/12/08/qOHBIDR8TVUbaGp.png)

- 这里：node指向deque的控制大脑，first指向某一段的开头，last指向某一段的结尾，前闭后开区间，cur指向当前的这一段里面的节点。当走到头时，会由node进行段的切换；

- 控制中心是一个vector。如果你想在前面插入的话，且前面空间不够了，你依旧也是需要开辟一个2倍原来空间的控制中心区域一个一个的拷贝构造一下。但是它很狡猾的拷贝到2倍区域的中段来，这样可以让首尾控制中心的扩充更为均衡一些；

- start与finish指向的是deque中所有元素的首跟尾；

![](https://i.loli.net/2019/12/08/mDnCTt48ZzyhaXF.png)

- 区分前++与后++的方法是：后++会传int的形参，这是规定

- 后++会生成一个临时的tmp对象，然后对原对象进行前++操作，再把tmp对象返回

- ### self的用处是？？？？？

![](https://i.loli.net/2019/12/08/wAq2eMDOSRUjl5a.png)

![](https://i.loli.net/2019/12/08/VQPYsLJjzCTWnfr.png)

![4.9](https://i.loli.net/2019/12/08/aKpUckOP2NVDQJl.png)

![](https://i.loli.net/2019/12/08/TQuPz1cew8p6atl.png)

![](https://i.loli.net/2019/12/08/1ntR6YcLUVMK7WO.png)

## Map

multimap<key,value>//multi允许重复

snprintf(buf,10,"%d",rand（）)；//如果格式化后的字符串长度 >= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符('\0')，返回值为欲写入的字符串长度

```c
#include <stdio.h>
 
int main () {
  char a[16];
  size_t i;
 
  i = snprintf(a, 13, "%012d", 12345);  // 第 1 种情况 12位宽
  printf("i = %lu, a = %s\n", i, a);    // 输出：i = 12, a = 000000012345
 
  i = snprintf(a, 9, "%012d", 12345);   // 第 2 种情况 0000 0001 2345
  printf("i = %lu, a = %s\n", i, a);    // 输出：i = 12, a = 00000001
 
  return 0;
}
```



c.insert(pair<long,string>(i,buf))

- multimap不可以用[作Insertion,map却可以，注意重复与不重复.

## OOP：&GP：Generic Programming

Object-Oriented-Programming

GP 可以使得两个团队可以专注于闭门造车

OOP相当于菜谱（数据相当于原材料，方法相当于烹饪步骤）

标准库用的全局的：：sort排序需要的是RandomAccessIterator，随机的迭代器，而list不能随意的像数组那样一下子蹦5个单元，所以List不能使用全局的：：sort排序。

## Template

类模板与函数模板

![](https://i.loli.net/2019/12/03/caYW31lkdThB7qR.jpg)

![](https://i.loli.net/2019/12/03/NKdZD8fH1anhATQ.jpg)

类模板如果不进行<double> <int>的绑定，它不知道该给T初始化为多少？毕竟2.5初始化为float也行，初始化为double也行。

但是函数模板就不一样了，因为编译器可以进行类型推导，从r1那个Stone r1就可以推出T的类型，进而重载Stone类的<操作符。

```c++
template<class T>和下面相同  
template<typename T>
class complex{};
```



## 泛化与特化

- 类模板中我可以通过T来形成各种各样的类的蓝图。但是如果你是一种特定的类型比如int，我可以提供给你一种更为有效的做法，这就叫做特化。

![特化](https://i.loli.net/2019/12/03/KFsXC3H18rieR4S.png)

- template<>有时候是__STL_TEMPLATE_NULL

- 以上是FULL 特化，还有偏特化    Partial Specialization

  <img src="https://i.loli.net/2019/12/03/w2KsNOf4ypomkzG.png" style="zoom:75%;" />
  
  
  
  
  
  
  
## traits

  萃取，特征，一种人为制造的萃取机器：我丢给它一些东西，它可以萃取出我想要的特征

  iterator_category：描述了迭代器的性质：有的迭代器可以一往无前的向前冲++，有的还可以后退--，有的可以跳着走......

  diffrence_type：两个迭代器之间的距离用啥来表示？比如int表示你的容器的两个迭代器的距离范围最大是2^32。一般设为ptrdiff_t，是一个Unsigned long类型的

  value_type：迭代器所指的容器里面的元素的类型

```c
template<typename _Tp> inline
Mat_<_Tp>::Mat_(int _rows, int _cols)
    : Mat(_rows, _cols, traits::Type<_Tp>::value)
{
}
```

   traits::Type<_Tp>::value

我对这段话的理解是，cv::DataType<>是一个模板类，当OpenCV中库函数需要传递特定数据类型的某些概念信息时，那么就可以通过创建cv::DataType<> 类型的对象来实现。我们使用的不是它本身，而是它特定的实例化对象。C++中这种用法叫做Traits。

  说实话，第一次看这一篇章，我也没有看懂cv::DataType<>到底是做什么用的，不过下面讲解一下Traits后，就能明白上面说意思了。

  简单来说，如果我们封装了一个算法，这个算法可能会由于输入数据类型的不同导致算法内部处理逻辑的不同（比如说传入的是int类型我们做一种操作，而传入的是double类型我们将进行另外一种操作），而我们并不想由于这种原因修改算法的封装时，Traits就派上用场了，它可以帮我们很方便的实现功能，而又不破坏函数的封装。
  Traits在开发者中运用特别多，主要也就是为了解决用户的负担，让一些复杂逻辑处理留给开发者来做，用户只需要根据要求调用API函数即可。

  https://blog.csdn.net/XiangJiaoJun_/article/details/84843194![](https://i.loli.net/2019/12/06/5FO9TWbmznukGlx.png)

## RB_Tree

关联式容器。红黑树。散列表。

- 红黑树的++操作类似于中序遍历，它是按照元素增大的顺序进行遍历的
- 我们不应该使用红黑树的迭代器进行修改值的操作：因为会破坏严谨的红黑树的平衡

## 二叉树

```c++
#include <iostream>
using namespace std;

typedef struct BinaryTree {
	BinaryTree *Lchild;
	BinaryTree *Rchild;
	int data;
}BinaryTree;
int Construct(BinaryTree **T) {
	int ch;
	cin >> ch;
	if (ch == -1) {
		*T = NULL;
		return 0;
	}
	else
	{
		*T = (BinaryTree *)malloc(sizeof(BinaryTree));
		if (T == NULL)
			cout << "malloc failed!" << endl;
		else
		{
			(*T)->data = ch;
			cout << "请输入" << ch << "的左子节点：" << endl;
			Construct(&((*T)->Lchild));
			Construct(&((*T)->Rchild));
		}
			

	}

}
int main(int argc, char **argv) {
	cout << "BinaryTree Construct Stage..." << endl;
	BinaryTree *Btree;
	cout << "请输入二叉树第一个节点的值，-1代表叶子节点..." << endl;
	Construct(&Btree);
	return 0;
}
```

BTree本来是一个指向BinaryTree的指针，

因为有小伙伴问了，可否在构建二叉树传入的参数为一级地址。上述的方法是一定要传二级参数的，但是这里给出一个传一级参数的方法，小伙伴也可以通过对比两种方法，对二叉树的构建和传参方式有更深的理解。

```c
struct TreeNode* Create(){
	int val;
	scanf("%d", &val);
	
	struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode*));
	if (val <= 0) {
		return NULL;
	}
	
	if (!root) {
		printf("创建失败\n");
	}
 
	if (val > 0) {
		root->val = val;
		root->left = Create();
		root->right = Create();
	}
	 
	return root;
}
```

## 从文本读取数据C++

包含头文件\#include <fstream>

逐词读取

逐行读取

	ifstream filestream("text.txt");
	if (filestream.is_open()) {
	
	}
![image-20191221120517828](https://i.loli.net/2020/03/30/buXMqazylTYwIBL.png)

## C++编程技巧Tips

- 定义变量的时候可以不用缩进然后避免在开头集中定义，又方便查找----侯捷

- 抽空研究一下快速排序，红黑树

- ：：find是循序查找， 

- 关键字typedef在编译阶段有效，由于是在编译阶段，因此typedef有类型检查的功能。

  \#define则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。

  typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。

  \#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。

  \#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。

  而typedef有自己的作用域。
  
  
  
- c++的一个语法：
  
  
  
  将typedef和typename关键字联用。
  
  ```
  template <class T,class Alloc=alloc>class vector{public://...typedef size_t size_type;//...};
  ```
  
  从vector的类定义可以看出，`vector::size_type`是`vector`嵌套类型定义，其实际等价于 `size_t`类型。
  
  ```
  vector<int>::size_type ssize;//就等价于size_t ssize;
  ```
  
  为什么要在typedef后面加上typename关键字？
  
  原因：
  
  实际上，模板类型在实例化之前，编译器并不知道`vector<T>::size_type`是什么东西，事实上一共有三种可能：
  
  > 静态数据成员
  > 静态成员函数
  > 嵌套类型
  
  那么此时`typename`的作用就在此时体现出来了——定义就不再模棱两可。
  
  `typedef`创建了存在类型的别名，而`typename`告诉编译器`std::vector<T>::size_type`是一个类型而不是一个成员。
  
  
  

## C++ string 成员函数 length() size() 和 strlen() 的区别

sizeof()是运算符，在编译期间就计算好了，所以对于字符串来说会统计到‘\0’的个数。

而size()是由于string 毕竟也是一个容器，容器会为了统一都有一个size()函数

size()、length()是c++中string的类的方法，只有string类的对象才可以用该方法，而字符串数组不可用，而strlen、strcpy等源于C语言的字符串处理函数库，需要include<string.h>,同时也只有字符串数组才可以用
size()与length()完全等同，遇到空字符不会被截断，可以返回字符串真实长度
strlen(),源于C语言，遇到空字符会截断，从而无法返回字符串真实长度
strlen同样也可以用于C++的string。但是需要用c_str()将C++ string转换为char*类型。