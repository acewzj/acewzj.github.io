---
title:  "C++ && STL 知识点"
date:   2019-12-02 10:16:18 +0800
categories:
- C++
tags:
- STL 
- C++
---

这篇文章主要记述了STL和一些C++的知识点。
<!--more-->



![P6150569](https://i.loli.net/2020/04/08/EBwdnzF3LA8M2Js.jpg)

# restrict 关键字

restrict 是 C 的关键字(出现于 C99 标准)，用在指针声明中，C++ 的标准中没有 restrict ，但是现代的主流编译器都保留了对 restrict 的支持，如 VC++, GCC, Clang, Icc 等，不同编译器的书写形式或许不同，可能是 restrict, __restrict__, __restrict 等.
restrict 的含义是由编程者向编译器声明，在这个指针的生命周期中，只有这个指针本身或者直接由它产生的指针(如 ptr + 1)能够用来访问该指针指向的对象．他的作用是限制指针别名，帮助编译器做优化．如果该指针与另外一个指针指向同一对象，那么结果是未定义的．

例如在下列代码中

```c
int add (int* a, int* b)
{
    *a = 10;
    *b = 12;
    return *a + *b;
}
```

　　这个函数直观的作用便是将 a 和 b 指向的 int 对象赋值为 10 和 12, 然后返回他们两个的和，可以看出最后 `return *a + *b` 这条语句中是不需要的访问内存单元的，a 中一定是 10, b 中一定是 12, 所以编译器可以在这里做优化直接返回 22.
　　但是如果 a 和 b 指向的是同一个 int 对象呢? 这时编译器就不应该做优化，实际上编译器的优化策略是保守的，当无法判断这里能不能优化时，便不做优化，所以可得如下汇编代码，这已经是编译器在已知信息下所能做的最好的优化，优化等级是 -O3

```assembly
add(int*, int*):
  mov DWORD PTR [rdi], 10
  mov DWORD PTR [rsi], 12
  mov eax, DWORD PTR [rdi]
  add eax, 12
  ret
```

　　但是如果加上 `restrict` 修饰(编译器 GCC)，代码如下

```c
int add (int* __restrict__ a, int* __restrict__ b)
{
    *a = 10;
    *b = 12;
    return *a + *b;
}
```

　　编译器已经得知 a, b 两指针不会指向同一单元(此点应由编程者保证)，所以在这里会减少一次内存的访问，可以得到如下的汇编代码

```assembly
add(int*, int*):
  mov DWORD PTR [rdi], 10
  mov DWORD PTR [rsi], 12
  mov eax, 22
  ret
```

　　可见少了一条内存访问的指令

## void *

指向void的指针是“通用”指针类型；

可以将void *转换为任何其他指针类型，而无需显式强制转换。

您不能解引用void *或对其进行指针运算； 您必须先将其转换为指向完整数据类型的指针



```c
  int thread_params = 5;

  int *temp = &thread_params;//temp = 0x7fffffffe1c4

  void * tmp = (void*) temp;//tmp = 0x7fffffffe1c4
  
  pthread_create(&t_id,NULL, thread_main, (void*)&thread_params)
  
  int cnt = *((int *)arg);
//先将void * 指针类型转换为 int *  ==》 （int *）arg
//接着进行解引用 *((int *)arg);
```




# const

```cpp
const int& fun(int& a); //修饰返回值
int& fun(const int& a); //修饰形参
int& fun(int& a) const{} //const成员函数
```

如果写的函数需要传入一个指针，面试官可能会问是否需要为该指针加上const，把const加在指针不同的位置是否有区别？（左定值右定向）

如果写的函数需要传入的参数是一个复杂类型的实例，面试官可能会问传入值参数和传入引用参数有什么区别，什么时候需要为传入的引用参数加上const?

- 如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数。如果你把复制构造函数的传入参数设置为实例，这样会导致复制构造函数内调用复制构造函数，形成无休止的递归调用从而导致堆栈溢出。同时，如果我们在函数内部不改变传入的实例的状态，应该在传入的引用参数前加上const。

![4D76BDE38E95CF045BB00DF2851C9DC4](https://i.loli.net/2020/04/08/LOWJmhx9GfaZ2Si.png)

## 1、const返回值

这种多是修饰返回值是引用类型的情况下，为了避免返回值被修改的情况。

解释下：返回值是引用的函数， 可以肯定的是这个引用必然不是临时对象的引用（栈上的对象在返回后就消失了，自然也就不存在临时对象的引用这么一说了）， 因此一定是成员变量或者是函数参数（对象new出来是在堆上，成员变量也在堆上）， 所以在返回的时候为了避免其成为左值（下面这个例子很好的说明了什么是左值被修改）被修改，就需要加上const关键字来修饰。

举个例子：

```cpp
#include<iostream>

using namespace std;

class A
{
private:
    int data;
public:
    A(int num):data(num){}
    ~A(){};
    int& get_data()
    {
        return data;
    }
};

int main()
{
    A a(1);
    a.get_data()=3;
    cout<<a.get_data()<<endl; //data=3
    return 0;
}
```

那么这个时候为了避免成员函数被修改就需要加上const关键字，这个时候如果试图改变返回值是不允许的：

```text
error: cannot assign to return value because function 'get_data' returns a const value
```

需要指出的是，如果函数的返回类型是内置类型，比如 int char 等，修改返回值本身就是不合法的！所以 const 返回值是处理返回类型为用户定义类型的情况。

## 2、const 修饰实参

多数情况下，我们都会选择 pass by reference，这样可以节省内存，并且可以起到改变实参的目的。不过有的时候我们并不希望改变实参的值，就要加上const关键字。

这个不仔细说了，很容易理解。不过在构造接口之前一定要思考函数是否会修改参数，如果不会修改的话一定要加上const，这个是代码写的是否大气的一个标准（侯捷大师原话）

## 3、const 成员函数

首先，面向对象程序设计中，为了体现封装性，通常不允许直接修改类对象的数据成员。

若要修改类对象，应调用公有成员函数来完成。

为了保证const对象的常量性，编译器区分不安全和安全的成员函数（即区分试图修改类对象与不修改类对象的函数），例如：

```C++
const Person man;
man.eat();	//对象的读操作
man.set(age = 34);	//错误：const 类对象不允许修改
```

**在C++中，只有被声明为const的成员函数才能被一个const类对象调用。**

 要声明一个const类型的类成员函数，只需要在成员函数参数列表后加上关键字const，例如，



```cpp
class Person{
    public:
    bool set(int age) const;    
}
```

const 修饰成员函数， 根本上是修饰了 this 指针。

在成员函数参数列表后面加上const修饰，表示函数内this指针是一个指向常量对象的指针，**不能修改成员变量**。

```C++
void Person::setName(string name) const
{
    this->name = name;
} //错误，const成员函数不能修改成员变量
```



> 补充this指针：
> 每个对象拥有一个this指针，通过this指针来访问自己的地址。
>
> this指针并不是对象的一部分，this指针所占的内存大小是不会反应在sizeof操作符上的。
>
> 在普通成员函数中，this是一个指向非const对象的const指针（如类类型为Student，那么this就是Student *const类型的指针）;
> 在const成员函数中，this指针是一个指向const对象的const指针（如类类型为Student，那么this就是const Student * const类型的指针)
>
> 对于const对象或者const对象的引用和指针，对象内的成员变量是不能修改的，因此只能调用const成员函数，不会修改成员变量
> 对于非const对象，既可以调用const成员函数，也可以调用非const成员函数。

![A171910534B481CF8D7F8866CDF1FB32](https://i.loli.net/2020/04/08/Twn25A1GWfD7izu.png)









# 向上/下强制转换

- 将派生类引用或指针转换为基类引用或指针被称为向上强制转换。

- 将基类引用或指针转换为派生类引用或指针被称为向下强制转换。

如果不使用显示类型转换，向下强制转换是不允许的，因为is-a关系是不可逆的。

比如香蕉是水果，但是水果不是香蕉。派生类香蕉可以新增数据成员，因此这些数据成员不能应用于基类水果，比如香蕉中有黄色，但是不是所有水果都是黄色的。



# STL

STL有六种序列容器类型：

- 1 Vector:相当于一个数组，在内存中分配一块连续的内存空间进行存储；STL内部实现时首先分配一个非常大的内存空间预备进行存储（可以通过capacity()函数返回其大小）
- 2 List：双向链表
- 3 Deque:双端队列
  人们习惯上把程序员分三个等级，知其然，知其所以然，造其所以然

## hash

hash也称散列，哈希。基本原理就是将**任意长度**的输入变成**固定长度**的输出。这个映射的规则就是哈希算法，而原始数据经过映射形成的二进制字符串就是哈希值。开发中的MD5和SHA都是历史悠久的哈希算法。

```python
echo md5("This is a test md5!");
//output 2124968af757ed51e7abecd04f98e
```



### hash的优点

1 不能从hash值反向推导出原始的数据

2 输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值

3 哈希算法的执行效率要高效，长的文本也能快速的计算出哈希值

4 哈希算法的冲突概率要小

由于哈希的原理就是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间，根据鸽笼原理，一定会存在不同的输入被映射成相同输出的情况。

### hash碰撞的解决方案

前面提到了哈希算法是一定会有碰撞的，那么如果我们遇到了hash冲突需要解决的时候该怎么处理呢？常用的方法就是 **链地址法**和**开放地址法**。

开放地址法就是构造一个M的数组保存N个键值对（M>N)。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所以方法统称为“开放地址法”。线性探测法，就是比较常见的一种实现方式。它的核心思想是当冲突发生时，顺序查看表的下一个单元，直到找到一个空单元或查遍全表。只要散列表足够大，空的散列地址总能找到。

## Array

就是个数组，不能扩充。

## Vector

vector的增长是2倍2倍的扩充容量（capacity）,注意这里不是在原来的基础上成长：它是在另外的地方找一个两倍的空间然后一个一个元素搬过去。。。。。。所以vector的size是元素的数量，但是capacity却是扩充 的2的倍数。补充：容器的data指的是在内存中首元素的地址。

vector初始化：

    int aa[8] = {9,6,2,8,4,3,7,5};
    
    vector<int> a(aa, aa + 8);
    vector<int> a = {1,2,3,4};
## List

list与vector不同，它是采用的环状双向链表

某些容器（如list）自带sort，这个要比全局的sort要快

![](https://i.loli.net/2019/12/06/2eK3CMPjGTDgvmX.png)

![](https://i.loli.net/2019/12/08/fK1yzJdoSA7VRWg.png)

c++中箭头运算符->，相当于把解引用和成员访问符两个操作符结合在一起，换句话说，

p->func()和(*p).func()所表示的意思一样。

地址->一个东西   *ite去解引用了ite这个地址
&（*ite）又取回来这个地址

## Deque

分段连续，类似于二维指针：由一个指针指向一个缓冲区

![](https://i.loli.net/2019/12/02/G4CH2ypvqLIKT9M.png)

![](https://i.loli.net/2019/12/08/qOHBIDR8TVUbaGp.png)

- 这里：node指向deque的控制大脑，first指向某一段的开头，last指向某一段的结尾，前闭后开区间，cur指向当前的这一段里面的节点。当走到头时，会由node进行段的切换；

- 控制中心是一个vector。如果你想在前面插入的话，且前面空间不够了，你依旧也是需要开辟一个2倍原来空间的控制中心区域一个一个的拷贝构造一下。但是它很狡猾的拷贝到2倍区域的中段来，这样可以让首尾控制中心的扩充更为均衡一些；

- start与finish指向的是deque中所有元素的首跟尾；

![](https://i.loli.net/2019/12/08/mDnCTt48ZzyhaXF.png)

- 区分前++与后++的方法是：后++会传int的形参，这是规定

- 后++会生成一个临时的tmp对象，然后对原对象进行前++操作，再把tmp对象返回

- ### self的用处是？？？？？

![](https://i.loli.net/2019/12/08/wAq2eMDOSRUjl5a.png)

![](https://i.loli.net/2019/12/08/VQPYsLJjzCTWnfr.png)

![4.9](https://i.loli.net/2019/12/08/aKpUckOP2NVDQJl.png)

![](https://i.loli.net/2019/12/08/TQuPz1cew8p6atl.png)

![](https://i.loli.net/2019/12/08/1ntR6YcLUVMK7WO.png)

## Map

multimap<key,value>//multi允许重复

snprintf(buf,10,"%d",rand（）)；//如果格式化后的字符串长度 >= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符('\0')，返回值为欲写入的字符串长度

```c
#include <stdio.h>
 
int main () {
  char a[16];
  size_t i;
 
  i = snprintf(a, 13, "%012d", 12345);  // 第 1 种情况 12位宽
  printf("i = %lu, a = %s\n", i, a);    // 输出：i = 12, a = 000000012345
 
  i = snprintf(a, 9, "%012d", 12345);   // 第 2 种情况 0000 0001 2345
  printf("i = %lu, a = %s\n", i, a);    // 输出：i = 12, a = 00000001
 
  return 0;
}
```



c.insert(pair<long,string>(i,buf))

- multimap不可以用[作Insertion,map却可以，注意重复与不重复.

## OOP：&GP：Generic Programming

Object-Oriented-Programming

GP 可以使得两个团队可以专注于闭门造车

OOP相当于菜谱（数据相当于原材料，方法相当于烹饪步骤）

标准库用的全局的：：sort排序需要的是RandomAccessIterator，随机的迭代器，而list不能随意的像数组那样一下子蹦5个单元，所以List不能使用全局的：：sort排序。

## Template

类模板与函数模板

![](https://i.loli.net/2019/12/03/caYW31lkdThB7qR.jpg)

![](https://i.loli.net/2019/12/03/NKdZD8fH1anhATQ.jpg)

类模板如果不进行<double> <int>的绑定，它不知道该给T初始化为多少？毕竟2.5初始化为float也行，初始化为double也行。

但是函数模板就不一样了，因为编译器可以进行类型推导，从r1那个Stone r1就可以推出T的类型，进而重载Stone类的<操作符。

```c++
template<class T>和下面相同  
template<typename T>
class complex{};
```



## 泛化与特化

- 类模板中我可以通过T来形成各种各样的类的蓝图。但是如果你是一种特定的类型比如int，我可以提供给你一种更为有效的做法，这就叫做特化。

![特化](https://i.loli.net/2019/12/03/KFsXC3H18rieR4S.png)

- template<>有时候是__STL_TEMPLATE_NULL

- 以上是FULL 特化，还有偏特化    Partial Specialization

  <img src="https://i.loli.net/2019/12/03/w2KsNOf4ypomkzG.png" style="zoom:75%;" />
  
  
  
  
  
  
  
## traits 萃取

萃取，特征，一种人为制造的萃取机器：我丢给它一些东西，它可以萃取出我想要的特征

STL 中，容器和算法是分开的，两者之间靠的是迭代器进行连接。算法是如何从迭代器中知道元素的类型的呢？靠的就是萃取。。。

简单来说，如果我们封装了一个算法，这个算法可能会由于输入数据类型的不同导致算法内部处理逻辑的不同（比如说传入的是int类型我们做一种操作，而传入的是double类型我们将进行另外一种操作），而我们并不想由于这种原因修改算法的封装时，Traits就派上用场了，它可以帮我们很方便的实现功能，而又不破坏函数的封装。
迭代器所指对象的类型，称为该迭代器的 value_type。我们来简单模拟一个迭代器 traits classes 的实现。

 ```c
// 主模板 不使用模板参数列表--》 my_iterator_traits<Iter T>
template<class IterT>
struct my_iterator_traits {
    typedef typename IterT::value_type value_type;
};
//简单的偏特化版本
template<class IterT>
struct my_iterator_traits<IterT*> {
    typedef IterT value_type;
};

void fun(int a) {
    cout << "fun(int) is called" << endl;
}

void fun(double a) {
    cout << "fun(double) is called" << endl;
}

void fun(char a) {
    cout << "fun(char) is called" << endl;
}
my_iterator_traits<vector<int>::iterator>::value_type a;
fun(a);  // 输出 fun(int) is called
my_iterator_traits<vector<double>::iterator>::value_type b;
fun(b);  // 输出 fun(double) is called
my_iterator_traits<char*>::value_type c;
fun(c);  // 输出 fun(char) is called


// 为了便于理解，我们这里贴出 vector 迭代器声明代码的简化版本：
template <class T, ...>
class vector {
public:
    class iterator {
    public:
        typedef T value_type;
        ...
    };
...
};
 ```

my_iterator_traits 其实就是个类模板，其中包含一个类型的声明。有上面 typename 的基础，相信大家不难理解 typedef typename IterT::value_type value_type; 的含义：将迭代器的value_type 通过 typedef 为 value_type。

>为什么要在typedef后面加上typename关键字？
>
>之所以使用 typename 是由于C++默认使用 ：： 访问的名字不是类型
>
>原因：
>
>实际上，模板类型在实例化之前，编译器并不知道`vector<T>::size_type`是什么东西，事实上一共有三种可能：
>
>> 静态数据成员
>> 静态成员函数
>> 嵌套类型
>
>那么此时`typename`的作用就在此时体现出来了——定义就不再模棱两可。
>
>`typedef`创建了存在类型的别名，而`typename`告诉编译器`std::vector<T>::size_type`是一个类型而不是一个成员。
>
>默认情况下，C++ 语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字 typename 来实现这一点：

 我们来解释 my_iterator_traits<vector<int>::iterator>::value_type a; 语句的含义。
vector<int>::iterator 为vector<int> 的迭代器，该迭代器包含了 value_type 的声明，由 vector 的代码可以知道该迭代器的value_type 即为 int 类型。
接着，my_iterator_traits<vector<int>::iterator> 会采用 my_iterator_traits 的通用版本，即 my_iterator_traits<vector<int>::iterator>::value_type 使用 typename IterT::value_type 这一类型声明，这里 IterT 为 vector<int>::iterator，故整个语句萃取出来的类型为 int 类型。

对 double 类型的 vector 迭代器的萃取也是类似的过程。

而 my_iterator_traits<char*>::value_type 则使用 my_iterator_traits 的偏特化版本，直接返回 char 类型。

由此看来，通过 my_iterator_traits ，我们正确萃取出了迭代器所指元素的类型。

总结一下我们设计并实现一个 traits class 的过程：
1）确认若干我们希望将来可取得的类型相关信息，例如，对于上面的迭代器，我们希望取得迭代器所指元素的类型；
2）为该信息选择一个名称，例如，上面我们起名为 value_type；
3）提供一个 template 和一组特化版本（例如，我们上面的 my_iterator_traits），内容包含我们希望支持的类型相关信息。

  https://blog.csdn.net/XiangJiaoJun_/article/details/84843194![](https://i.loli.net/2019/12/06/5FO9TWbmznukGlx.png)

## RB_Tree

关联式容器。红黑树。散列表。

- 红黑树的++操作类似于中序遍历，它是按照元素增大的顺序进行遍历的
- 我们不应该使用红黑树的迭代器进行修改值的操作：因为会破坏严谨的红黑树的平衡

## C++编程技巧Tips

- 定义变量的时候可以不用缩进然后避免在开头集中定义，又方便查找----侯捷

- 抽空研究一下快速排序，红黑树

- ：：find是循序查找， 

- 关键字typedef在编译阶段有效，由于是在编译阶段，因此typedef有类型检查的功能。

  \#define则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。

  typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。

  \#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。

  \#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。

  而typedef有自己的作用域。
  
  
  
  
  

## 拷贝构造

**拷贝构造函数必须以引用的方式传递参数**。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。

## 拷贝赋值

首先返回值得是一个引用哈，是为了：p1 = p2 = p3的这种递归赋值的情况；

然后注意形参是一个常量引用，成员函数后面加不加const呢？由于要修改this类的成员变量，所以不能加const

进入函数要先判断this指针的p1 = p1这种情况；

最后要把this类的原指针指向的内存释放一下，防止内存泄露

delete []m_pData;  m_pData = nullptr;

```c++
CMyString& CMyString::operator = (const CMyString& str)
{
    if(this == &str)
        return *this;

    delete []m_pData;
    m_pData = nullptr;

    m_pData = new char[strlen(str.m_pData) + 1];
    strcpy(m_pData, str.m_pData);

    return *this;
}
```





# 关于命名空间

命名空间是可以不断进行扩充的，并不是一次就定义好命名空间里所有的东西。

尽量少的使用Using namespace std;等全局的引入，因为这样的引入多了之后，还是会产生命名污染。最好是你用哪里的变量，在前面写上命名空间。

`error C2872: ACCESS_MASK: 不明确的符号。`
有点懵，来不及懵。

当一个函数没有在编译头文件中找到定义时，一般就会报错：未标识的符号。
至于报错不明确的符号，那可能是因为，工程的编译文件里有多个该符号定义。
笔者没那么聪明，是在前辈基础经验上总结的。
opencv3.0的cv “ACCESS_MASK”冲突

不想打开链接可以直接看原文截图：


瞧见没？是因为winnt.h里边定义了cv，它的cv空间里有一个符号叫ACCESS_MASK；
opencv函数里边也定义了命名空间cv，它的cv空间里也有一个符号叫ACCESS_MASK。
那么我的项目如果同时包含这两个头文件，计算机是否知道我要调用哪个ACCESS_MASK吗？

回想平时写代码习惯性的：

using namespace std;
using namespace cv;
1
2
因为opencv里边很多函数，诸如imread，imshow，waitkey，Rect，Point，在使用频率上比较高，每次把它所在的命名空间书写有点麻烦，所以就习惯性的一次性了。
可惜懒人没懒福，这样的报错遇到过很多次，一直在回避。
改完这六百多个报错，以后还是一次性写清楚吧，不要给自己留隐患了。





# Note

----------------------------------------------------------------------------------------------------
2010.01.02

问题描述：当自己写一个类的时候，如何确定成员变量和成员函数的访问权限？

解决方法：根据《Effective C++》所说，所有成员变量都应声明为private，这样可以保证该类的public用户（类使用者）和protected用户（派生类撰写者）都可以不因你要修改类而修改他们的代码。

----------------------------------------------------------------------------------------------------
2010.01.02

问题描述：当自己写一个类的时候，有些功能只依赖于类的public接口函数。当需要用函数封装该功能时，是写成成员函数、友元函数还是普通函数？

解决方法：根据《Effective C++》所说，当然是普通函数。这样增强了类的封装性，实现新功能也更灵活。相关功能的普通函数还可以声明到一个namespace中作进一步打包封装。用namespace可以在很多文件中实现向同一个namespace添加功能函数，扩展灵活，编译依存度更低，使用起来语意像类的静态成员函数一样清晰。有百利而无一害。

----------------------------------------------------------------------------------------------------
2010.01.02

问题描述：为什么将自定义代码放在std命名空间里会出错？

问题原因：因为std的所有成员，都能且只能由C++标准委员会指定。

解决方法：1.没招儿，没法解决。
	2.将代码写在别的命名空间内，用的时候using对应的namespace。
	3.最根本的办法，你去成为C++标准委员会的一员，提交提案并说服其他委员在定C++标准的时候，把你这段代码加到std命名空间去。

----------------------------------------------------------------------------------------------------
2010.01.08

问题描述：在类继承体系中，为什么会出现“鸟都会飞――企鹅是鸟――但企鹅不会飞”这样的悖论？

问题原因：因为软件世界和现实世界有一些不同。在软件世界中，类的继承表示派生类能拥有基类的所有行为，而且严格拥有。但在现实世界中，我们说“鸟都会飞”，是说“一般的鸟都会飞”，并不是很严格的继承关系。

解决方法：1.严格地使用抽象继承体系，对世界做贴近软件规则的抽象；
	2.根据软件的应用范围，灵活设计继承体系；（换句话说，也许你的应用中根本不会出现不会飞的鸟，那还操那个心干什么？）
	3.在运行时检查逻辑错误，抛出异常或提示错误等。
	4.在逻辑非法的操作中使用static_assert()，保证编译期查错，个别禁止非法行为；（也就是在企鹅的飞行函数中加入一个错的判断）

----------------------------------------------------------------------------------------------------
2010.03.27

问题描述：在Visual Studio 2005中，如何将代码转换为标准格式？

解决方法：选定需要格式化的范围，在菜单中选择“编辑”->“高级”->“设置选定内容的格式”即可。
	快捷键为：CTRL+K，CTRL+F

----------------------------------------------------------------------------------------------------
2010.03.27

问题描述：在Visual Studio 2005中，如何为主函数执行加入参数？

解决方法：在菜单中选择“项目”->“属性”->“配置属性”->“调试”->"命令参数"，加入参数即可。

----------------------------------------------------------------------------------------------------
2010.03.30

问题描述：如何在启动命令行界面(cmd.exe)运行程序时，程序执行完毕后命令行不退出？

解决方法：1. 在启动命令行的时候加入参数 /k 可以保持命令行不自动退出。如：cmd /k test.exe

----------------------------------------------------------------------------------------------------
2010.03.30

问题描述：对一个区间进行排序的标准算法有哪些？都完成什么功能？

解决方法：1.BidirectionalIterator partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred);
		完成区间[first,last)的不稳定二分，使满足pred(*iter)的元素都在左边，返回值是指向第一个不满足pred(*iter)==true的迭代器iter。
	2. BidirectionalIterator stable_partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred);
		完成区间[first,last)的稳定二分，使满足pred(*iter)的元素都在左边，返回值是指向第一个不满足pred(*iter)==true的迭代器iter。
	3. void nth_element(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);
		void nth_element(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, StrictWeakOrdering cmp);
		完成区间[first,last)上的不稳定二分，使区间[first,middle+1)内的任意元素i和区间[middle+1,last)内的任意元素j满足j<i==false(或cmp(j,i)==false)，
		而且，middle位置的元素恰好是区间[first,last)全排后middle位置的元素。
	4. void partial_sort(RandomAccessIterator first, RandomAccessIterator first_n, RandomAccessIterator last);
		void partial_sort(RandomAccessIterator first, RandomAccessIterator first_n, RandomAccessIterator last, StrictWeakOrdering cmp);
		完成区间[first,last)上的不稳定二分，使区间[first,first_n)中的元素为[first,last)中的最小的(first_n-first)个元素，
		而且，[first,first_n)中的元素按升序排序(后一版本中，使用cmp为排序规则)，[first_n,last)中的元素不排序。
	5. void sort(RandomAccessIterator first, RandomAccessIterator last);
		void sort(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering cmp);
		完成区间[first,last)的不稳定排序。（后一个版本使排序后的区间内相邻元素满足cmp(*(i+1),*i)==false（i为迭代器）。）
	6. void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
		void stable_sort(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering cmp);
		完成区间[first,last)的稳定排序。（后一个版本使排序后的区间内相邻元素满足cmp(*(i+1),*i)==false（i为迭代器）。）
	

----------------------------------------------------------------------------------------------------
2010.04.05

问题描述：为什么用私有继承不能实现运行时多态？

问题原因：人民邮电出版社.徐惠民.2005年.《C++大学基础教程》.P246有以下语句：
	要实现运行时的多态，需要以下条件：
		必须通过指向基类对象的指针访问和基类成员函数同名的派生类成员函数；
		或者用派生类对象初始化的基类对象的引用访问和基类成员函数同名的派生类成员函数；
		派生类的继承方式必须是共有继承；
		基类中的同名成员函数必须定义为虚函数。
		
解决方法：如上所述，私有继承和保护继承都不能实现运行时多态，要将继承方式改为公有继承，并将需要实现多态的成员函数修改为虚函数。
	
----------------------------------------------------------------------------------------------------
2010.04.07

问题描述：为什么#include <stdlib.h>后报错“std命名空间中没有名为long labs(long)的函数”？

问题原因：因为stdlib.h是C语言的函数，没有命名空间概念。

解决方法：改用#include <cstdlib>，long labs(long)在其中的std命名空间内。
	（顺便说一句，全局命名空间中的labs仍然有效（long ::labs(long)），放心用您的。）
	
----------------------------------------------------------------------------------------------------
2010.04.09

问题描述：如何在Visual Studio 2010里面设置全局引用目录(include)和库目录(lib)？

解决方法："View"->"Property Manager"(没看到蹦出来对话框？没错。它在左边的边栏里)->"Properties"(可以按里面的按钮，也可以在空白处右键)->"Configuration Properties"->"VC++ Directories"
	
----------------------------------------------------------------------------------------------------
2010.08.26

问题描述：size_t是在哪个头文件中定义的？

解决方法：在<cstddef>中定义，该文件定义了若干个标识符：
	类型：ptrdiff_t, size_t
	宏：NULL, offsetof

----------------------------------------------------------------------------------------------------
2010.08.27

问题描述：system()函数是在哪个头文件中定义的？

解决方法：在<cstdlib>中定义，该文件定义了getenv()和system()函数。

----------------------------------------------------------------------------------------------------
2010.08.28

问题描述：<stdexcept>头文件中有哪些成员？

解决方法：成员如下：

domain_error Class
 The class serves as the base class for all exceptions thrown to report a domain error.

invalid_argument Class
 The class serves as the base class for all exceptions thrown to report an invalid argument.

length_error Class
 The class serves as the base class for all exceptions thrown to report an attempt to generate an object too long to be specified.

logic_error Class
 The class serves as the base class for all exceptions thrown to report errors presumably detectable before the program executes, such as violations of logical preconditions.

out_of_range Class
 The class serves as the base class for all exceptions thrown to report an argument that is out of its valid range.

overflow_error Class
 The class serves as the base class for all exceptions thrown to report an arithmetic overflow.

range_error Class
 The class serves as the base class for all exceptions thrown to report a range error.

runtime_error Class
 The class serves as the base class for all exceptions thrown to report errors presumably detectable only when the program executes.

underflow_error Class
 The class serves as the base class for all exceptions thrown to report an arithmetic underflow.

----------------------------------------------------------------------------------------------------
2010.08.31

问题描述：在输入流中，如何把读到的一个字节放回到输入缓冲区中？

解决方法：istream& istream.putback(char c);

----------------------------------------------------------------------------------------------------
2010.08.31

问题描述：在输入流中，如何提取缓冲区第一个字符而不造成读取指针变化？

解决方法：int istream.peek();

----------------------------------------------------------------------------------------------------
2010.08.31

问题描述：在输入流中，如何读取一个以回车结尾的行字符串，而不读取回车？

解决方法：
	istream& istream.get( char* buffer, streamsize num );
	istream& istream.get( char* buffer, streamsize num, char delim );

----------------------------------------------------------------------------------------------------
2010.08.31

问题描述：istream.getline(char* buf, streamsize size)最多读取多少字节？

解决方法：size-1。

----------------------------------------------------------------------------------------------------
2010.09.20

问题描述：如何处理double类型的NaN数据？

解决方法：1.#include <limits>
		using namespace std;
		bool numeric_limits<double>::has_quiet_NaN
		double numeric_limits<double>::quiet_NaN
		bool numeric_limits<double>::has_signaling_NaN
		double numeric_limits<double>::signaling_NaN
	2.#define NAN (0.0/0.0)
	#define IS_NAN(val) ((val)!=(val))

----------------------------------------------------------------------------------------------------
2010.09.23

问题描述：有没有比较搞笑的模板使用方法？

解决方法：有的是。
	1.	template <typename T,
			template<typename> Comp=greater>
		class Select							//没有实际作用，就是演示模板用法
		{
		public:
			T operator () (T* first, T* last)
			{
				if (first>=last)
					return T();
				T val=*first++;
				Comp<T> comp;					//注意：亮点！
				while (first!=last)
					if (!comp(val,*first))
						val = *first;
				return val;
			}
		};

----------------------------------------------------------------------------------------------------
2010.10.10_20'18

问题描述：如何使用C++实现通用的“字符串转为其他类型”函数？

解决方法：

	#include <sstream>
	
	template <typename T>
	T cast(const char* str)
	{
		std::stringstream ss;
		ss << str;
		T val;
		ss >> val;
		return val;
	}

----------------------------------------------------------------------------------------------------
2010.10.14_10'09

问题描述：在C++中能否直接引用C风格头文件？

解决方法：在Linux下测试，可以直接引用<math.h>，内部函数位于全局命名空间。

----------------------------------------------------------------------------------------------------
2010.10.16_02'21

问题描述：如何安装boost库？

解决方法：
	在Windows上，根据文档向导所示：
		1. 启动Visual Studio 命令行，将文件夹cd到boost文件夹根目录
		2. 输入命令bootstrap，回车
		3. 输入命令bjam --prefix=D:\Libraries\boost --build-type=complete install，回车
		4. 耐心等待，卡住了也不要管，直至安装完成。
	在Linux上，根据文档向导所示：
		1. 开启一个终端，cd到boost文件夹根目录
		2. 输入命令./bootstrap.sh，回车
		3. 输入命令sudo ./bjam install，回车（需要系统权限）
		4. 耐心等待，直至安装完成

----------------------------------------------------------------------------------------------------
2010.10.17_15'23

问题描述：在Visual Studio 2005中，为什么空项目不能调试？如何解决？

问题原因：在空项目中不生成调试文件pdb，所以无法调试。

解决方法：
	项目->属性->配置属性->链接器->调试->生成调试信息->是
	项目->属性->配置属性->C/C++->常规->调试信息格式->C7兼容
	项目->属性->配置属性->C/C++->优化->优化->禁用
	(参考：http://blog.163.com/cjp19900228@126/blog/static/12016225720105514314590/)

----------------------------------------------------------------------------------------------------
2010.11.13_18'41

问题描述：下面的语句，为什么第一行不会报错？为什么第二行会报错？
	string string, str;
	string str1;

问题原因：
	1. 第一行不会报错，是因为局部变量string是在类型名string之后出现的，不会导致类型名解析为变量，不会出错；
	2. str在变量string之后出现，但因为这种声明语法表示str的类型是变量string出现之前的类型名string，所以也不会出错；
	3. str1的声明，试图使用类型名string，但此时变量string已经覆盖了str1所处的作用域中所有其他的与string同名的元素，所以编译器认为str1前面的string是变量名，而不是类型名，因此出现声明错误；

解决方法：
	1. 尽量不要以类型名命名变量，这样看起来很帅气，实际很危险；
	2. 在名称空间已经被污染之后，使用作用域操作符(::)来指明到底要用哪一个名称，如下所示：
		string string,str;
		std::string str1;
		::string str2;

----------------------------------------------------------------------------------------------------
2010.11.14_18'04

问题描述：使用new int[10]能否初始化？

解决方法：能，但只能进行默认初始化，语法为：new int[10]();
	如果试图用初值初始化（new int[10](3)），则编译报错。

----------------------------------------------------------------------------------------------------
2010.11.14_21'04

问题描述：如何在Linux下使用boost库编写程序？

解决方法：在Linux下,使用库文件需要在编译选项中指明所使用的库，所以只把库所在文件夹给出是没有用的。
	makefile中相关配置如下：


	# BOOST_INC_DIR: where the boost headers (ie. header directory "boost/") are
	BOOST_INC_DIR = /usr/local/include
	
	# BOOST_LIB_DIR: where the boost binary libraries are
	BOOST_LIB_DIR = /usr/local/lib
	
	# INC_BOOST: used to add all boost headers to include path
	INC_BOOST = -I$(BOOST_INC_DIR)
	
	# LIB_BOOST: used to add all boost libraries to compile path
	LIB_BOOST = -L$(BOOST_LIB_DIR) \
		-lboost_date_time \
		-lboost_filesystem \
		-lboost_graph \
		-lboost_math_c99 \
		-lboost_math_c99f \
		-lboost_math_c99l \
		-lboost_math_tr1 \
		-lboost_math_tr1f \
		-lboost_math_tr1l \
		-lboost_prg_exec_monitor \
		-lboost_program_options \
		-lboost_random \
		-lboost_regex \
		-lboost_serialization \
		-lboost_signals \
		-lboost_system \
		-lboost_test_exec_monitor \
		-lboost_thread \
		-lboost_unit_test_framework \
		-lboost_wave \
		-lboost_wserialization \
	
	exec : *.cpp
		c++ *.cpp -o a $(INC_BOOST) $(LIB_BOOST)

----------------------------------------------------------------------------------------------------
2010.11.18_12'37

问题描述：如何在一个局部作用域内，强制使用一组重载函数中的某一个？

解决方法：使用函数的局部声明，根据C++的名字查找和作用域覆盖规则，将屏蔽掉重载函数名。
	具体实例如下：
	void print(char*);
	void print(int);
	void print(double);
	int test()
	{
		void print(int);
		print(30);	//use void print(int)
		print(2.5);	//use void print(int)
	}

----------------------------------------------------------------------------------------------------
2010.11.18_13'29

问题描述：在#include <iostream>之后，如果需要使用istream或ostream，是否还需要单独#include <istream>或<ostream>？

解决方法：不用。iostream类继承自istream和ostream，即如果我们能看到iostream类，就一定能看到istream类和ostream类，不用单独引用这两个相应的头文件。

----------------------------------------------------------------------------------------------------
2010.11.19_16'36

问题描述：编译器如何确定拷贝构造函数和赋值运算符的选择？

解决方法：
	A a; 
	A b(a);//调用拷贝构造函数 
	或 
	A b=a;//仍然调用拷贝构造函数 
	  
	A a; 
	A b; 
	b=a;//这样才能调用赋值运算符 

----------------------------------------------------------------------------------------------------
2010.11.20_20'08

问题描述：如何编写工具代码，得到一个数组的大小？

解决方法：
	1. 使用常规方法，sizeof：
		#define ARRAY_LENGTH(arr) (sizeof(arr)/sizeof(arr[0]))

	2. 使用模板函数：
		template <typename T, size_t N>
		inline size_t ArrayLength(T (&arr)[N]) {return N;}

----------------------------------------------------------------------------------------------------
2010.11.21_14'21

问题描述：在位域定义中，可否将同一字节内的不同位赋予不同的访问权限？

解决方法：可以，示例如下：
	class BitField
	{
	public:
		unsigned char a:2;
	protected:
		unsigned char b:2;
	protected:
		unsigned char c:2;
	};
	//sizeof(BitField)==1;

----------------------------------------------------------------------------------------------------
2010.11.23_19'13

问题描述：如何使用C++读取一个目录下的所有文件（夹）名？

解决方法：使用操作系统目录命令和C++ system()函数，代码如下（Windows为例）：

	system("dir /B > input.txt");
	ifstream fin("input.txt");
	cout << fin.rdbuf();
	fin.close();
	system("del input.txt");

----------------------------------------------------------------------------------------------------
2010.12.01_09'19

问题描述：在继承层次中，如果基类定义了重载的虚函数，在派生类中能否只覆盖其中一个重载，而复用其他重载？

解决方法：能。只要在派生类中public区块指定using Base::FuncName（没有括号），再重载需要的形式即可。代码如下：

	class A
	{
	public:
		virtual void func() {cout << "A::func()" << endl;}
		virtual void func(int i) {cout << "A::func(" << i << ")" << endl;}
	};
	
	class B1: public A
	{
	public:
		void func() {cout << "B1::func()" << endl;}
	};
	
	class B2: public A
	{
	public:
		using A::func;
		void func() {cout << "B2::func()" << endl;}
	};
	
	int main()
	{
		A a;
		a.func();
		a.func(1);
		B1 b1;
		b1.func();
		//b1.func(2); //error
		B2 b2;
		b2.func();
		b2.func(3);	
	}
	
	输出如下：
	
	A::func()
	A::func(1)
	B1::func()
	B2::func()
	A::func(3)

----------------------------------------------------------------------------------------------------