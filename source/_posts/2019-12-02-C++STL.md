---
title:  "C++ && STL 知识点"
date:   2019-12-02 10:16:18 +0800
categories:
- C++
tags:
- STL 
- C++
---

这篇文章主要记述了STL和一些C++的知识点。
<!--more-->



![P6150569](https://i.loli.net/2020/04/08/EBwdnzF3LA8M2Js.jpg)

# C++类对象内存分布

先选择左侧的C/C++->命令行，然后在其他选项这里写上/d1 reportAllClassLayout，它可以看到所有相关类的内存布局，如果写上/d1 reportSingleClassLayoutXXX（XXX为类名），则只会打出指定类XXX的内存布局。

![image-20200408220704507](https://i.loli.net/2020/04/08/EUFLn3IeTGxRVC1.png)

下面可以定义一个类，像下面这样：



```cpp
class Base
{
	int a;
	int b;
public:
	void CommonFunction();
};
```

然后编译一下，可以看到输出框里面有这样的排布：

```c
class Base Size（8）：
	+---
0  | a
4  | b
	+---
```

再看下继承：



```cpp
class Base
{
	int a;
	int b;
public:
	void CommonFunction();
};
class DerivedClass : public Base
{
	int c;
public:
	void DerivedCommonFunction();
};
```

编译，然后看到如下的内存分布（父类的内存分布不变，这里只讨论子类成员变量的内存分布）：

![image-20200408230007485](https://i.loli.net/2020/04/08/9ndhA5vNu2Y3Z4b.png)

可以看到子类继承了父类的成员变量，在内存排布上，先是排布了父类的成员变量，接着排布子类的成员变量，同样，成员函数不占字节。(创建对象不会为成员函数分配空间。成员函数放在代码区，多个对象共享。函数本身是用来操作数据的，函数本身并不占用内存，只有再运行时才占用一点堆栈空间和寄存器空间~)

下面给基类加上虚函数，暂时注释掉DerivedClass，看一下这时的内存排布：

![image-20200408221832508](https://i.loli.net/2020/04/08/sdKoWFVOIyLJeNf.png)

这个内存结构图分成了两个部分，上面是内存分布，下面是虚表，我们逐个看。VS所带编译器是把虚表指针放在了内存的开始处（0地址偏移），然后再是成员变量；下面生成了虚表，紧跟在&Base1_meta后面的0表示，这张虚表对应的虚指针在内存中的分布，下面列出了虚函数，左侧的0是这个虚函数的序号，这里只有一个虚函数，所以只有一项，如果有多个虚函数，会有序号为1，为2的虚函数列出来。

编译器是在构造函数中创建这个虚表指针以及虚表的。

**那么编译器是如何利用虚表指针与虚表来实现多态的呢**？

是这样的，当创建一个含有虚函数的父类的对象时，编译器在对象构造时将虚表指针指向父类的虚函数表；

同样，当创建子类的对象时，编译器在构造函数里将虚表指针指向子类的虚表（这个虚表里面的虚函数入口地址是子类的）。

所以，如果是调用Base * p = new Derived();生成的是子类的对象，

在构造时，子类对象的虚指针指向的是子类的虚表，

接着由Derived * 到Base*的转换并没有改变虚表指针，

所以这时候p->VirtualFunction，实际上是p->vfptr->VirtualFunction，

它在构造的时候就已经指向了子类的VirtualFunction，

所以调用的是子类的虚函数，这就是多态了。

```cpp
class Base
{
	int a;
	int b;
public:
	void CommonFunction();
	void virtual VirtualFunction();
}
```

下面加上子类，并在子类中添加虚函数，像下面这样：



```cpp
class Base
{
	int a;
	int b;
public:
	void CommonFunction();
	void virtual VirtualFunction();
};
class DerivedClass : public Base
{
	int c;
public:
	void DerivedCommonFunction();
	void virtual VirtualFunction();
};
```

可以看到子类内存的排布如下：

![image-20200408223716252](https://i.loli.net/2020/04/08/1w8OVhK3Zt7uXMj.png)

上半部是子类的内存分布，可以看到，虚表指针被继承了，且仍位于内存排布的起始处，下面是父类的成员变量a和b，最后是子类的成员变量c，注意虚表指针只有一个，子类并没有再生成虚表指针了；下半部的虚表情况与父类是一样的。

我们把子类换个代码，像这样：

```cpp
class DerivedClass1 : public Base
{
	int c;
public:
	void DerivedCommonFunction();
	void virtual VirtualFunction2();
};
```

注意到这时我们并没有覆写父类的虚方法，而是重声明了一个新的子类虚方法，内存分布如下：

![image-20200408223948030](https://i.loli.net/2020/04/08/GwLDUsXnCmYANkZ.png)

还是只有一个虚表指针，但是下方虚表的内容变化了，虚表的0号是父类的VirtualFunction，而1号放的是子类的VirtualFunction2。也就是说，如果定义了DerivedClass的对象，那么在构造时，虚表指针就会指向这个虚表，以后如果调用的是VirtualFunction，那么会从父类中寻找对应的虚函数，如果调用的是VirtualFunction2，那么会从子类中寻找对应的虚函数。

更多关于虚继承、多重继承请参阅https://blog.csdn.net/songshiMVP1/article/details/51253387

# 虚函数与纯虚函数

![image-20200408092835255](https://i.loli.net/2020/04/08/zArc8lmLiNwWB51.png)



5. 子类可**自主选择**是否要提供一份属于自己的个性化虚函数实现。
6. 子类**必须提供**一份属于自己的个性化纯虚函数实现。



![B33DC6CEA3480F8E912BDF9B93AAC158](https://i.loli.net/2020/04/08/7bUA4gKm98EFpYq.png)

C++的编译器一旦发现一个类型中有虚函数，会为该类型生成虚函数表（vtbl），并在该类型的每一个实例中添加一个指向虚函数表的指针（vptr）。

通常，编译器处理虚函数的方法是：
　　给每个对象添加一个隐藏成员；隐藏成员中保存了一个指向函数地址数组的指针。
　　其实这里的函数地址数组指的就是虚函数表（virtual function table),vtbl。
　　虚函数表中存储了为类对象进行声明的虚函数的地址。

　　例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。
　　如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址，如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。
　　如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中，注意，无论类中包含的虚函数是一个还是多个，都只需要在对象中添加一个地址成员，只是表的大小不同。

------------------------------------------------
1. 每个对象都将增大，增大量为存储地址的空间
2. 对每个类，编译器都创建一个虚函数的地址表
3. 每个函数调用都需要执行一步额外的操作，即到表中查找地址

### 析构函数必须为虚函数

如果不是虚函数，则使用时可能存在内在泄漏的问题。

如果我们以下面这种方式创建对象，不管析构函数是否是虚函数，delete时基类和子类都会被释放。

```C++
SubClass* pObj = new SubClass();
delete pObj;
```

```c++
BaseClass* pObj = new SubClass();
delete pObj;
```

- 若析构函数是虚函数，delete时基类和子类都会被释放；
- 若析构函数不是虚函数，delete时只释放基类，不释放子类；

## 虚函数

定义一个函数为虚函数，不代表函数为不被实现的函数。
定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

>这里补充一下抽象类和接口的异同：
>
>抽象类（abstract）是只能继承一次，接口却可以实现多个；
>
>接口是个集合，并不是类，类描述了属性和方法，而接口只包含方法（未实现的方法）;
>
>接口和抽象类一样不能被实例化，因为不是类;
>
>但是接口可以被实现（使用 implements 关键字）。
>
>实现某个接口的类必须在类中实现该接口的全部方法。
>
>
>
>抽象类虽然不能实例化来使用，但是可以被继承，让子类来具体实现父类的所有抽象方法。有点像老子没完成的梦想交给儿子来完成，但是如果子类将抽象方法没有全部实现，就必须把自己也修饰成抽象类，交于继承它的子类来完成实现。就相当于，儿子能力不够也没完成老爹的梦想，现在儿子等着再生儿子（被继承），然后让孙子去完成。以此类推，直到没有抽象函数。
>
>接口的实现，通过implements关键字。实现该接口的类，必须把接口中的所有方法给实现。不能再推给下一代。和抽象类相比，抽象类是将梦想传给家族，一代一代去完成。那么接口就是掌门人找大师兄来完成帮派的鸿星伟业，这时候就只有一次希望，要么有能力就实现，没能力就不要接。
>
>
>
>作者：IT废柴
>链接：https://www.jianshu.com/p/038f0b356e9a
>来源：简书
>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 纯虚函数

虚函数的声明以`=0`结束，便可将它声明为纯虚函数。包含纯虚函数的类不允许实例化，称为**抽象类**。 事实上纯虚函数提供了面向对象中接口的功能。当然，这样的接口是以继承的方式实现的。

纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”



虚函数的意义，就在于定义了一个从最早的父类，到最后的子类，都必须具备的一个功能（函数），只是在不断的进化（继承）中，这个功能会略微发生改变。通过虚函数，我们在调用不同的衍生类的时候，可以拥有不同的功能。然后我会说：这么麻烦，干脆每个继承类都重写命名一个函数么算了，只要知道重命名的函数有这个功能就行了不是？理论上来说，完全可以，在一个父类和其继承类不多的项目中，这么做完全可以，只要你自己能熟记或者找到这个重命名函数是干嘛用的；但是在大一点的项目中，由于类中的函数成百上千，恐怕你就会为此疯狂。另外还有一点，是重命名函数无法做到的，这一点我会在纯虚函数中一并解释。

纯虚函数，就是虚函数了以后，末尾还要加=0的那一类函数。我一直没想通的是，既然这个函数完全没有实现方法，那么定义这个函数有个蛋用啊？我也曾经试着在网上搜索过纯虚函数的意义和作用，回答大多千篇一律照本宣科。于是我渐渐的也就无视这个纯虚函数了。直到现在我开始写一个PSO算法的时候，才发现天哪这居然是一个完全不可或缺的东西！如果说虚函数还可以用重命名作为另外一种解决方法，那么纯虚函数则是没有第二种可以替代的方法。我可以拿一个非常简单的代码说明一下：

```c++
class test{ 
public:
	virtual void print();
   virtual void order()=0; 
   int array[20]; 
 };
```

上面声明了一个非常简单的类，它只有两个函数，其中一个是虚函数：打印，另外一个是纯虚函数：排序。其中打印函数的定义如下:

```c++
void test::print(){ 
order();
printf('打印结果： '); 
for(int i=0; i<20; i++) 
	printf('%d ', array);
 }
```

在这个打印函数中，调用了order函数对array进行了排序，然后输出结果。问题是：我根本不知道order函数是什么算法，或者说order函数因人而异，所以无法确定！于是网上照本宣科的内容就出来：当函数没有实现方法或者需要子类来定义实现方法的时候，可以在父类中定义纯虚函数。就是这么简单！于是当不同的子类继承这个父类的时候，定义不同的实现方法，那么实例化这个子类的时候，这个纯虚函数就有了不同的方法。这也解释了为什么包含纯虚函数的抽象类为什么不能实例化，因为它中间有函数根本不知道是怎么个实现！当然我们可以用其他方法避免使用纯虚函数，比方说在子类中重写print方法，但是这样一来等于除了order函数代码以外所有的代码都要重新复制一遍，当继承类越来越多的时候，要修改print等于这一堆继承类都要修改，会疯的！所以说纯虚函数是一个很神奇的用法，也是简化了编程使得面向对象的方法更加灵活。

至于接口，这是一个只有JAVA中才用到的概念，C++中不存在接口，与接口相似的是：抽象类。因为JAVA不允许多重继承类，但可以继承多个接口。关于接口，在我编写JAVA SERVLET的时候，碰到过一个httpservlet，用户需要为doget和dopost等函数编写实现方法。而这些函数就可以看成是纯虚函数，它在HTTPservlet也类似于上述代码的order函数，有着在局部函数中的作用。

面向对象编程确实很有意思，虽然从某种程度上来说，和面向过程也差不多，但是灵活多变的设计方法，也许也是C++（面向对象）比C（面向过程）强大的地方.

## 虚函数总结0409


基类如果有函数前面加了virtual，那么构造器会为每个基类的实例增加一个隐藏的虚函数表指针，指向一张虚函数表，虚函数表记录着基类的虚函数信息。当派生类继承基类的时候，也会把基类的虚函数表指针继承下来，就不生成新的指针了。该指针就指向派生类自己的虚函数表，如果派生类选择重写基类的虚函数，那么就会在自己的虚函数表里新增一个自己的虚函数记录！如果选择不重写，那么派生类也会有一个指向基类虚函数的指针！
当我们new一个派生类对象并且把它的引用赋值给基类引用时，它的虚函数表指针指向的还是自己的虚函数，所以就可以实现通过基类的引用或指针来调用派生类的方法从而实现运行时多态了……
由于函数只是对数据的加工，编译的时候会放到代码段，所以内存模型里不会出现函数……



# const

```cpp
const int& fun(int& a); //修饰返回值
int& fun(const int& a); //修饰形参
int& fun(int& a) const{} //const成员函数
```

如果写的函数需要传入一个指针，面试官可能会问是否需要为该指针加上const，把const加在指针不同的位置是否有区别？（左定值右定向）

如果写的函数需要传入的参数是一个复杂类型的实例，面试官可能会问传入值参数和传入引用参数有什么区别，什么时候需要为传入的引用参数加上const?

- 如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数。如果你把复制构造函数的传入参数设置为实例，这样会导致复制构造函数内调用复制构造函数，形成无休止的递归调用从而导致堆栈溢出。同时，如果我们在函数内部不改变传入的实例的状态，应该在传入的引用参数前加上const。

![4D76BDE38E95CF045BB00DF2851C9DC4](https://i.loli.net/2020/04/08/LOWJmhx9GfaZ2Si.png)

## 1、const返回值

这种多是修饰返回值是引用类型的情况下，为了避免返回值被修改的情况。

解释下：返回值是引用的函数， 可以肯定的是这个引用必然不是临时对象的引用（栈上的对象在返回后就消失了，自然也就不存在临时对象的引用这么一说了）， 因此一定是成员变量或者是函数参数（对象new出来是在堆上，成员变量也在堆上）， 所以在返回的时候为了避免其成为左值（下面这个例子很好的说明了什么是左值被修改）被修改，就需要加上const关键字来修饰。

举个例子：

```cpp
#include<iostream>

using namespace std;

class A
{
private:
    int data;
public:
    A(int num):data(num){}
    ~A(){};
    int& get_data()
    {
        return data;
    }
};

int main()
{
    A a(1);
    a.get_data()=3;
    cout<<a.get_data()<<endl; //data=3
    return 0;
}
```

那么这个时候为了避免成员函数被修改就需要加上const关键字，这个时候如果试图改变返回值是不允许的：

```text
error: cannot assign to return value because function 'get_data' returns a const value
```

需要指出的是，如果函数的返回类型是内置类型，比如 int char 等，修改返回值本身就是不合法的！所以 const 返回值是处理返回类型为用户定义类型的情况。

## 2、const 修饰实参

多数情况下，我们都会选择 pass by reference，这样可以节省内存，并且可以起到改变实参的目的。不过有的时候我们并不希望改变实参的值，就要加上const关键字。

这个不仔细说了，很容易理解。不过在构造接口之前一定要思考函数是否会修改参数，如果不会修改的话一定要加上const，这个是代码写的是否大气的一个标准（侯捷大师原话）

## 3、const 成员函数

首先，面向对象程序设计中，为了体现封装性，通常不允许直接修改类对象的数据成员。

若要修改类对象，应调用公有成员函数来完成。

为了保证const对象的常量性，编译器区分不安全和安全的成员函数（即区分试图修改类对象与不修改类对象的函数），例如：

```C++
const Person man;
man.eat();	//对象的读操作
man.set(age = 34);	//错误：const 类对象不允许修改
```

**在C++中，只有被声明为const的成员函数才能被一个const类对象调用。**

 要声明一个const类型的类成员函数，只需要在成员函数参数列表后加上关键字const，例如，



```cpp
class Person{
    public:
    bool set(int age) const;    
}
```

const 修饰成员函数， 根本上是修饰了 this 指针。

在成员函数参数列表后面加上const修饰，表示函数内this指针是一个指向常量对象的指针，**不能修改成员变量**。

```C++
void Person::setName(string name) const
{
    this->name = name;
} //错误，const成员函数不能修改成员变量
```



> 补充this指针：
> 每个对象拥有一个this指针，通过this指针来访问自己的地址。
>
> this指针并不是对象的一部分，this指针所占的内存大小是不会反应在sizeof操作符上的。
>
> 在普通成员函数中，this是一个指向非const对象的const指针（如类类型为Student，那么this就是Student *const类型的指针）;
> 在const成员函数中，this指针是一个指向const对象的const指针（如类类型为Student，那么this就是const Student * const类型的指针)
>
> 对于const对象或者const对象的引用和指针，对象内的成员变量是不能修改的，因此只能调用const成员函数，不会修改成员变量
> 对于非const对象，既可以调用const成员函数，也可以调用非const成员函数。

![A171910534B481CF8D7F8866CDF1FB32](https://i.loli.net/2020/04/08/Twn25A1GWfD7izu.png)









# 向上/下强制转换

- 将派生类引用或指针转换为基类引用或指针被称为向上强制转换。

- 将基类引用或指针转换为派生类引用或指针被称为向下强制转换。

如果不使用显示类型转换，向下强制转换是不允许的，因为is-a关系是不可逆的。

比如香蕉是水果，但是水果不是香蕉。派生类香蕉可以新增数据成员，因此这些数据成员不能应用于基类水果，比如香蕉中有黄色，但是不是所有水果都是黄色的。



# STL

STL有六种序列容器类型：

- 1 Vector:相当于一个数组，在内存中分配一块连续的内存空间进行存储；STL内部实现时首先分配一个非常大的内存空间预备进行存储（可以通过capacity()函数返回其大小）
- 2 List：双向链表
- 3 Deque:双端队列
  人们习惯上把程序员分三个等级，知其然，知其所以然，造其所以然

## hash

hash也称散列，哈希。基本原理就是将**任意长度**的输入变成**固定长度**的输出。这个映射的规则就是哈希算法，而原始数据经过映射形成的二进制字符串就是哈希值。开发中的MD5和SHA都是历史悠久的哈希算法。

```python
echo md5("This is a test md5!");
//output 2124968af757ed51e7abecd04f98e
```



### hash的优点

1 不能从hash值反向推导出原始的数据

2 输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值

3 哈希算法的执行效率要高效，长的文本也能快速的计算出哈希值

4 哈希算法的冲突概率要小

由于哈希的原理就是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间，根据鸽笼原理，一定会存在不同的输入被映射成相同输出的情况。

### hash碰撞的解决方案

前面提到了哈希算法是一定会有碰撞的，那么如果我们遇到了hash冲突需要解决的时候该怎么处理呢？常用的方法就是 **链地址法**和**开放地址法**。

开放地址法就是构造一个M的数组保存N个键值对（M>N)。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所以方法统称为“开放地址法”。线性探测法，就是比较常见的一种实现方式。它的核心思想是当冲突发生时，顺序查看表的下一个单元，直到找到一个空单元或查遍全表。只要散列表足够大，空的散列地址总能找到。

## Array

就是个数组，不能扩充。

## Vector

vector的增长是2倍2倍的扩充容量（capacity）,注意这里不是在原来的基础上成长：它是在另外的地方找一个两倍的空间然后一个一个元素搬过去。。。。。。所以vector的size是元素的数量，但是capacity却是扩充 的2的倍数。补充：容器的data指的是在内存中首元素的地址。

## List

list与vector不同，它是采用的环状双向链表

某些容器（如list）自带sort，这个要比全局的sort要快

![](https://i.loli.net/2019/12/06/2eK3CMPjGTDgvmX.png)

![](https://i.loli.net/2019/12/08/fK1yzJdoSA7VRWg.png)

c++中箭头运算符->，相当于把解引用和成员访问符两个操作符结合在一起，换句话说，

p->func()和(*p).func()所表示的意思一样。

地址->一个东西   *ite去解引用了ite这个地址
&（*ite）又取回来这个地址

## Deque

分段连续，类似于二维指针：由一个指针指向一个缓冲区

![](https://i.loli.net/2019/12/02/G4CH2ypvqLIKT9M.png)

![](https://i.loli.net/2019/12/08/qOHBIDR8TVUbaGp.png)

- 这里：node指向deque的控制大脑，first指向某一段的开头，last指向某一段的结尾，前闭后开区间，cur指向当前的这一段里面的节点。当走到头时，会由node进行段的切换；

- 控制中心是一个vector。如果你想在前面插入的话，且前面空间不够了，你依旧也是需要开辟一个2倍原来空间的控制中心区域一个一个的拷贝构造一下。但是它很狡猾的拷贝到2倍区域的中段来，这样可以让首尾控制中心的扩充更为均衡一些；

- start与finish指向的是deque中所有元素的首跟尾；

![](https://i.loli.net/2019/12/08/mDnCTt48ZzyhaXF.png)

- 区分前++与后++的方法是：后++会传int的形参，这是规定

- 后++会生成一个临时的tmp对象，然后对原对象进行前++操作，再把tmp对象返回

- ### self的用处是？？？？？

![](https://i.loli.net/2019/12/08/wAq2eMDOSRUjl5a.png)

![](https://i.loli.net/2019/12/08/VQPYsLJjzCTWnfr.png)

![4.9](https://i.loli.net/2019/12/08/aKpUckOP2NVDQJl.png)

![](https://i.loli.net/2019/12/08/TQuPz1cew8p6atl.png)

![](https://i.loli.net/2019/12/08/1ntR6YcLUVMK7WO.png)

## Map

multimap<key,value>//multi允许重复

snprintf(buf,10,"%d",rand（）)；//如果格式化后的字符串长度 >= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符('\0')，返回值为欲写入的字符串长度

```c
#include <stdio.h>
 
int main () {
  char a[16];
  size_t i;
 
  i = snprintf(a, 13, "%012d", 12345);  // 第 1 种情况 12位宽
  printf("i = %lu, a = %s\n", i, a);    // 输出：i = 12, a = 000000012345
 
  i = snprintf(a, 9, "%012d", 12345);   // 第 2 种情况 0000 0001 2345
  printf("i = %lu, a = %s\n", i, a);    // 输出：i = 12, a = 00000001
 
  return 0;
}
```



c.insert(pair<long,string>(i,buf))

- multimap不可以用[作Insertion,map却可以，注意重复与不重复.

## OOP：&GP：Generic Programming

Object-Oriented-Programming

GP 可以使得两个团队可以专注于闭门造车

OOP相当于菜谱（数据相当于原材料，方法相当于烹饪步骤）

标准库用的全局的：：sort排序需要的是RandomAccessIterator，随机的迭代器，而list不能随意的像数组那样一下子蹦5个单元，所以List不能使用全局的：：sort排序。

## Template

类模板与函数模板

![](https://i.loli.net/2019/12/03/caYW31lkdThB7qR.jpg)

![](https://i.loli.net/2019/12/03/NKdZD8fH1anhATQ.jpg)

类模板如果不进行<double> <int>的绑定，它不知道该给T初始化为多少？毕竟2.5初始化为float也行，初始化为double也行。

但是函数模板就不一样了，因为编译器可以进行类型推导，从r1那个Stone r1就可以推出T的类型，进而重载Stone类的<操作符。

```c++
template<class T>和下面相同  
template<typename T>
class complex{};
```



## 泛化与特化

- 类模板中我可以通过T来形成各种各样的类的蓝图。但是如果你是一种特定的类型比如int，我可以提供给你一种更为有效的做法，这就叫做特化。

![特化](https://i.loli.net/2019/12/03/KFsXC3H18rieR4S.png)

- template<>有时候是__STL_TEMPLATE_NULL

- 以上是FULL 特化，还有偏特化    Partial Specialization

  <img src="https://i.loli.net/2019/12/03/w2KsNOf4ypomkzG.png" style="zoom:75%;" />
  
  
  
  
  
  
  
## traits

  萃取，特征，一种人为制造的萃取机器：我丢给它一些东西，它可以萃取出我想要的特征

  iterator_category：描述了迭代器的性质：有的迭代器可以一往无前的向前冲++，有的还可以后退--，有的可以跳着走......

  diffrence_type：两个迭代器之间的距离用啥来表示？比如int表示你的容器的两个迭代器的距离范围最大是2^32。一般设为ptrdiff_t，是一个Unsigned long类型的

  value_type：迭代器所指的容器里面的元素的类型

```c
template<typename _Tp> inline
Mat_<_Tp>::Mat_(int _rows, int _cols)
    : Mat(_rows, _cols, traits::Type<_Tp>::value)
{
}
```

   traits::Type<_Tp>::value

我对这段话的理解是，cv::DataType<>是一个模板类，当OpenCV中库函数需要传递特定数据类型的某些概念信息时，那么就可以通过创建cv::DataType<> 类型的对象来实现。我们使用的不是它本身，而是它特定的实例化对象。C++中这种用法叫做Traits。

  说实话，第一次看这一篇章，我也没有看懂cv::DataType<>到底是做什么用的，不过下面讲解一下Traits后，就能明白上面说意思了。

  简单来说，如果我们封装了一个算法，这个算法可能会由于输入数据类型的不同导致算法内部处理逻辑的不同（比如说传入的是int类型我们做一种操作，而传入的是double类型我们将进行另外一种操作），而我们并不想由于这种原因修改算法的封装时，Traits就派上用场了，它可以帮我们很方便的实现功能，而又不破坏函数的封装。
  Traits在开发者中运用特别多，主要也就是为了解决用户的负担，让一些复杂逻辑处理留给开发者来做，用户只需要根据要求调用API函数即可。

  https://blog.csdn.net/XiangJiaoJun_/article/details/84843194![](https://i.loli.net/2019/12/06/5FO9TWbmznukGlx.png)

## RB_Tree

关联式容器。红黑树。散列表。

- 红黑树的++操作类似于中序遍历，它是按照元素增大的顺序进行遍历的
- 我们不应该使用红黑树的迭代器进行修改值的操作：因为会破坏严谨的红黑树的平衡

## 二叉树

```c++
#include <iostream>
using namespace std;

typedef struct BinaryTree {
	BinaryTree *Lchild;
	BinaryTree *Rchild;
	int data;
}BinaryTree;
int Construct(BinaryTree **T) {
	int ch;
	cin >> ch;
	if (ch == -1) {
		*T = NULL;
		return 0;
	}
	else
	{
		*T = (BinaryTree *)malloc(sizeof(BinaryTree));
		if (T == NULL)
			cout << "malloc failed!" << endl;
		else
		{
			(*T)->data = ch;
			cout << "请输入" << ch << "的左子节点：" << endl;
			Construct(&((*T)->Lchild));
			Construct(&((*T)->Rchild));
		}
			

	}

}
int main(int argc, char **argv) {
	cout << "BinaryTree Construct Stage..." << endl;
	BinaryTree *Btree;
	cout << "请输入二叉树第一个节点的值，-1代表叶子节点..." << endl;
	Construct(&Btree);
	return 0;
}
```

BTree本来是一个指向BinaryTree的指针，

因为有小伙伴问了，可否在构建二叉树传入的参数为一级地址。上述的方法是一定要传二级参数的，但是这里给出一个传一级参数的方法，小伙伴也可以通过对比两种方法，对二叉树的构建和传参方式有更深的理解。

```c
struct TreeNode* Create(){
	int val;
	scanf("%d", &val);
	
	struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode*));
	if (val <= 0) {
		return NULL;
	}
	
	if (!root) {
		printf("创建失败\n");
	}
 
	if (val > 0) {
		root->val = val;
		root->left = Create();
		root->right = Create();
	}
	 
	return root;
}
```

## 从文本读取数据C++

包含头文件\#include <fstream>

逐词读取

逐行读取

	ifstream filestream("text.txt");
	if (filestream.is_open()) {
	
	}
![image-20191221120517828](https://i.loli.net/2020/03/30/buXMqazylTYwIBL.png)

## C++编程技巧Tips

- 定义变量的时候可以不用缩进然后避免在开头集中定义，又方便查找----侯捷

- 抽空研究一下快速排序，红黑树

- ：：find是循序查找， 

- 关键字typedef在编译阶段有效，由于是在编译阶段，因此typedef有类型检查的功能。

  \#define则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。

  typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。

  \#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。

  \#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。

  而typedef有自己的作用域。
  
  
  
- c++的一个语法：
  
  
  
  将typedef和typename关键字联用。
  
  ```
  template <class T,class Alloc=alloc>class vector{public://...typedef size_t size_type;//...};
  ```
  
  从vector的类定义可以看出，`vector::size_type`是`vector`嵌套类型定义，其实际等价于 `size_t`类型。
  
  ```
  vector<int>::size_type ssize;//就等价于size_t ssize;
  ```
  
  为什么要在typedef后面加上typename关键字？
  
  原因：
  
  实际上，模板类型在实例化之前，编译器并不知道`vector<T>::size_type`是什么东西，事实上一共有三种可能：
  
  > 静态数据成员
  > 静态成员函数
  > 嵌套类型
  
  那么此时`typename`的作用就在此时体现出来了——定义就不再模棱两可。
  
  `typedef`创建了存在类型的别名，而`typename`告诉编译器`std::vector<T>::size_type`是一个类型而不是一个成员。
  
  
  

## C++ string 成员函数 length() size() 和 strlen() 的区别

sizeof()是运算符，在编译期间就计算好了，所以对于字符串来说会统计到‘\0’的个数。（这都是早期落后的C故意设计的--字符串后面加一个\0，之后先进的length等函数都不用统计\0的个数了）

而size()是由于string 毕竟也是一个容器，容器会为了统一都有一个size()函数

size()、length()是c++中string的类的方法，只有string类的对象才可以用该方法，而字符串数组不可用，而strlen、strcpy等源于C语言的字符串处理函数库，需要include<string.h>,同时也只有字符串数组才可以用
size()与length()完全等同，遇到空字符不会被截断，可以返回字符串真实长度
strlen(),源于C语言，遇到空字符会截断，从而无法返回字符串真实长度
strlen同样也可以用于C++的string。但是需要用c_str()将C++ string转换为char*类型。

## 指针与引用

我们可以把引用理解成变量的别名。定义一个引用的时候，程序把该引用和它的初始值绑定在一起，而不是拷贝它。计算机必须**在声明r的同时就要对它初始化**，并且，r一经声明，就不可以再和其它对象绑定在一起了。

实际上，你也可以把引用看做是通过一个常量指针来实现的，它只能绑定到初始化它的对象上。

关于指针和引用的对比，可以参看<<more effective C++>>中的第一条条款，引用的一个优点是它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率

```c
int a,b,*p,&r=a;//正确
r=3;//正确：等价于a=3
int &rr;//出错：引用必须初始化
p=&a;//正确：p中存储a的地址，即p指向a
*p=4;//正确：p中存的是a的地址，对a所对应的存储空间存入值4
p=&b//正确：p可以多次赋值，p存储b的地址
```

对于指针来说，它是一个地址，这个地址是一个数值，那么就意味这个数值可以为0(空指针)，也可以为其他，即指针可以不指向任何东西。

而对于引用来说，他是一个外号，外号一定是“某个存在物体”的外号，所以引用不能为空，即不能存在空引用。

![04697FE33645E5C85A94D6323FA06C38](https://i.loli.net/2020/04/08/7lte6FOTBSIavL3.png)

![1760A8239D9C4A766A9B79CEF1E16A47](https://i.loli.net/2020/04/08/lZPaOrdvR4u32UF.png)

引用既然是张大胖的一个别名--大胖，就不能再让这个别名大胖指代别的人了，不然的话，故人提起大胖，你给我找出一个王大胖？这样不对吧，，，所以我们可以认为引用是指针常量，int * const 

1.如果一个引用和一个东西（这里再次使用“东西”这个词）绑定，那么它就永远只能是这个东西的“别名”，不能再说“其他人”的“别名”，即引用本身不能修改。但是，我们可以通过引用来修改它所引用的东西的值。

2.引用声明时必须同时初始化 ，且必须用左值初始化。（左值：就是可以用&求地址的量，换言之，就是有确定地址的量，而不是所谓的临时量）

​    对这些特性大家是不是似曾相识呢？没错，这些特性和“本身是常量的指针”(int* const p)的特性一样。事实上，我们完全可以借用“本身是常量的指针”来理解甚至定义引用：

**引用是一个指向不可变的、被编译器自动解引用的指针，即，引用是一个被编译器自动解引用的“本身是常量的指针”。**

看下面的代码

```
int a = 10;
int &ra = a;
ra = 11;
```

   在上面的代码中，编译器将int &ra=a转化为int* const ra=&a,而将ra=11转化为* ra=11，将ra自动转化为*ra的过程，就是上面定义中所说的“自动解引用”。

很显然，const int &ra=a就相当于const int* const ra=&a了。

## 拷贝构造

**拷贝构造函数必须以引用的方式传递参数**。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。

## 拷贝赋值

首先返回值得是一个引用哈，是为了：p1 = p2 = p3的这种递归赋值的情况；

然后注意形参是一个常量引用，成员函数后面加不加const呢？由于要修改this类的成员变量，所以不能加const

进入函数要先判断this指针的p1 = p1这种情况；

最后要把this类的原指针指向的内存释放一下，防止内存泄露

delete []m_pData;  m_pData = nullptr;

```c++
CMyString& CMyString::operator = (const CMyString& str)
{
    if(this == &str)
        return *this;

    delete []m_pData;
    m_pData = nullptr;

    m_pData = new char[strlen(str.m_pData) + 1];
    strcpy(m_pData, str.m_pData);

    return *this;
}
```



# 动态内存

到目前为止，我们编写的程序中所使用的对象都有着严格定义的生存期。全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时被销毁。局部static对象在第一次使用前分配，在程序结束时销毁。

除了自动和static对象外，C++还支持动态分配对象。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。

动态对象的正确释放被证明是编程中极易出错的地方。为了更安全的使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。

我们的程序到目前为止只使用过静态内存或栈内存。静态内存用来保存局部static对象：static int counter 函数调用次数。类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在：static对象在使用之前分配，在程序结束时销毁。

除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称为自由空间或堆。程序用堆来存储动态分配的对象---即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。

### 类static数据成员

![AE4A99F468247A2465144993271D3C22](https://i.loli.net/2020/04/08/AphFqMuRO3J1b2L.png)

有的时候类需要它的一些成员与类本身直接相关，而不是和类的各个对象保持关联。

例如，一个银行账户类需要一个数据成员来表示当前的基准利率。在此例中，我们希望利率与类关联，而非与类的每个对象关联。从实现效率的角度来看，没必要为每个对象都储存利率信息。而且更加中重要的是，一旦利率浮动，我们希望所有的对象都能使用新的值。

```c++
class Account{
    public calculate(){amount += amount * interestRate;}
    static double rate() {return interestRate;}
    static void rate(double);
    
    private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();    
}
```

类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。

### 动态内存与智能指针

Ｃ++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete，接受一个动态对象指针，销毁该对象，并释放与之相关联的内存。

为了更容易同时更安全地使用动态内存，新的标准库提供了两种智能指针类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。此外还有一个weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。

#### shared_ptr

shared_ptr<string> p1;

shared_ptr<list<int>> p2;

