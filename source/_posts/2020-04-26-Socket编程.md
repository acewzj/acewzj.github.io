---
title: Socket编程
tags:
  - socket
categories:
  - socket
date: 2020-04-26 18:55:26
---

这篇文章记述了关于Socket编程的知识点。

<!--more-->



## accept

`clntfd = accept(serfd,(struct sockaddr*)&servaddr,sizeof(clntaddr));`

`int accept(int sock,struct sockaddr* addr,socklen_t* addrlen);`

成功时返回创建的套接字文件描述符，失败时返回-1

为什么这里会再创建一个fd呢？

这是因为accept函数受理连接请求队列里面待处理的客户端的连接请求。函数调用成功后，accept函数内部会生成用于数据I/O的套接字，并返回其文件描述符。以下这幅图很形象的描述了这个过程：也就是说你客户端connect到我服务器listen的队列里，服务器有空了就从队列里取队头的客户端进行accept创建套接字进行连接。

它之所以被命名为套接字，就是说得配套，客户端人家是有connect给自动创建出来的fd，服务器先开始通过socket函数返回了文件描述符server_fd，这个是告诉进程可以通过像读写文件那样来进行网络通信

![image-20200401101317898](https://i.loli.net/2020/04/01/1gzbMQ6qr5VkNY7.png)



## connection refused

服务器正常启动，但是客户端一启动就在`connect`函数退出了，错误显示`connection refused`，单步调试也看不出什么来。

上网一看，有的人也碰到了类似问题，他们怀疑出现这个状况最大的可能是服务器正在监听程序，但是客户端并没有按照规矩的IP和端口号来给服务器发程序：这不有的人就是因为把服务器的`serv_addr.sin_port = htons(atoi(argv[1]));`写错为`serv_addr.sin_port = htonl(atoi(argv[1]));`导致端口号分配出错了。

![image-20200401092200981](https://i.loli.net/2020/04/01/2UY1yrgvwzsNjD8.png)

当然我也好不到哪里去？在使用telnet localhost 9000发现服务器正常好用之后，我坚信我的客户端程序出了问题：一行一行代码排查，终于发现`serv_addr.sin_port = htons(argv[1]);` 我特么忘了加atoi，这端口号肯定是错了啊【初始端口为9000，16进制为0x2328经过hostToNetShort后变成0x2823–>10275】

![image-20200401100250744](https://i.loli.net/2020/04/01/OcltiYzaLw89gv3.png)

![image-20200401100638777](https://i.loli.net/2020/04/01/L6Qp4ORXPeFi5UY.png)









## 不同socket地址结构对比

![image-20200401224452953](https://i.loli.net/2020/04/01/8ZcPnrdFHtVwW5D.png)



## 如何判断机器的大端与小端？

### 常见的字节序

一般操作系统都是小端，而通讯协议是大端的。

![image-20200401213715103](https://i.loli.net/2020/04/01/Nxpg5lwZLejzRTA.png)

```c
#define BigtoLittle16(A)  ((((uint16)(A) & 0xff00) >> 8) | 
							(((uint16)(A) & 0x00ff) << 8))
  
 
#define BigtoLittle32(A)  ((((uint32)(A) & 0xff000000) >> 24) |                                            						(((uint32)(A) & 0x00ff0000) >> 8) | \
                   (((uint32)(A) & 0x0000ff00) << 8) | \
                   (((uint32)(A) & 0x000000ff) << 24))
```



## 