---
title: C++输入输出
tags:
  - C++
  - Cin
categories:
  - C++
  - IO
date: 2020-04-26 22:31:42
---

这篇文章记述了关于C++输入输出的知识点。

<!--more-->



## 从文本读取数据C++

包含头文件\#include <fstream>

逐词读取

逐行读取

	ifstream filestream("text.txt");
	if (filestream.is_open()) {
	
	}

![image-20191221120517828](https://i.loli.net/2020/03/30/buXMqazylTYwIBL.png)

## Cin

在理解 cin 功能时，不得不提标准输入缓冲区。当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键（\r）会被转换为一个换行符（\n），这个换行符也会被存储在 cin 的缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了 123456 这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是 7 ，而不是 6。
cin 读取数据也是从缓冲区中获取数据，缓冲区为空时，cin 的成员函数会阻塞等待数据的到来，一旦缓冲区中有数据，就触发 cin 的成员函数去读取数据。

使用 cin 从标准输入读取数据时，通常用到的方法有 cin>>、cin.get()，getline(cin,str)

**当 cin>> 从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin>> 会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。**

**但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin>> 不做处理。**

```c
#include <string> 
#include <iostream>
using namespace std;

int main()
{
	char a;
	int b;
	float c;
	string str;
	cin>>a>>b>>c>>str;
	cout<<a<<" "<<b<<" "<<c<<" "<<str<<endl;

	string test;
	getline(cin,test);//不阻塞
	cout<<"test:"<<test<<endl;
	return 0;
}
```



![image-20200426223706565](https://i.loli.net/2020/04/26/RCx1y2sFrJUdMhc.png)

从结果可以看出，cin>> 对缓冲区中的第一个换行符视而不见，采取的措施是忽略清除，继续阻塞等待缓冲区有效数据的到来。但是，getline() 读取数据时，并非像 cin>> 那样忽略第一个换行符，getline() 发现 cin 的缓冲区中有一个残留的换行符，不阻塞请求键盘输入，直接读取，送入目标字符串后，因为读取的内容为空，所以程序中的变量 test 为空串。

> cin流在读取数据之后会把回车符之前的字符拿去传递给buf然后将回车符残留在cin流中，所以当getline在读取cin流的时候会第一个读到回车符随之而退出。
>
> 解决方法很简单:
> 可以在getline之前使用cin.ignore()函数来将cin的残留回车符清除

------------------------------------------------
```c
#include <iostream>
using namespace std;

int main()
{
	char a;
	char b;
	a=cin.get();
	cin.get(b);
	cout << a << b <<endl;
	return 0;
}

```

输入：e[回车]，输出：

![image-20200426224435867](https://i.loli.net/2020/04/26/aryd8VMJWbE15t7.png)

（1）从结果可以看出，cin.get(array,20);读取一行时，遇到换行符时结束读取，但是不对换行符进行处理，换行符仍然残留在输入缓冲区。第二次由cin.get()将换行符读入变量b，打印输入换行符的ASCII码值为10。这也是cin.get()读取一行与使用getline读取一行的区别所在。getline读取一行字符时，默认遇到’\n’时终止，并且将’\n’直接从输入缓冲区中删除掉，不会影响下面的输入处理。

------------------------------------------------
版权声明：本文为CSDN博主「Dablelv」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/K346K346/article/details/48213811

```
在你写getline()函数之前，一定有使用过了回车了吧
不论你输入的是字符，数字或是回车，空格符，getline()函数都接收
而cin>>这种输入方式却是忽略回车的，如果你在getline()之前cin的一个数，回车被cin忽略了，却被getline函数接收了，感觉就是这条语句被跳过了 
所以解决的办法是在getline函数之前再使用getline一次，将输入流里的回车符接收掉，后面就能正常输入了
```

```c
#include <iostream>
using namespace std;
int main(){
    int num,sum,a,times;
    cin >> num;
    while(num--)
    {
        cin >> times;
        sum = 0;
        while(times--)
        {
            cin >> a;
            sum+=a;
        }
        cout << sum << endl;
    }
}
```

题目描述

计算一系列数的和

输入描述:

```
输入数据有多组, 每行表示一组输入数据。

每行不定有n个整数，空格隔开。(1 <= n <= 100)。
```

输出描述:

```
每组数据输出求和的结果
```

```c
#include <iostream>
using namespace std;
int main(){
    int num,sum,a,times;   
    
    while(cin >> a)
    {
        sum = 0;
        while(true)
        {
            sum+=a;
            if(cin.get()=='\n')
                break;
            cin >> a;
        }
        cout << sum << endl;
    }
}
```

```c
#include <iostream>
using namespace std;
int main()
{
	char a[20];
	cin >> a;
	cout << a << endl;
	return 0;
}
输入：
    asasdascaasd
输出：
    asasdascaasd
输入：
    asasdasd kkkkkkk
输出：
    asasdasd
```

# 此项目需要缓解了 Spectre 漏洞的库。

# VS2019无法打开VS Instalcdler的解决办法

vs_installer.exe右键->属性->兼容性->勾选禁用视觉主题，勾选禁用桌面元素

![image-20200427113950251](https://i.loli.net/2020/04/27/RJeslzhK8IZTtCD.png)





 

## 对输入的字符串进行排序后输出

输入描述:

```
输入有两行，第一行n

第二行是n个空格隔开的字符串
5
c d a bb e
```

输出描述:

```
输出一行排序后的字符串，空格隔开，无结尾空格
a bb c d e
```



```c
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int main()
{
    int num = 0;
    vector<string> str;
    cin >> num;
    int nn = num;
    while(num--)
    {
        string temp;
        cin >> temp;
        str.push_back(temp);
    }
    sort(str.begin(),str.end());
   for(int i = 0;i < nn; i++)
    {
       if(i<nn-1) 
           cout<<str[i]<<" ";
       else cout<<str[i];       
    }
    
}
```

链接：https://ac.nowcoder.com/acm/contest/320/I
来源：牛客网



## 题目描述

对输入的字符串进行排序后输出

## 输入描述:

```
多个测试用例，每个测试用例一行。

每行通过空格隔开，有n个字符，n＜100
a c bb
f dddd
nowcoder
```

## 输出描述:

```
对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开
a bb c
dddd f
nowcoder
```

```c
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int main()
{
    int num = 0;
    vector<string> str;
    
    int nn = num;
    string temp;
    while(cin >> temp)
    {
        str.push_back(temp);
        if(cin.get() == '\n')
        {
            sort(str.begin(),str.end());
            for(int i=0;i<str.size()-1;i++)
                cout<<str[i]<<" ";
            cout<<str[str.size()-1]<<endl;   //保持输出格式，这里要注意
            str.clear();            
        }
            
    }
    
}
```

## find函数

```c
find(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0)
```

        for (int j=0;j<TIMES;j++)
        {
            getline(cin, OPERATOR_STYLE);
            int IDX;
            if (OPERATOR_STYLE.find("PUSH") != OPERATOR_STYLE.npos)
            {
                IDX = OPERATOR_STYLE.find(" ");
                int x = stoi(OPERATOR_STYLE.substr(IDX + 1));
                q1.push(x);
    
            }
## substring函数

```c
string substr (size_t pos = 0, size_t len = npos) const;
```
左闭右开区间[0,2)

1sapce1

out: 1space

## SplitString

```
void SplitString(const string &s, vector<string> &v, const string &c)
{
 
    string::size_type pos1, pos2;
    pos2 = s.find(c);
    pos1 = 0;
    while (string::npos != pos2)
    {
        v.push_back(s.substr(pos1, pos2 - pos1));
        pos1 = pos2 + c.size();
        pos2 = s.find(c, pos1);
    }
    if (pos1 != s.length())
        v.push_back(s.substr(pos1));
}
```
 

## 对输入的字符串进行排序后输出

输入描述:
多个测试用例，每个测试用例一行。
每行通过,隔开，有n个字符，n＜100

```
a,c,bb
f,dddd
nowcoder
```

输出描述:
对于每组用例输出一行排序后的字符串，用','隔开，无结尾空格

```
a,bb,c
dddd,f
nowcoder
```

```c
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int main()
{
    int num = 0;
    vector<string> str;
    string temp;
    while(getline(cin,temp))
    {
        int index1 = 0;
        int index2 = temp.find(',');        
        while(index2 != string::npos)
        {
            str.push_back(temp.substr(index1,index2-index1));
            index1 = index2 + 1;
            index2 = temp.find(',',index1);
        }
        if (index1 != temp.length())
            str.push_back(temp.substr(index1));        
        sort(str.begin(),str.end());
        for(int i=0;i<str.size()-1;i++)
            cout<<str[i]<<",";
        cout<<str[str.size()-1]<<endl;   //保持输出格式，这里要注意
        str.clear(); 
    }
    
}
```

