---
title:  "印象笔记"
date:   2019-12-18 10:16:18 +0800
categories:
- C++
tags:
- C++ 
---

这篇文章主要记述了之前记录于印象笔记里的一些内容。

<!--more-->



## GitHub

1.先生成秘钥

ssh-keygen -t rsa -C "[xxxxx@xxxxx.com](mailto:xxxxx@xxxxx.com)"  

\# Generating public/private rsa key pair...

\# 三次回车即可生成 ssh key



1. $ git clone "SSH地址"
2. \#git pull origin master
3. \#git add .
4. \#git commit -m 'init'
5. \#git push origin master
6. git checkout -b ‘name’

https://www.cnblogs.com/riverdubu/p/6491944.html



## **传递参数的方法：**

1.Params

由于动态路由也是传递params的，所以在 this.$router.push() 方法中path不能和params一起使用，否则params将无效。需要用name来指定页面。

及通过路由配置的name属性访问

**在路由配置文件中定义参数：**

![image-20191218170051967](https://i.loli.net/2020/03/30/lYf4VonRmkptNLS.png)

**通过name获取页面，传递params：**

![image-20191218170126558](https://i.loli.net/2020/03/30/Vb6jedOBaAEZDfF.png)

**在目标页面通过this.$route.params获取参数：**

![image-20191218170146300](https://i.loli.net/2020/03/30/9O2HjZEFt15lRJa.png)

**2.Query**

**页面通过path和query传递参数，该实例中row为某行表格数据**

![image-20191218170211945](https://i.loli.net/2020/03/30/F6tmPowgrpLNlkC.png)

**在目标页面通过this.$route.query获取参数：**

**this**.**$route**.query.row.xxx

## 前端设计

![1576645387066](https://i.loli.net/2020/03/30/oHqOlGZWaPI7wV9.png)

padding就是与上一个父级元素的距离

![1576645411047](https://i.loli.net/2020/03/30/xsRetKAzTHUhvPn.png)

![1576645429672](https://i.loli.net/2020/03/30/pzYWPd9mtyocbv1.png)

![1576645651793](https://i.loli.net/2020/03/30/9Tu28hnrdx1QwBO.png)

![1576645676226](https://i.loli.net/2020/03/30/vMXHlc7rGIySqoT.png)

![1576645705677](https://i.loli.net/2020/03/30/Oemg4sIZLdTvlRP.png)

![1576645725576](https://i.loli.net/2020/03/30/EwcmQ8r2un9Zbtg.png)

## MySQL

1.连接

进入bin，win+R cmd 输入net start mysql

2 输入 

mysql -h 127.0.0.1 -u root -p

password:root



查看所有的数据库,输入“show databases；”，注意一定要加上分号，因为mysql中是以分号来标志结束的。

```sql
create test;

create table users(userId int primary key auto_increment,username varchar(20),passwd varchar(20),email varchar(30),grade int);

insert into users values(1,'admin','admin','admina@163.com',1);

insert into users values(2,'acewzj','123','acewzj@dlmu.edu.cn',2);
```



J2EE连接MySQL

![1576645570723](https://i.loli.net/2020/03/30/QfXIMVjSAecqsnw.png)

![1576645588344](https://i.loli.net/2020/03/30/4Hd1ReOoLbNYmrB.png)

![1576645597943](https://i.loli.net/2020/03/30/hUPfin6mLK5ODXj.png)

```sql
//URL指向要访问的数据库名mydata

​         String url = "jdbc:mysql://localhost:3306/test";

​        //MySQL配置时的用户名

​         String user = "root";

​       //MySQL配置时的密码

​         String password = "root";

​      

​       //1.加载驱动程序

​       Class.forName("com.mysql.jdbc.Driver");

​       

​         //2.getConnection()方法，连接MySQL数据库！！

​         Connection ct =  DriverManager.getConnection(url,user,password);

​         //3.创建statement

​         Statement sm = ct.createStatement();

​         //4.查询

​         ResultSet rs = sm.executeQuery("select passwd from users  where username='" + u + "'");



create table users(

userid bigint primary key auto_increment,

username varchar(30) not null unique,

truename varchar(30) not null,

passwd varchar(30) not null,

email varchar(40)not null,

phone varchar(20)not null,

address varchar(30)not null,

postcode char(6),

grade int default 1

)AUTO_INCREMENT = 1;

create table students(

stuPointer bigint primary key auto_increment,

stuDepartment varchar(20),

stuMajor varchar(20),

stuGrade varchar(5),

className varchar(20),

stuNum varchar(10),

stuName varchar(10),

stuNamePinyin varchar(20),

stuId varchar(18),

stuGender varchar(2),

stuNation varchar(6),

stuBirth varchar(8),

stuPolitic varchar(5)

)AUTO_INCREMENT = 1;


```



如何将excel中的数据导入到mysql数据库中？

1，在mysql中新建一个和Excel表头一样的表。注意如果是中文的话，一个varchar存储一个中文字符，但是如果编码方式选择了utf-8，则一个varchar占据3个字节数据，如果是gb2312则占据两个字节数据

2，将Excel表只剩下数据另存为CSV（逗号分隔），然后使用记事本打开并且另存为utf-8格式

3，通过import wizard 导入CSV文件中的数据



## 面向对象

从理论上来说，这三个概念很容易背的滚瓜烂熟，但是从大学毕业到现在，我都没真正搞明白这三个东西的出现，究竟是为了做到什么事情。

也许之前我很少写代码，更很少写面向对象的代码，即使有写多半也很容易写回到面向过程的老路上去。在写面向过程的代码的时候，根本不管什么函数重载和覆盖，想到要什么功能就变得法子的换个函数名字，心里想想：反正函数重载本质也就是入栈了两个不同的函数。

知道后来我才慢慢了解，这些概念的出现，完全就不是为了编程的功能实现，而是编程的易用和扩展，准确的来说是方便再次开发而提出的一种标准而已。如果仅仅只要写个自己用的功能性的程序，那的确可以用不到上面这些麻烦的东西。

回过头来讲，让我了解标题这三个概念的实际用处，还是在于我这第四次重写毕业论文的代码，将它改写成面向对象的时候，才理解的。在面向对象设计的过程中，类是从抽象逐渐具体起来的，父类可以是非常非常抽象的东西，而最终实例化的子类就非常具体了。在这个继承的过程中，不断的对父类进行填充丰富，最终得到的子类就是有血有肉的 - 我的理解。

虚函数的意义，就在于定义了一个从最早的父类，到最后的子类，都必须具备的一个功能（函数），只是在不断的进化（继承）中，这个功能会略微发生改变。通过虚函数，我们在调用不同的衍生类的时候，可以拥有不同的功能。然后我会说：这么麻烦，干脆每个继承类都重写命名一个函数么算了，只要知道重命名的函数有这个功能就行了不是？理论上来说，完全可以，在一个父类和其继承类不多的项目中，这么做完全可以，只要你自己能熟记或者找到这个重命名函数是干嘛用的；但是在大一点的项目中，由于类中的函数成百上千，恐怕你就会为此疯狂。另外还有一点，是重命名函数无法做到的，这一点我会在纯虚函数中一并解释。

纯虚函数，就是虚函数了以后，末尾还要加=0的那一类函数。我一直没想通的是，既然这个函数完全没有实现方法，那么定义这个函数有个蛋用啊？我也曾经试着在网上搜索过纯虚函数的意义和作用，回答大多千篇一律照本宣科。于是我渐渐的也就无视这个纯虚函数了。直到现在我开始写一个PSO算法的时候，才发现天哪这居然是一个完全不可或缺的东西！如果说虚函数还可以用重命名作为另外一种解决方法，那么纯虚函数则是没有第二种可以替代的方法。我可以拿一个非常简单的代码说明一下：

class test{ public: virtual void print(); virtual void order()=0; int array[20]; };

上面声明了一个非常简单的类，它只有两个函数，其中一个是虚函数：打印，另外一个是纯虚函数：排序。其中打印函数的定义如下

void test::print(){ order(); printf('打印结果： '); for(int i=0; i<20; i++) printf('%d ', array); }

在这个打印函数中，调用了order函数对array进行了排序，然后输出结果。问题是：我根本不知道order函数是什么算法，或者说order函数因人而异，所以无法确定！于是网上照本宣科的内容就出来：当函数没有实现方法或者需要子类来定义实现方法的时候，可以在父类中定义纯虚函数。就是这么简单！于是当不同的子类继承这个父类的时候，定义不同的实现方法，那么实例化这个子类的时候，这个纯虚函数就有了不同的方法。这也解释了为什么包含纯虚函数的抽象类为什么不能实例化，因为它中间有函数根本不知道是怎么个实现！当然我们可以用其他方法避免使用纯虚函数，比方说在子类中重写print方法，但是这样一来等于除了order函数代码以外所有的代码都要重新复制一遍，当继承类越来越多的时候，要修改print等于这一堆继承类都要修改，会疯的！所以说纯虚函数是一个很神奇的用法，也是简化了编程使得面向对象的方法更加灵活。

至于接口，这是一个只有JAVA中才用到的概念，C++中不存在接口，与接口相似的是：抽象类。因为JAVA不允许多重继承类，但可以继承多个接口。关于接口，在我编写JAVA SERVLET的时候，碰到过一个httpservlet，用户需要为doget和dopost等函数编写实现方法。而这些函数就可以看成是纯虚函数，它在HTTPservlet也类似于上述代码的order函数，有着在局部函数中的作用。

面向对象编程确实很有意思，虽然从某种程度上来说，和面向过程也差不多，但是灵活多变的设计方法，也许也是C++（面向对象）比C（面向过程）强大的地方

##   JSON

[JSON](https://baike.baidu.com/item/JSON)([JavaScript](https://baike.baidu.com/item/JavaScript) Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。 存储时，通过**JSON.stringify()**将对象转换为文本格式；读取时，通过**JSON.parse()**将文本转换回对象。

简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在函数之间轻松地传递这个字符串，或者在异步应用程序中将字符串从 Web 客户机传递给服务器端程序。这个字符串看起来有点儿古怪，但是JavaScript很容易解释它，而且 JSON 可以表示比"名称 / 值对"更复杂的结构。



对象：对象在 JS 中是使用花括号包裹 {} 起来的内容，数据结构为 {key1：value1, key2：value2, ...} 的键值对结构。在面向对象的语言中，key 为对象的属性，value 为对应的值。键名可以使用整数和字符串来表示。值的类型可以是任意类型。



```json
var text = '{"employees":[' +

​    '{"name":"菜鸟教程","site":"[http://www.runoob.com](http://www.runoob.com/)" },' +

​    '{"name":"Google","site":"[http://www.Google.com](http://www.google.com/)" },' +

​    '{"name":"Taobao","site":"[http://www.taobao.com](http://www.taobao.com/)" }]}';

obj = JSON.parse(text);

document.getElementById("demo").innerHTML =

​    obj.employees[0].name + " " + obj.employees[1].site;
```



## 站群系统

站群系统就是一网站的集合，但是一定要统一，分级管理，信息共享，[单点登录](https://baike.baidu.com/item/单点登录/4940767)才可以。最初的[站群](https://baike.baidu.com/item/站群)由政府提出，现在已经应用领域范围很广，例如政府门户网站群、大型企事业网站群、行业网站群等。

[站群](https://baike.baidu.com/item/站群)通常由几个到几百个网站组成，站群最简单的理解就是一群网站。而这些网站都是属于一个人的。那么这些网站就称之为此站长的站群。

站群，即一个人或一个团队操作多个网站，目的是通过搜索引擎获得大量流量，或者是将链接指向同一个网站，以提高搜索排名。

J2EE是一套全然不同于传统应用开发的技术架构，包含许多组件，主要可简化且规范应用系统的开发与部署，进而提高可移植性、安全与再用价值。

J2EE（Java 2 Platform, Enterprise Edition）是一个为大企业主机级的计算类型而设计的Java平台。Sun微系统（与其工业伙伴一起，例如IBM）设计了J2EE，以此来简化在受客户级环境下的应用开发。由于创造了标准的可重用模块组件以及由于构建出能自动处理编程中多方面问题的等级结构，J2EE简化了应用程序的开发，也降低了对编程和对受训的程序员的要求。

[Sun公司](https://baike.baidu.com/item/Sun公司)在1998年发表JDK1.2版本的时候， 使用了新名称Java 2 Platform，即“Java2平台”，修改后的JDK称为Java 2 Platform Software Develping Kit，即[J2SDK](https://baike.baidu.com/item/J2SDK)。并分为标准版(Standard Edition，[J2SE](https://baike.baidu.com/item/J2SE)), 企业版(Enterprise Edition，J2EE)，微型版(MicroEdition，[J2ME](https://baike.baidu.com/item/J2ME))。J2EE便由此诞生。

java包含三大分支:

[手机游戏](https://www.baidu.com/s?wd=手机游戏&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLryDLuj0vm19buyDkPh7b0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH63PWT3n1bs)

3.[J2EE](https://www.baidu.com/s?wd=J2EE&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLryDLuj0vm19buyDkPh7b0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH63PWT3n1bs) --java Enterprise Editon --一般为[服务器端](https://www.baidu.com/s?wd=服务器端&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLryDLuj0vm19buyDkPh7b0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH63PWT3n1bs)程序的应用:例如JSP站点!

Web服务器一般指网站服务器，是指驻留于[因特网](https://baike.baidu.com/item/因特网)上某种类型计算机的程序，可以向浏览器等Web客户端提供文档，[1]  也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个Web服务器是Apache Nginx IIS

Web服务器可以解析（handles)HTTP协议。当Web服务器接收到一个HTTP请求（request），会返回一个HTTP响应（response），例如送回一个HTML页面。为了处理一个请求（request），Web服务器可以响应（response）一个[静态页面](https://baike.baidu.com/item/静态页面)或图片，进行页面跳转(redirect），或者把动态响应（dynamic response）的产生委托（delegate）给一些其它的程序例如CGI脚本，JSP(JavaServer Pages）脚本，servlets，ASP(Active Server Pages）脚本，服务器端（server-side)JavaScript，或者一些其它的服务器端（server-side）技术。无论它们（译者注：脚本）的目的如何，这些服务器端（server-side）的程序通常产生一个HTML的响应（response）来让浏览器可以浏览。

要知道，Web服务器的代理模型（delegation model）非常简单。当一个请求（request）被送到Web服务器里来时，它只单纯的把请求（request）传递给可以很好的处理请求（request）的程序（译者注：服务器端脚本）。Web服务器仅仅提供一个可以执行服务器端（server-side）程序和返回（程序所产生的）响应（response）的环境，而不会超出职能范围。服务器端（server-side）程序通常具有事务处理（transaction processing），数据库连接（database connectivity）和消息（messaging）等功能。

虽然Web服务器不支持事务处理或[数据库连接池](https://baike.baidu.com/item/数据库连接池)，但它可以配置（employ）各种策略（strategies）来实现[容错性](https://baike.baidu.com/item/容错性)（fault tolerance）和可扩展性（scalability），例如[负载平衡](https://baike.baidu.com/item/负载平衡)（load balancing），缓冲（caching）。集群特征（clustering—features）经常被误认为仅仅是应用程序服务器专有的特征。

![1576646067050](https://i.loli.net/2020/03/30/EadoOnWz3FHrhSX.png)



## Socket编程

![1576646789677](https://i.loli.net/2020/03/30/GikRcHbNUXpQ47t.png)

两个进程进行通信最基本的一个前提是能够唯一的标示一个进程，在本地通信中可以用PID（Process ID）来唯一标示一个进程；但是网络中的两个进程PID冲突几率很大，我们知道IP层的IP地址可以唯一标示一台主机，而TCP层的协议和端口号可唯一的标示主机的一个进程，这样可以用IP地址+协议+端口号来唯一的标示网络中的一个进程。

- UDP：不靠谱的通信协议，不去理会数据是否传送到目的地，只管把数据打成包发送出去；

- TCP：每次传输完成，等待一个应答，确保数据发送成功。

- 0-1024,端口是给操作系统用的，剩下的256*（256-1）给自己用

```java
public void onCreate(Bundle savedInstanceState) {

​        super.onCreate(savedInstanceState);

​        setContentView(R.layout.main);

​        startButton = (Button)findViewById(R.id.startListener);

​        startButton.setOnClickListener(new StartSocketListener());

​    }



​    class StartSocketListener implements OnClickListener{



​           @Override

​           public void onClick(View v) {

​                new ServerThread().start();

​           }
```



​    在实际应用中，当一个Activity结束前，如果需要保存状态，就在onsaveInsanceState中，将状态数据以key-value的形式放入到saveInsanceState中。这样，当一个Activity被创建时，就能从onCreate的参数saveInsanceState中获得状态数据。

​    状态这个参数在实现应用中有很大的用途，比如：一个游戏在退出前，保存一下当前游戏运行的状态，当下次开启时能接着上次的继续玩下去。再比如：电子书程序，当一本小说被阅读到第199页后退出了（不管是内存不足还是用户自动关闭程序），当下次打开时，读者可能已忘记了上次已阅读到第几页了，但是，读者想接着上次的读下去。如果采用saveInstallState参数，就很容易解决上述问题。

```java
服务器端代码如下：

public void run(){

​           //声明一个ServerSocket对象

​           ServerSocket serverSocket = null;

​           try {

​                //创建一个ServerSocket对象，并让这个Socket在4567端口监听

​                     serverSocket = new ServerSocket(4567);

​                     //调用ServerSocket的accept()方法，接受客户端所发送的请求

​                     Socket socket = serverSocket.accept();

​                     //从Socket当中得到InputStream对象

​                     InputStream inputStream = socket.getInputStream();

​                     byte buffer [] = new byte[1024*4];

​                     int temp = 0;

​                     //从InputStream当中读取客户端所发送的数据

​                     while((temp = inputStream.read(buffer)) != -1){

​                           System.out.println(new String(buffer,0,temp));

​                     }

​                } catch (IOException e) {

​                     // TODO Auto-generated catch block

​                     e.printStackTrace();

​                }

​                finally{

​                     try {

​                           serverSocket.close();

​                     } catch (IOException e) {

​                           // TODO Auto-generated catch block

​                           e.printStackTrace();

​                     }

​                }



​     }

客户端代码如下：

try {

​                //创建一个Socket对象，指定服务器端的IP地址和端口号

​                Socket socket = new Socket("192.168.1.104",4567);

​                //使用InputStream读取硬盘上的文件

​                InputStream inputStream = new FileInputStream("f://file/words.txt");

​                //从Socket当中得到OutputStream

​                OutputStream outputStream = socket.getOutputStream();

​                byte buffer [] = new byte[4*1024];

​                int temp = 0 ;

​                //将InputStream当中的数据取出，并写入到OutputStream当中

​                while((temp = inputStream.read(buffer)) != -1){

​                     outputStream.write(buffer, 0, temp);

​                }

​                outputStream.flush();

​           } catch (Exception e) {

​                // TODO Auto-generated catch block

​                e.printStackTrace();

​           }
```

e为FileNotFoundException的对象
 当试图打开指定路径名表示的文件失败时，抛出此异常。
 ------解决方法--------------------
 e 变量名，如果你不喜欢用 f，也是没关系的，主要可以用来获得一些异常的信息。
 ------解决方法--------------------
 简单地说，FileNotFoundException e，就相当于int e，或是Integer e；

声明一个变量而已。

printStackTrace()方法的意思是：在命令行打印异常信息在程序中出错的位置及原因。（这是白话解释，比较容易理解）

## premiere输出高清视频

在弹出的序列中选择HDV 720 25P的格式，这是一种常用格式。制作出来的视频尺寸是1280x720.

等制作完成后，选择【文件】--【导出】-【多媒体】。在弹出的导出设置中格式选择【H.264】，预设【HDTV 720P  25高品质】设置好后【导出】就可以了。

**常见的直线有三种扫描算法：DDA算法，中点画线法，Bresenham算法。下面来看看Bresenham算法。**

## **Bresenham算法**

过各行各列象素中心构造一组虚拟网格线。按直线从起点到终点的顺序计算直线与各垂直网格线的交点，然后根据误差项的符号确定该列象素中与此交点最近的象素。

![1576647567737](https://i.loli.net/2020/03/30/CLwiaVfpqB2vUOy.png)

[](http://photo.blog.sina.com.cn/showpic.html#blogid=73428e9a01016gnp&url=http://s1.sinaimg.cn/orignal/73428e9a4ca1c662241c0)

**核心思想：**
假设：k=dy/dx。因为直线的起始点在象素中心，所以误差项d的初值d0＝0。
 X下标每增加1，d的值相应递增直线的斜率值k，即d＝d＋k。一旦d≥1，就把它减去1，这样保证d在0、1之间。
 当d≥0.5时，最接近于当前象素的右上方象素（x+1,y+1）
 而当d<0.5时，更接近于右方象素(x+1,y）

为方便计算，令`e＝d-0.5`，
 e的初值为-0.5，增量为k。
 当e≥0时，取当前象素（xi，yi）的右上方象素（x+1,y+1）
 而当e<0时，更接近于右方象素(x+1,y）


可以改用整数以避免除法。由于算法中只用到误差项的符号，因此可作如下替换：
`e1 = 2*e*dx`

**算法代码：**

```c
void Bresenhamline (int x0,int y0,int x1, int y1,int color)
 { 
  int x, y, dx, dy;
  float k, e;
  dx = x1-x0, dy = y1- y0, k=dy/dx;
  e=-0.5, x=x0, y=y0;
  for (i=0; i<=dx; i++)
  {    drawpixel (x, y, color);
  x=x+1，e=e+k;
  if (e>=0)
  { y++, e=e-1;}
  }
 }
 //或者将e扩大2dx倍；



void Bresenhamline (int x0,int y0,int x1, int y1,int color)
 {
 int x, y, dx, dy;
 float k, e;
 dx = x1-x0, dy = y1- y0, k=dy/dx;
 e=-dx, x=x0, y=y0;
 for (i=0; i<=dx; i++)
 { drawpixel (x, y, color);
 x=x+1，e=e+2dy;
 if (e>=0)
 { y++, e=e-2dx;}
 }
```

![1576647586467](https://i.loli.net/2020/03/30/85ejMKYNJOnEBiF.png)

