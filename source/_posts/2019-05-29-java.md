---
title:  "java基础"
date:   2019-05-29 10:06:18 +0800
categories:
- Java_Base
tags:
- Java Base
---

本文记述了关于Java的一些基础知识点。

<!--more-->



## Base Tips

> 一个源文件只能有一个public类
>
> char类型是一个单一的16位Unicode字符，可以储存任意字符，和之前想的不太一样，因为byte可以是二进制补码表示的整数



## 为什么数据要用二进制补码表示？

正数的二进制补码还是正数本身，但是负数的二进制补码是各位取反然后最低位再加一。采用补码表示主要是为了简化加法运算，让一个正数加上一个负数时得出的结果就是正确的形式。摘自阮一峰：将正数转化为负数，就让0减去这个数就行了，`0-8=-8`

```java
    0000 0000
   -0000 1000
   ----------
   **好像不够减，向前一位借一**
   10000 0000
  - 0000 1000
  -----------
    1111 1000
```
拓展：大端与小端，一个Int占4个字节，如果0x12345678中的"78"在高地址处，那就是大端，反之就是小端。

## String 

String 存储的是字符串常量(const 不可修改) 每次对String类型进行改变的时候等于生成了一个新的String对象，然后将指针指向新的String对象。如果经常改变字符串内容，最好不要用 String ，因为每次生成对象都会对系统性能产生影响，而且当内存中无引用的对象多了以后， JVM 的 垃圾回收器GC 就会开始工作，程序运行速度就会变慢。
如果是定义一个StringBuffer 类型的对象，每次对字符串内容进行操作都会对 StringBuffer对象本身进行操作，而不是生成新的对象。所以一般情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全。StringBuilder类提供一个与 StringBuffer 兼容的 API，该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。

## 到底什么是`classpath`？

`classpath`是JVM用到的一个环境变量，它用来指示JVM如何搜索`class`。

因为Java是编译型语言，源码文件是`.java`，而编译后的`.class`文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个`abc.xyz.Hello`的类，应该去哪搜索对应的`Hello.class`文件。

所以，`classpath`就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用`;`分隔，带空格的目录用`""`括起来，可能长这样：

```
C:\work\project1\bin;C:\shared;"D:\My Documents\project1\bin"
```

在Linux系统上，用`:`分隔，可能长这样：

```
/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin
```

现在我们假设`classpath`是`.;C:\work\project1\bin;C:\shared`，当JVM在加载`abc.xyz.Hello`这个类时，会依次查找：

- <当前目录>\abc\xyz\Hello.class
- C:\work\project1\bin\abc\xyz\Hello.class
- C:\shared\abc\xyz\Hello.class

注意到`.`代表当前目录。如果JVM在某个路径下找到了对应的`class`文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。

`classpath`的设定方法有两种：

在系统环境变量中设置`classpath`环境变量，不推荐；

在启动JVM时设置`classpath`变量，推荐。

我们强烈*不推荐*在系统环境变量中设置`classpath`，那样会污染整个系统环境。在启动JVM时设置`classpath`才是推荐的做法。实际上就是给`java`命令传入`-classpath`或`-cp`参数：

```
java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello
```

或者使用`-cp`的简写：

```
java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello
```

没有设置系统环境变量，也没有传入`-cp`参数，那么JVM默认的`classpath`为`.`，即当前目录：

```
java abc.xyz.Hello
```

上述命令告诉JVM只在当前目录搜索`Hello.class`。

在IDE中运行Java程序，IDE自动传入的`-cp`参数是当前工程的`bin`目录和引入的jar包。

通常，我们在自己编写的`class`中，会引用Java核心库的`class`，例如，`String`、`ArrayList`等。这些`class`应该上哪去找？

有很多“如何设置classpath”的文章会告诉你把JVM自带的`rt.jar`放入`classpath`，但事实上，根本不需要告诉JVM如何去Java核心库查找`class`，JVM怎么可能笨到连自己的核心库在哪都不知道？

 不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！

更好的做法是，不要设置`classpath`！默认的当前目录`.`对于绝大多数情况都够用了。

### jar包

如果有很多`.class`文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。

jar包就是用来干这个事的，它可以把`package`组织的目录层级，以及各个目录下的所有文件（包括`.class`文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。

jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的`class`，就可以把jar包放到`classpath`中：

```
java -cp ./hello.jar abc.xyz.Hello
```

这样JVM会自动在`hello.jar`文件里去搜索某个类。

那么问题来了：如何创建jar包？

因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从`.zip`改为`.jar`，一个jar包就创建成功。

假设编译输出的目录结构是这样：

```ascii
package_sample
└─ bin
   ├─ hong
   │  └─ Person.class
   │  ming
   │  └─ Person.class
   └─ mr
      └─ jun
         └─ Arrays.class
```

这里需要特别注意的是，jar包里的第一层目录，不能是`bin`，而应该是`hong`、`ming`、`mr`。如果在Windows的资源管理器中看，应该长这样：

![hello.zip.ok](https://www.liaoxuefeng.com/files/attachments/1261393208671488/l)

如果长这样：

![hello.zip.invalid](https://www.liaoxuefeng.com/files/attachments/1261391527906784/l)

说明打包打得有问题，JVM仍然无法从jar包中查找正确的`class`，原因是`hong.Person`必须按`hong/Person.class`存放，而不是`bin/hong/Person.class`。

jar包还可以包含一个特殊的`/META-INF/MANIFEST.MF`文件，`MANIFEST.MF`是纯文本，可以指定`Main-Class`和其它信息。JVM会自动读取这个`MANIFEST.MF`文件，如果存在`Main-Class`，我们就不必在命令行指定启动的类名，而是用更方便的命令：

```
java -jar hello.jar
```

jar包还可以包含其它jar包，这个时候，就需要在`MANIFEST.MF`文件里配置`classpath`了。

在大型项目中，不可能手动编写`MANIFEST.MF`文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如[Maven](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200)，可以非常方便地创建jar包。

### 小结

JVM通过环境变量`classpath`决定搜索`class`的路径和顺序；

不推荐设置系统环境变量`classpath`，始终建议通过`-cp`命令传入；

jar包相当于目录，可以包含很多`.class`文件，方便下载和使用；

`MANIFEST.MF`文件可以提供jar包的信息，如`Main-Class`，这样可以直接运行jar包。

## 关于JAVA中Static的用法

1，对于成员变量

用了Static以后，主函数就可以不用先生成一个对象然后再对象.变量名字 这样调用这个成员变量（面向对象语言要求调用成员变量必须用 对象.成员变量名字 这种形式来调用）；你对象怎么来的？还不是person p1=new person();这种靠类来初始化一个对象，实际上是一个引用，指向一个内存堆。

2.对于成员函数

用了Static以后，任何东西实际上已经被分配了一个固定到死的空间，不像动态变量那样具有生命周期，静态的东西一直都在那里，在C语言中：用Static可以保存上一次程序退出后的值，下一次程序再进入，动态变量重新归0，静态变量继续存活，执行累加或者等等......

3，以上，对于静态成员变量与静态函数，都可以不用初始化一个对象，靠对象来执行相应工程，直接来 类.对象名字（成员变量，函数）就可以了。

## 关于JAVA中This的用法

1.对于成员变量

用`This`可以代替类.成员变量，直接可以变为This.成员变量

```java
用This可以这样  函数（string name,int age）{

this.name=name;

this.age=age;//.后面代表成员变量

}

2.对于成员函数（主要对构造函数）

person(){

System.out.println("无参数的构造函数");

}

person(String name,int age){

this();//调用1函数

System.out.println("有两个参数的构造函数");

}

person(String name,int age，string adress){

this(zhangsan,20);//根据参数个数及形式调用相应的构造函数



System.out.println("有三个参数的构造函数");

}

程序运行结果：

无参数的构造函数

有两个函数的构造函数

有三个函数的构造函数
```

必须把This放在第一行，但是super不必这样！

## Java：Override

复写：

子类继承父类后，父类的某个函数与子类的某个函数，参数列表完全相同，类型也一样。就说子类复写了父类的这个方法。



可以在子类方法中用super.方法，调用父类的同名函数。

## JAVA：上下转型

1.上转型

![1576646436445](https://i.loli.net/2020/03/30/SObB2LfqMvgTREk.png)

语法：1，一个引用能够调用哪些成员（变量和函数），取决与这个引用的类型{虽然指向同一个内存堆，但是p里面如果没有定义某个变量，那它不能使用}

2.一个引用调用的是哪一个方法，取决于这个引用所指向的对象{使用introduce方法时，虽然两个类中都有，但是它调用子类的那个方法}

2.下转型

![1576646454271](https://i.loli.net/2020/03/30/S6Rji5aETfnCqWV.png)

错误的向下转型：学生是人，但是有的人不是学生

![1576646482475](https://i.loli.net/2020/03/30/OAhd9M6vPsYazl4.png)

## JAVA：子类实例化



1，子类继承父类时，不能继承父类的构造方法，但是父类有一些成员变量，我想在子类中对它进行赋值；但是它在父类中已经被构造函数赋值了。作为一个程序员，最不能忍受的就是父类和子类有相同的代码块：像吐了唾沫！怎么办？

子类会使 用super（）；调用父类不带参数的构造函数；

或者Super（x1,x2）；调用相应的构造函数//类似This

这样就省得你对父类成员变量赋值时。冗余拖沓！



2.就算你不屑写super，编译器也会自动给你生成的，那么此时牛就会调用父类不带参数的构造方法

## Abstract

1.Abstract天生就是给人当爹的！

![1576646640881](https://i.loli.net/2020/03/30/jN3nGxgd6myfKWA.png)

2.继承抽象类的子函数必须复写父类中的抽象方法！

3.抽象类不能生成相应的对象！

4.既然抽象函数不能生成对象，它还是会有构造函数的，因为还会有Super

5.生成子类的对象必须要有父类的生成！

## 静态区

静态区：保存自动全局变量和 static变量（包括 static全局和局部变量） 。静态区的内容

在总个程序的生命周期内都存在，由编译器在编译的时候分配。

栈：保存局部变量。栈上的内容只在函数的范围内存在，当函数运行结束，这些内容

也会自动被销毁。其特点是效率高，但空间大小有限。

堆：由 malloc系列函数或 new操作符分配的内存。其生命周期由 free或 delete决定。

在没有释放之前一直存在，直到程序结束。其特点是使用灵活，空间比较大，但容易出错。

按照 getchar名字的意思，应该将变量 c 定义为 char类型。但是很不幸，getchar函数的

返回值却是 int类型，其原型为：

int getchar(void)；

## JAVA：访问权限

两个类如果在不同的包里面，被访问的类（变量和方法）必须是public，你不屑写 ，就默认为friend，也还是访问不了

default:必须在同一个包里面，不同的包使用不了

## Java:内部类和匿名内部类

内部类就是定义在类里面的类；它可以使用外部类的变量；但是在生成内部类的对象时，必须先生成其外部类：eg

```java
A a=new A();

A.a b=new a.B();

A.this.i+this.j;
```

匿名内部类就是没有名字的类，一般别的类都是什么……classA implements interface……

匿名内部类直接就是`new A（）`

匿名内部类也就是没有名字的内部类

正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写

但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口

 

#### 实例1:不使用匿名内部类来实现抽象方法

```java
abstract class Person {
    public abstract void eat();
}
 
class Child extends Person {
    public void eat() {
        System.out.println("eat something");
    }
}
 
public class Demo {
    public static void main(String[] args) {
        Person p = new Child();
        p.eat();
    }
}
```

**运行结果：**`eat something`

可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用

但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？

这个时候就引入了匿名内部类

 

#### 实例2：匿名内部类的基本实现

```java
abstract class Person {
    public abstract void eat();
}
 
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println("eat something");
            }
        };
        p.eat();
    }
}
```

**运行结果：**`eat something`

可以看到，我们直接将抽象类Person中的方法在大括号中实现了

这样便可以省略一个类的书写

并且，匿名内部类还能用于接口上 

#### 实例3：在接口上使用匿名内部类

```java
interface Person {
    public void eat();
}
 
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println("eat something");
            }
        };
        p.eat();
    }
}
```

 **运行结果：**`eat something`

 由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现

最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口

 

#### 实例4：Thread类的匿名内部类实现

```java
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread() {
            public void run() {
                for (int i = 1; i <= 5; i++) {
                    System.out.print(i + " ");
                }
            }
        };
        t.start();
    }
}
```

**运行结果：**`1 2 3 4 5`

 

#### 实例5：Runnable接口的匿名内部类实现

```java
public class Demo {
    public static void main(String[] args) {
        Runnable r = new Runnable() {
            public void run() {
                for (int i = 1; i <= 5; i++) {
                    System.out.print(i + " ");
                }
            }
        };
        Thread t = new Thread(r);
        t.start();
    }
}
```

**运行结果：**`1 2 3 4 5`

## 线程

实现线程的两个方法：实现`runnable`接口 ；`runnable`只是一个接口：它里面只有一个`run(）`方法，没有`start`方法，而没有`start`方法，其实是还在原来的那个进程中的。

第二：继承`Thread`类  而`Thread`类有一个构造方法：参数是Runnale对象，也就是说可以通过`Thread`类来启动Runnable的多线程

Java标准的启动线程的方法：

1.生成一个`Runnable`对象 

`Runnable r = **new** Runnable()` 

2.把上述对象当成参数传进Thread中去

`Thread t = **new** Thread(r);` 

3.启动Start方法

`t.start(); `

调用Start（）方法之后，线程进入就绪状态，当时间片轮转动到该线程时，获得CPU的使用权

 handler.post(r);并没有调用Start方法，而是调用Run方法。

什么时候开线程？

耗时时间长，并不一定有结果，比如下载，搜索蓝牙

## Handle机制详解

假如一个隧道就是一个消息队列，那么里面的每一部汽车就是一个一个消息，这里我们先忽略掉超车等种种因素，只那么先进隧道的车将会先出

Looper:(相当于隧道) 一个线程可以产生一个Looper 对象，由它来管理此线程里的Message Queue( 车队,消息隧道) 。

Handler: 你可以构造Handler 对象来与Looper 沟通，以便push 新消息到Message Queue 里；或者接收Looper( 从Message Queue 取出) 所送来的消息。

Message Queue( 消息队列): 用来存放线程放入的消息。

线程：UI thread 通常就是main thread ，而Android 启动程序时会替它建立一个Message Queue 。

每一个线程里可含有一个Looper 对象以及一个MessageQueue [数据结构](http://lib.csdn.net/base/datastructure)

在你的Android 程序里，新诞生一个线程，或执行 (Thread) 时，并不会自动建立其Message Loop 。

Android 里并没有Global 的Message Queue 数据结构，例如，不同APK 里的对象不能透过Massage Queue来交换讯息(Message) 。 

Looper 类用来管理特定线程内对象之间的消息交换(Message Exchange) 。你的应用程序可以产生许多个线程。而一个线程可以有许多个组件，这些组件之间常常需要互相交换讯息。如果有这种需要，您可以替线程构造一个Looper 对象，来担任讯息交换的管理工作。Looper 对象会建立一个MessageQueue 数据结构来存放各对象传来的消息( 包括UI 事件或System 事件等) 。

```java
 Looper looper = Looper.myLooper();//取得当前线程里的looper
 MyHandler mHandler = new MyHandler(looper);//构造一个handler使之可与looper通信
//buton等组件可以由mHandler将消息传给looper后,再放入messageQueue中,同时mHandler也可以接受来自looper消息
```

## 使用IDEA创建第一个springboot应用

步骤01 新建项目，选择Spring initializer

![image-20200330203745540](https://i.loli.net/2020/03/30/lXZ9Q5vbAmr361J.png)

步骤02 输入项目的基本信息，包括Group(组织Id)、Artifact(模块名称)、Type(项目构建类型)、Language(开发语言)、Packaging(最终生成包的类型)、Java Version(Java版本)、Version(项目的版本号)、Name(项目名称)、Description(项目描述)、Package(项目的包)，各项基本信息输入完成后即可点击“Next”进入下一步；

![image-20200330203252179](https://i.loli.net/2020/03/30/bqVSCJLEhHp5NWK.png)

> 其中，“组织Id”一般为公司等组织域名的反写，而对于个人项目而言，建议采用“**pers(个人发起、独自完成、可分享的项目)或priv(个人发起、独自完成、非公开的私人使用的项目)+个人名**”的形式；“项目构建类型”表示是使用Maven还是Gradle构建项目；“最终生成包的类型”表示是使用Jar包还是War包作为项目的最终打包方式，此处选择Jar包，后续可以在项目的配置文件中进行修改；“项目的包”的包名则是根据“组织Id+模块名称”规则自动生成，一般情况下没有必要去进行修改

步骤03 选择web–>Spring Web 

![image-20200330203343084](https://i.loli.net/2020/03/30/XYruqbfnByJUecz.png)

> GA:General Availability,正式发布的版本，官方推荐使用此版本。在国外都是用GA来说明release版本的。
>
> SNAPSHOT: 快照版，可以稳定使用，且仍在继续改进版本。

步骤04 选择finish

![image-20200330203700464](https://i.loli.net/2020/03/30/T5AEpBxr9SJ4DOC.png)

步骤05 在启动之前先熟悉一下文件结构

![image-20200330204009831](https://i.loli.net/2020/03/30/9RuvL5kFCTrzZoQ.png)

- .idea文件夹：存放项目的一些配置信息，例如IDE的一些配置(主题、字体等)、缓存、版本控制和历史记录等信息；
- .mvn文件夹：该文件夹展开有一个wrapper文件夹，其中存放maven-wrapper.jar和maven-wrapper.properties和MavenWrapperDownloader.java三个文件。在src文件夹下方的文件中，还有mvnw、mvnw.cmd两个文件。其实mvnw就是一个maven wrapper script,可以让你在没有安装maven或者maven版本不兼容的条件下运行maven的命令，mvn.cmd是执行mvnw命令的cmd入口。它的原理是在maven-wrapper.properties文件中记录你要使用的maven版本，当我们执行mvnw clean命令时，发现当前环境中的maven版本和期望的版本不一致，那么就下载期望的版本，然后用期望的版本来执行mvn命令。在实际的开发过程中，我们应该保证开发环境安装了maven且maven版本与期望版本保持一致。所以这个文件夹与下面的mvnw、mvnw.cmd两个文件均可以删除；
- src文件夹：这个目录就比较熟悉了，就是用来存放源代码的文件夹。
    **main**是源文件夹，包括存放Java代码的“**java**”文件夹和存放静态资源的“**resources**”文件夹。在“java”文件夹中可以看到根据步骤03“输入项目的基本信息”时配置的包名而自动生成的一个包，其中含有自动生成的"StudySpringbootApplication"类，它是整个项目的入口类，通过其中的run方法启动项目；而“resources”文件夹中包含两个文件夹和一个文件，“static”文件夹默认存放静态资源也就是静态页面，“templates”文件夹默认存放视图模板也就是动态页面(需要引入官方推荐使用的Thymeleaf模板引擎组件或FreeMarker等第三方的模板引擎)。但是在目前的企业级Web应用中，前后端分离是大势所趋，视图层技术日渐式微，不过这两个文件夹Spring官方还是给予了提供;“application.properties”是一个配置文件，包含系统属性、环境变量、命令参数等信息，Spring Boot启动时默认加载该配置文件。此处建议将该配置文件由.properties格式改为.yml格式(虽然两者皆为官方推荐的格式)，因为相比较而言.yml比.properties更好用，后面我会写专文进行讨论；
    **test**是测试文件夹，存放我们编写的测试类；
- mvnw、mvnw.cmd：这两个文件之前已经说过了，此处不再赘述；
- pom.xml：Maven的配置文件，主要描述了项目的Maven坐标、依赖关系、开发者需要遵循的规则、缺陷管理系统、组织、licenses以及其他所有的项目相关因素，是项目级别的配置文件；
- firstboot.iml：IDEA的工程配置文件，里面是当前项目的一些配置信息，例如历史记录、版本控制信息等；
- External Libraries：即项目的外部依赖，此处的外部依赖由Maven自动导入，一般不需要操作和干预；
- Scratches and Consoles：划痕和控制台，IDEA提供的一个临时的文件编辑环境，通过该环境你可以写一些临时注释和项目上下文之外的代码片段，相当于一个草稿本的功能。

步骤06 启动FirstbootApplication，浏览器输入localhost:8080出现白页

![image-20200330204614392](https://i.loli.net/2020/03/30/lf8N1UHFIZzGeqm.png)

Inspections 为最高等级检查，可以检查单词拼写，语法错误，变量使用，方法之间调用等
Syntax 可以检查单词拼写，简单语法错误
None 不设置检查
IntelliJ IDEA 对于编辑大文件并没有太大优势，很卡，原因就是它有各种检查，这样是非常耗内存和 CPU 的，所以为了能加快大文件的读写，可以考虑暂时性设置为 None

`Power Save Mode` 省电模式，也可以通过`File -> Power Save Mode`来设置，开启这种模式之后 IntelliJ IDEA 会关掉代码检查和代码提示等功能。如果在开发过程中遇到突然代码文件不能进行检查和提示可以来看看这里是否有开启该功能

![image-20200330212055153](https://i.loli.net/2020/03/30/zdbRvZfIT743AD1.png)

### 所谓Controller就是起一个路由的作用啊

![img](https://i.loli.net/2020/03/30/STsVlKgZ5rUN1RW.png)