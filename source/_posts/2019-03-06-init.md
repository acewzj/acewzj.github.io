---
title:  "杂项文章"
date:   2019-03-06 09:49:18 +0800
categories:
- Other
tags:
- 自然数e 种子填充算法 
---



<!--more-->

## office2016专业增强版秘钥

　　Office 2016 Pro Plus Volume License MAK Key（VL批量授权版）：
　　QCKNG-29MKJ-74G4B-X7DT8-JFHBB





## 2、种子填充算法的递归关系

```c++
void boundaryFill4(int x, int y, Color fillColor, Color boarderColor) {
	Color interiorColor;
	getpixel(x, y, interiorColor);
	if (compareColor(interiorColor, fillColor) == 0 && compareColor(interiorColor, boarderColor) == 0) {
		setpixel(x, y);
		boundaryFill4(x - 1, y, fillColor, boarderColor);
		boundaryFill4(x, y + 1, fillColor, boarderColor);
		boundaryFill4(x + 1, y, fillColor, boarderColor);
		boundaryFill4(x, y - 1, fillColor, boarderColor);
	}

}
```

我原来以为的填充顺序是这样的：

![](https://i.loli.net/2019/12/14/CJPutDZ51m39TBz.png)

结果是这样的：

![](https://i.loli.net/2019/12/14/298AvhzrgjlEBsY.png)

## 点云

利用PCL的IO接口，将数据倒腾到PCD文件（PCD采用binary形式保存，ASCII性能实在太差）

![](https://i.loli.net/2019/12/17/1XTI8fLA4JKcYM3.png)

1. 首先，读取参考点云（reference,target）和目标点云（current,object）数据，在上述代码中分别对应ptCloudRef与ptCloudCurrent；
2. 去除体外孤点（可选，速度较慢）
3. 降采样，上述代码中采用的是网格采样的方法（除此之外，matlab point cloud processing还自带random方法，并且更加推荐使用random）。网格采样大体思路是件点云数据划分为正方体网格，每个网格内输出一个3D数据点，该点的位置则由网格中所有点平均得来。

## 3、超像素（Super Pixel）与亚像素（Sub Pixel）

本来看像素就是一个一个的二维像素点，但是超像素就是将相同的区域分割到了一起

![](https://pic3.zhimg.com/v2-4588a384c16721fa03ed0127ef13a982_r.jpg)

![](https://pic1.zhimg.com/v2-70bf0b56df5e5ba07f9719f15abaf681_r.jpg)

面阵摄像机的成像面以像素为最小单位。例如某[CMOS](https://baike.baidu.com/item/CMOS/428167)摄像芯片，其像素间距为5.2微米。摄像机拍摄时，将物理世界中连续的图像进行了[离散化](https://baike.baidu.com/item/离散化/10501557)处理。到成像面上每一个像素点只代表其附近的颜色。至于“附近”到什么程度？就很困难解释。两个像素之间有5.2微米的距离，在宏观上可以看作是连在一起的。但是在[微观](https://baike.baidu.com/item/微观/4542832)上，它们之间还有无限的更小的东西存在。这个更小的东西我们称它为“亚像素”。实际上“亚像素”应该是存在的，只是硬件上没有个细微的传感器把它检测出来。于是软件上把它近似地计算出来。

[数码摄像机](https://baike.baidu.com/item/数码摄像机/10935797)的成像面的分辨率以像素数量来衡量。隔行TV的分辨率是576x768个像素。 像素中心之间的距离有几个至十几个微米不等。为了最大限度利用图像信息来提高分辨率，有人提出了Sub-Pixel概念。意思是说，在两个物理像素之间还有像素，称之为Sub-Pixel，它完全是通过计算方法得出来的。这里提出计算方法。

如果原始图像是n行m列的，希望做k细分的Sub-Pixel，这样就有新的行N和列M，有

N = k*n

M = k*m

原来相邻4个像素包含的区域变成了(k+1)*(k+1)的区域了；要填满这个(k+1)*(k+1)的区域，实际上就是从一个小正方形映照到一个大正方形的过程。在数学上用双线性插值得算法可以轻松搞定。(二次或者三次[样条曲线](https://baike.baidu.com/item/样条曲线))。



## .PHONY与添加glibc库源代码



拿clean举例，如果make完成后，自己另外定义一个名叫clean的文件，再执行make clean时，将不会执行rm命令。
　　为了避免出现这个问题，需要.PHONY: clean

无法打开“printf.c”: 无法读取文件'/build/glibc-OTsEL5/glibc-2.27/stdio-common/printf.c' (Error: 无法解析不存在的文件"/build/glibc-OTsEL5/glibc-2.27/stdio-common/printf.c")。

```shell
$cd /
$sudo mkdir build
$cd build
$sudo mkdir glibc-LK5gWL（注意这里文件名对应报错的文件名）
$cd glibc-LK5gWL
$sudo wget http://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz （注意这里包的版本2.23对应报错版本）
$sudo tar -zxvf glibc-2.23.tar.gz
```

