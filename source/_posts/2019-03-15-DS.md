---
title:  "数据结构与算法"
date:   2019-03-15 10:06:18 +0800
categories:
- Data_Structure
tags:
- Data_Structure
---

本文主要关于数据结构（java），数据结构是指数据存储的组织方式。大致上分为线性表、栈（Stack）、队列、树（tree）、图（Map）。

<!--more-->







## 二叉树C++

```c++
#include <iostream>
using namespace std;

typedef struct BinaryTree {
	BinaryTree *Lchild;
	BinaryTree *Rchild;
	int data;
}BinaryTree;
int Construct(BinaryTree **T) {
	int ch;
	cin >> ch;
	if (ch == -1) {
		*T = NULL;
		return 0;
	}
	else
	{
		*T = (BinaryTree *)malloc(sizeof(BinaryTree));
		if (T == NULL)
			cout << "malloc failed!" << endl;
		else
		{
			(*T)->data = ch;
			cout << "请输入" << ch << "的左子节点：" << endl;
			Construct(&((*T)->Lchild));
			Construct(&((*T)->Rchild));
		}
			

	}

}
int main(int argc, char **argv) {
	cout << "BinaryTree Construct Stage..." << endl;
	BinaryTree *Btree;
	cout << "请输入二叉树第一个节点的值，-1代表叶子节点..." << endl;
	Construct(&Btree);
	return 0;
}
```

BTree本来是一个指向BinaryTree的指针，

因为有小伙伴问了，可否在构建二叉树传入的参数为一级地址。上述的方法是一定要传二级参数的，但是这里给出一个传一级参数的方法，小伙伴也可以通过对比两种方法，对二叉树的构建和传参方式有更深的理解。

```c
struct TreeNode* Create(){
	int val;
	scanf("%d", &val);
	
	struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode*));
	if (val <= 0) {
		return NULL;
	}
	
	if (!root) {
		printf("创建失败\n");
	}
 
	if (val > 0) {
		root->val = val;
		root->left = Create();
		root->right = Create();
	}
	 
	return root;
}
```

## 

## 二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```java
public class BinaryTree<T> {

    private Node<T> root;

    public BinaryTree() {
        root = null;
    }

    public BinaryTree(Node root) {
        this.root = root;
    }

    public void inOrder() {
        inOrder(root);
    }

    public void preOrder() {
        preOrder(root);
    }

    public void postOrder() {
        postOrder(root);
    }

    private void preOrder(Node node) {
        if (node == null) {
            return;
        }
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }

    private void inOrder(Node node) {
        if (node == null) {
            return;
        }
        inOrder(node.left);
        System.out.print(node.data + " ");
        inOrder(node.right);
    }

    private void postOrder(Node node) {
        if (node == null) {
            return;
        }
        postOrder(node.left);
        postOrder(node.right);
        System.out.print(node.data + " ");
    }

    // 节点
    static class Node<T> {
        T data;
        Node<T> left;
        Node<T> right;

        Node(T data) {
            this(data, null, null);
        }

        Node(T data, Node<T> left, Node<T> right) {
            this.data = data;
            this.left = left;
            this.right = right;
        }
    }

    public static void main(String[] args) {
        Node<Integer> node1 = new Node(2, new Node(4), new Node(5));
        Node<Integer> node2 = new Node(3, new Node(6), new Node(7));
        Node<Integer> root = new Node(1, node1, node2);
        BinaryTree<Integer> tree = new BinaryTree(root);
        tree.inOrder();
        System.out.println();
        tree.preOrder();
        System.out.println();
        tree.postOrder();
    }
}
```



## 求一个字符串中连续出现次数最多的子串

例如字符串“abababc”,最多连续出现的为ab，连续出现三次。要和求一个字符串中的最长重复子串区分开来，还是上面的字符串，那么最长的重复子串为abab。两个题目的解法有些类似，都用到了后缀数组这个数据结构。求一个字符串中连续出现的次数最多的子串，首先生成后缀数组例如上面的字符串为:

```c
abababc
bababc
ababc
babc
abc
bc
c
```

可以看出第一个后缀数组和第三个后缀数组的起始都为ab，第5个后缀数组也为ab。可以看出规律来，一个字符串s，如果第一次出现在后缀数组i的前面，那么如果它重复出现，下一次出现应该在第i+len(s)个后缀数组的前面。

```c
#include <iostream>
#include <cstring>
#include <utility>
#include <string>
#include <vector>
using namespace std;

pair<int, string> fun(const string& str)
{
    vector<string> subs;
    int len = str.size();
    for (int i = 0; i < len; i++)
    {
        subs.push_back(str.substr(i));
    }

    int count = 1;
    int maxCount = 1;
    string sub;

    for (int i = 0; i < len; i++)
    {
        for (int j = i + 1; j < len; j++)
        {
            count = 1;
            if (subs[i].substr(0, j - i) == subs[j].substr(0, j - i))
            {
                ++count;
                //j-i为子串长度
                for (int k = j + j - i; k < len; k += j - i)
                {
                    if (subs[i].substr(0, j - i) == subs[k].substr(0, j - i))
                    {
                        ++count;
                    }
                    else
                    {
                        break;
                    }
                }
                if (count > maxCount)
                {
                    maxCount = count;
                    sub = subs[i].substr(0, j - i);
                }
            }
        }
    }

    return make_pair(maxCount, sub);
}

int main()
{
    string str;
    pair<int, string> rs;
    while (cin>>str)
    {
        rs = fun(str);
        cout<<rs.second<<":"<<rs.first<<endl;
    }

    return 0;
}
```

## 不含有重复字符的最长子串 

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

![image-20200417085840556](https://i.loli.net/2020/04/17/RDhsTeHlZnBGOAu.png)

```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //s[start,end) 前面包含 后面不包含
        int start(0), end(0), length(0), result(0);
        int sSize = int(s.size());
        while(end < sSize)
        {
            char tempChar = s[end];
            for(int index = start;index < end;index++)
            {//去滑动窗口里面去看看有么有重复的元素
                if(tempChar == s[index])
                {
                    start = index + 1;
                    length=end - start;
                    break;                   
                }
            }
        end++;
        length++;
        result = max(result,length);//有可能后面的窗口越来越小，所以要保留前面的最大值            
        }
    return result;
    }
};
-----------------------------
Hashmap
-----------------------------
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //s[start,end) 前面包含 后面不包含
        int start(0), end(0), length(0), result(0);
        unordered_map<char,int> hash;
        int sSize = s.length();
        while(end < sSize)
        {
            char tempChar = s[end];
            if(hash.find(tempChar) != hash.end() && hash[tempChar] > start)
            {
                    start = hash[tempChar] + 1;
                    length=end - start;                
            }
        hash[tempChar] = end;
        end++;
        length++;
        result = max(result,length);            
        }
    return result;
    }
};
```

## 最长回文子串



## 找出数组中出现奇数次的元素(WeGame)

给定一个含有n个元素的整型数组a，其中只有一个元素出现奇数次，找出这个元素。

因为对于任意一个数k，有k ^ k = 0，k ^ 0 = k，所以将a中所有元素进行异或，那么个数为偶数的元素异或后都变成了0，只留下了个数为奇数的那个元素。

```c
#include <stdio.h>
int FindElementWithOddCount(int* a, int n)
{
	int r = a[0];
	for (int i = 1; i < n; ++i)
	{
		r ^= a[i];
	}
	return r;
}
int main()
{
	int array[] = { 1, 2, 2, 3, 3, 4, 1 };
	int len = sizeof(array) / sizeof(array[0]);
	printf("%d\n", FindElementWithOddCount(array, len));
	getchar();
	return 0;
}
```

## 



## 删除链表的倒数第 N 个节点

![](https://i.loli.net/2020/04/20/43HM1ZpB7YWQi9N.gif)

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.

这道题很巧妙：

其一是设置了一个虚拟的头结点：这是为了防止让你删除倒数第四个结点时结果把自己的头结点给删除了。。。

其二是窗口的大小比你要删除的大小要大一个，这样可以直接用后面那个的next来删除，省却了后面跟一个伴随指针来做删除。所以你看到n+1

注意看它的动图，它最后q指针指向了null，我感到困惑：指到5不就行了吗？

注意他这里是q，而不是q->next。所以指到5之后还要进行一次while循环，因为q不为空嘛！

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //ListNode *temp = head;
       ListNode *temp = new ListNode(0);
       temp -> next = head;
       ListNode *last = temp;
       ListNode *first = temp;
        for(int i = 0; i < n+1 ; i++)
        {
            first = first->next;
        }

        while(first)
        {
            last = last->next;
            first = first->next;
        }
			ListNode *delNode = last->next;
			last->next = delNode->next;
			delete delNode;
			
			ListNode *retNode = temp->next;
			delete temp;
			
			return retNode;
        
    }
};
```



举个例子，遍历经过 IVIV 的时候先记录 II 的对应值 11 再往前移动一步记录 IVIV 的值 33，加起来正好是 IVIV 的真实值 44。max 函数在这里是为了防止遍历第一个字符的时候出现 [-1:0][−1:0] 的情况

```
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<string, int> m = {{"I", 1}, {"IV", 3}, {"IX", 8}, {"V", 5}, {"X", 10}, {"XL", 30}, {"XC", 80}, {"L", 50}, {"C", 100}, {"CD", 300}, {"CM", 800}, {"D", 500}, {"M", 1000}};
        int r = m[s.substr(0, 1)];
        for(int i=1; i<s.size(); ++i){
            string two = s.substr(i-1, 2);
            string one = s.substr(i, 1);
            r += m[two] ? m[two] : m[one];
        }
        return r;
    }
};
```

## [旋转链表](https://leetcode-cn.com/problems/rotate-list/)

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL

 

```c
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
    if (head == NULL) return NULL;
    if (head->next == NULL) return head;
    ListNode* temp;
    temp = head;
    int length = 1;

        while (temp->next)
        {
            ++length;
            temp = temp->next;
        }
        temp->next = head;
        if (k%=length)
        {
            for (int i = 0; i < length - k; ++i)
            {
                temp = temp->next;
            }
        }
        ListNode* res = temp->next;
        temp->next = NULL;
    return res;
    }
};
```

这个代码有以下几个值得学习的地方：

将链表做成一个回环：注意空链表与单链表特例

使用++len而不是len++，省却拷贝花销

这里的k%=len很巧妙：其一是对于0和链表长度的k不进行处理--因为就算翻转过来也和原链表一样

其二是将k值重新设置为小于等于len的数值，防止下面len-k出现溢出

还有一点需要注意的是每次你想设置一个节点来追踪前链表元素的时候，不妨考虑一下少走一步？

我本来for循环里是写的head= head->next，前面设置一个节点来做游标，不如人家这个直接使用temp尾节点来做游标好一些。。。

## 快速排序  从数组里面找出K大的数

快排是这样解决的，假设做正序排序：

> 在数组的头部和尾部分别设置一个`哨兵`，同时向对方走去。尾部的哨兵如发现有比基准数小的数，停下。头部的哨兵如发现有比基准数大的数，停下。交换两个数。再重新走重复前面的交换过程。直到两个哨兵相遇，交换基准数和尾哨兵。

## 冒泡排序

冒泡排序是由两个for循环构成，第一个for循环的变量 i 表示总共需要多少轮比较，第二个for循环的变量 j 表示每轮参与比较的元素下标【0,1，......，length-i】，因为每轮比较都会出现一个最大值放在最右边，所以每轮比较后的元素个数都会少一个，这也是为什么 j 的范围是逐渐减小的。



```java
package bublesort;
public class bublesort{
    //遍历显示数组
    public static void display(int[] array){
        for(int i = 0 ; i < array.length ; i++){
            System.out.print(array[i]+" ");
        }
        System.out.println();
    }
	public static int[] sort(int[] array){
		for(int i=1;i<array.length;i++){
			for(int j=0;j<array.length - i;j++){
				if(array[j]>array[j+1]){
					int temp;
					temp = array[j+1];
					array[j+1] = array[j];
					array[j] = temp;					 
				}
			}
			display(array);
		}
		
		return array;	
	}
	public static void main(String[] args) {
		int[] aaa={32,34,12,3,56,4,7};
		 sort(aaa);
		 
	}
}
```

//内层循环控制 元素 进行比较交换的次数；i为什么从1开始？你要看最后那个 4，5这两个元素，只要比较4和5就行了，5之后就不用比较了。。。

//外层循环控制

## 手写strcpy()

```c
#include<iostream>
using namespace std;

char* strcpy(char *strSrc, char *strDest)
{
	if ((strSrc == NULL) || (strDest == NULL))
		return NULL;
	char *strDestCopy = strDest;
	while ((*strDest++ = *strSrc++) != '\0');
		return strDestCopy;
}


int main()
{
	char strSrc[] = "Hello World!";
	char strDest[20];
	strcpy(strSrc, strDest);
	cout << "strDest: " << strDest << endl;
	return 0;
}
```

