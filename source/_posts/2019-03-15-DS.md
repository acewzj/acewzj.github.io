---
title:  "数据结构"
date:   2019-03-15 10:06:18 +0800
categories:
- Data_Structure
tags:
- Data_Structure
---

本文主要关于数据结构（java），数据结构是指数据存储的组织方式。大致上分为线性表、栈（Stack）、队列、树（tree）、图（Map）。

<!--more-->









## 二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```java
public class BinaryTree<T> {

    private Node<T> root;

    public BinaryTree() {
        root = null;
    }

    public BinaryTree(Node root) {
        this.root = root;
    }

    public void inOrder() {
        inOrder(root);
    }

    public void preOrder() {
        preOrder(root);
    }

    public void postOrder() {
        postOrder(root);
    }

    private void preOrder(Node node) {
        if (node == null) {
            return;
        }
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }

    private void inOrder(Node node) {
        if (node == null) {
            return;
        }
        inOrder(node.left);
        System.out.print(node.data + " ");
        inOrder(node.right);
    }

    private void postOrder(Node node) {
        if (node == null) {
            return;
        }
        postOrder(node.left);
        postOrder(node.right);
        System.out.print(node.data + " ");
    }

    // 节点
    static class Node<T> {
        T data;
        Node<T> left;
        Node<T> right;

        Node(T data) {
            this(data, null, null);
        }

        Node(T data, Node<T> left, Node<T> right) {
            this.data = data;
            this.left = left;
            this.right = right;
        }
    }

    public static void main(String[] args) {
        Node<Integer> node1 = new Node(2, new Node(4), new Node(5));
        Node<Integer> node2 = new Node(3, new Node(6), new Node(7));
        Node<Integer> root = new Node(1, node1, node2);
        BinaryTree<Integer> tree = new BinaryTree(root);
        tree.inOrder();
        System.out.println();
        tree.preOrder();
        System.out.println();
        tree.postOrder();
    }
}
```

## 冒泡排序

冒泡排序是由两个for循环构成，第一个for循环的变量 i 表示总共需要多少轮比较，第二个for循环的变量 j 表示每轮参与比较的元素下标【0,1，......，length-i】，因为每轮比较都会出现一个最大值放在最右边，所以每轮比较后的元素个数都会少一个，这也是为什么 j 的范围是逐渐减小的。



```java
package bublesort;
public class bublesort{
    //遍历显示数组
    public static void display(int[] array){
        for(int i = 0 ; i < array.length ; i++){
            System.out.print(array[i]+" ");
        }
        System.out.println();
    }
	public static int[] sort(int[] array){
		for(int i=1;i<array.length;i++){
			for(int j=0;j<array.length - i;j++){
				if(array[j]>array[j+1]){
					int temp;
					temp = array[j+1];
					array[j+1] = array[j];
					array[j] = temp;					 
				}
			}
			display(array);
		}
		
		return array;	
	}
	public static void main(String[] args) {
		int[] aaa={32,34,12,3,56,4,7};
		 sort(aaa);
		 
	}
}
```



## 求一个字符串中连续出现次数最多的子串

例如字符串“abababc”,最多连续出现的为ab，连续出现三次。要和求一个字符串中的最长重复子串区分开来，还是上面的字符串，那么最长的重复子串为abab。两个题目的解法有些类似，都用到了后缀数组这个数据结构。求一个字符串中连续出现的次数最多的子串，首先生成后缀数组例如上面的字符串为:

```c
abababc
bababc
ababc
babc
abc
bc
c
```

可以看出第一个后缀数组和第三个后缀数组的起始都为ab，第5个后缀数组也为ab。可以看出规律来，一个字符串s，如果第一次出现在后缀数组i的前面，那么如果它重复出现，下一次出现应该在第i+len(s)个后缀数组的前面。

```c
#include <iostream>
#include <cstring>
#include <utility>
#include <string>
#include <vector>
using namespace std;

pair<int, string> fun(const string& str)
{
    vector<string> subs;
    int len = str.size();
    for (int i = 0; i < len; i++)
    {
        subs.push_back(str.substr(i));
    }

    int count = 1;
    int maxCount = 1;
    string sub;

    for (int i = 0; i < len; i++)
    {
        for (int j = i + 1; j < len; j++)
        {
            count = 1;
            if (subs[i].substr(0, j - i) == subs[j].substr(0, j - i))
            {
                ++count;
                //j-i为子串长度
                for (int k = j + j - i; k < len; k += j - i)
                {
                    if (subs[i].substr(0, j - i) == subs[k].substr(0, j - i))
                    {
                        ++count;
                    }
                    else
                    {
                        break;
                    }
                }
                if (count > maxCount)
                {
                    maxCount = count;
                    sub = subs[i].substr(0, j - i);
                }
            }
        }
    }

    return make_pair(maxCount, sub);
}

int main()
{
    string str;
    pair<int, string> rs;
    while (cin>>str)
    {
        rs = fun(str);
        cout<<rs.second<<":"<<rs.first<<endl;
    }

    return 0;
}
```

