---






 title:  "数据结构与算法"
date:   2019-03-15 10:06:18 +0800
categories:
- Data_Structure
tags:
- Data_Structure
---

本文主要关于数据结构（java），数据结构是指数据存储的组织方式。大致上分为线性表、栈（Stack）、队列、树（tree）、图（Map）。

<!--more-->

```c
#include <iostream>
 
int main() {
    // 带 else 子句的简单 if 语句
    int i = 5;
    if (i < 2) {
        std::cout << i << " < 2\n";
    } else if(i > 3)
    
    {
        std::cout << i << " > 3\n";
    }
    else if(i > 4){
        std::cout << i << " > 4\n";
    }
}
---------
    5 > 3
--------
//它不执行下面那个 5 > 4 了！！！
```

## [从先序遍历还原二叉树](https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/)

```c
class Solution {
public:
    TreeNode* recoverFromPreorder(string S) {
        stack<TreeNode*> path;
        int pos = 0;
        while (pos < S.size()) {
            int level = 0;
            while (S[pos] == '-') {
                ++level;
                ++pos;
            }
            int value = 0;
            while (pos < S.size() && isdigit(S[pos])) {
                value = value * 10 + (S[pos] - '0');
                ++pos;
            }
            TreeNode* node = new TreeNode(value);
            if (level == path.size()) {
                if (!path.empty()) {
                    path.top()->left = node;
                }
            }
            else {
                while (level != path.size()) {
                    path.pop();
                }
                path.top()->right = node;
            }
            path.push(node);
        }
        while (path.size() > 1) {
            path.pop();
        }
        return path.top();
    }
};
```





```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* recoverFromPreorder(string str) {
        stack<TreeNode*> treeStack;
        TreeNode* root = nullptr;

        int index      = 0;
        int levl       = 0;

        while (index < str.length())
        {
            // 如果是 - ，增加层级
            if (str[index] == '-')
            {
                levl++;
                index++;
                continue;
            }

            // 字符转数字
            int val = 0;
            while (index < str.length() && str[index] != '-')
            {
                val = val * 10 + (str[index] - '0');
                index++;
            }

            // 如果层级低于现在的层级，那么说明它是上某级的右节点
            while (levl < treeStack.size() && treeStack.size() > 0)
            {
                treeStack.pop();
            }

            // 确定节点层级后，要么是根，要么是别人的子节点
            TreeNode* tempNode = new TreeNode(val);
            if (treeStack.size() <= 0)
            {
                root = tempNode;
                treeStack.push(root);
            }     
            //注意看这里！！！
            else if (treeStack.top()->left == NULL)
            {
                treeStack.top()->left = tempNode;
                treeStack.push(treeStack.top()->left);
            }
            //注意看这里！！！
            else if (treeStack.top()->right == NULL)
            {
                treeStack.top()->right = tempNode;
                treeStack.push(treeStack.top()->right);
            }
            
            // 层级清空
            levl = 0;
        }

        return root;
    }
};


```

## 最长重复子数组记住，子序列默认不连续，子数组默认连续

注意子数组和子序列的区别 如果是子序列的话 递推公式就是 ： dp[i][j] = max(dp[i-1][j-1]+(A[i-1] == B[j-1]?1:0),dp[i-1][j],dp[i][j-1]) 三个里面挑最大

输入:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出: 3
解释: 
长度最长的公共子数组是 [3, 2, 1]。

```c
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int n = A.size(), m = B.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        int ans = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                dp[i][j] = A[i-1] == B[j-1] ? dp[i - 1][j - 1] + 1 : 0;
                ans = max(ans, dp[i][j]);
            }
        }
        return ans;
    }
};
------------
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int n = A.size(), m = B.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                dp[i+1][j+1] = A[i] == B[j] ? dp[i][j] + 1 : 0;
                ans = max(ans, dp[i+1][j+1]);
            }
        }
        return ans;
    }
};
```



## 二叉树C++

```c++
#include <iostream>
using namespace std;

typedef struct BinaryTree {
	BinaryTree *Lchild;
	BinaryTree *Rchild;
	int data;
}BinaryTree;
int Construct(BinaryTree **T) {
	int ch;
	cin >> ch;
	if (ch == -1) {
		*T = NULL;
		return 0;
	}
	else
	{
		*T = (BinaryTree *)malloc(sizeof(BinaryTree));
		if (T == NULL)
			cout << "malloc failed!" << endl;
		else
		{
			(*T)->data = ch;
			cout << "请输入" << ch << "的左子节点：" << endl;
			Construct(&((*T)->Lchild));
			Construct(&((*T)->Rchild));
		}
			

	}

}
int main(int argc, char **argv) {
	cout << "BinaryTree Construct Stage..." << endl;
	BinaryTree *Btree;
	cout << "请输入二叉树第一个节点的值，-1代表叶子节点..." << endl;
	Construct(&Btree);
	return 0;
}
```

BTree本来是一个指向BinaryTree的指针，

因为有小伙伴问了，可否在构建二叉树传入的参数为一级地址。上述的方法是一定要传二级参数的，但是这里给出一个传一级参数的方法，小伙伴也可以通过对比两种方法，对二叉树的构建和传参方式有更深的理解。

```c
struct TreeNode* Create(){
	int val;
	scanf("%d", &val);
	
	struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode*));
	if (val <= 0) {
		return NULL;
	}
	
	if (!root) {
		printf("创建失败\n");
	}
 
	if (val > 0) {
		root->val = val;
		root->left = Create();
		root->right = Create();
	}
	 
	return root;
}
```

## 

## 二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```java
public class BinaryTree<T> {

    private Node<T> root;

    public BinaryTree() {
        root = null;
    }

    public BinaryTree(Node root) {
        this.root = root;
    }

    public void inOrder() {
        inOrder(root);
    }

    public void preOrder() {
        preOrder(root);
    }

    public void postOrder() {
        postOrder(root);
    }

    private void preOrder(Node node) {
        if (node == null) {
            return;
        }
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }

    private void inOrder(Node node) {
        if (node == null) {
            return;
        }
        inOrder(node.left);
        System.out.print(node.data + " ");
        inOrder(node.right);
    }

    private void postOrder(Node node) {
        if (node == null) {
            return;
        }
        postOrder(node.left);
        postOrder(node.right);
        System.out.print(node.data + " ");
    }

    // 节点
    static class Node<T> {
        T data;
        Node<T> left;
        Node<T> right;

        Node(T data) {
            this(data, null, null);
        }

        Node(T data, Node<T> left, Node<T> right) {
            this.data = data;
            this.left = left;
            this.right = right;
        }
    }

    public static void main(String[] args) {
        Node<Integer> node1 = new Node(2, new Node(4), new Node(5));
        Node<Integer> node2 = new Node(3, new Node(6), new Node(7));
        Node<Integer> root = new Node(1, node1, node2);
        BinaryTree<Integer> tree = new BinaryTree(root);
        tree.inOrder();
        System.out.println();
        tree.preOrder();
        System.out.println();
        tree.postOrder();
    }
}
```



## 求一个字符串中连续出现次数最多的子串

例如字符串“abababc”,最多连续出现的为ab，连续出现三次。要和求一个字符串中的最长重复子串区分开来，还是上面的字符串，那么最长的重复子串为abab。两个题目的解法有些类似，都用到了后缀数组这个数据结构。求一个字符串中连续出现的次数最多的子串，首先生成后缀数组例如上面的字符串为:

```c
abababc
bababc
ababc
babc
abc
bc
c
```

可以看出第一个后缀数组和第三个后缀数组的起始都为ab，第5个后缀数组也为ab。可以看出规律来，一个字符串s，如果第一次出现在后缀数组i的前面，那么如果它重复出现，下一次出现应该在第i+len(s)个后缀数组的前面。

```c
#include <iostream>
#include <cstring>
#include <utility>
#include <string>
#include <vector>
using namespace std;

pair<int, string> fun(const string& str)
{
    vector<string> subs;
    int len = str.size();
    for (int i = 0; i < len; i++)
    {
        subs.push_back(str.substr(i));
    }

    int count = 1;
    int maxCount = 1;
    string sub;

    for (int i = 0; i < len; i++)
    {
        for (int j = i + 1; j < len; j++)
        {
            count = 1;
            if (subs[i].substr(0, j - i) == subs[j].substr(0, j - i))
            {
                ++count;
                //j-i为子串长度
                for (int k = j + j - i; k < len; k += j - i)
                {
                    if (subs[i].substr(0, j - i) == subs[k].substr(0, j - i))
                    {
                        ++count;
                    }
                    else
                    {
                        break;
                    }
                }
                if (count > maxCount)
                {
                    maxCount = count;
                    sub = subs[i].substr(0, j - i);
                }
            }
        }
    }

    return make_pair(maxCount, sub);
}

int main()
{
    string str;
    pair<int, string> rs;
    while (cin>>str)
    {
        rs = fun(str);
        cout<<rs.second<<":"<<rs.first<<endl;
    }

    return 0;
}
```

## 不含有重复字符的最长子串 

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

![image-20200417085840556](https://i.loli.net/2020/04/17/RDhsTeHlZnBGOAu.png)

```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //s[start,end) 前面包含 后面不包含
        int start(0), end(0), length(0), result(0);
        int sSize = int(s.size());
        while(end < sSize)
        {
            char tempChar = s[end];
            for(int index = start;index < end;index++)
            {//去滑动窗口里面去看看有么有重复的元素
                if(tempChar == s[index])
                {
                    start = index + 1;
                    length=end - start;
                    break;                   
                }
            }
        end++;
        length++;
        result = max(result,length);//有可能后面的窗口越来越小，所以要保留前面的最大值            
        }
    return result;
    }
};
-----------------------------
Hashmap
-----------------------------
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //s[start,end) 前面包含 后面不包含
        int start(0), end(0), length(0), result(0);
        unordered_map<char,int> hash;
        int sSize = s.length();
        while(end < sSize)
        {
            char tempChar = s[end];
            if(hash.find(tempChar) != hash.end() && hash[tempChar] > start)
            {
                    start = hash[tempChar] + 1;
                    length=end - start;                
            }
        hash[tempChar] = end;
        end++;
        length++;
        result = max(result,length);            
        }
    return result;
    }
};
```

## 最长回文子串



## 找出数组中出现奇数次的元素(WeGame)

给定一个含有n个元素的整型数组a，其中只有一个元素出现奇数次，找出这个元素。

因为对于任意一个数k，有k ^ k = 0，k ^ 0 = k，所以将a中所有元素进行异或，那么个数为偶数的元素异或后都变成了0，只留下了个数为奇数的那个元素。

```c
#include <stdio.h>
int FindElementWithOddCount(int* a, int n)
{
	int r = a[0];
	for (int i = 1; i < n; ++i)
	{
		r ^= a[i];
	}
	return r;
}
int main()
{
	int array[] = { 1, 2, 2, 3, 3, 4, 1 };
	int len = sizeof(array) / sizeof(array[0]);
	printf("%d\n", FindElementWithOddCount(array, len));
	getchar();
	return 0;
}
```

## 



## 删除链表的倒数第 N 个节点

![](https://i.loli.net/2020/04/20/43HM1ZpB7YWQi9N.gif)

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.

这道题很巧妙：

其一是设置了一个虚拟的头结点：这是为了防止让你删除倒数第四个结点时结果把自己的头结点给删除了。。。

其二是窗口的大小比你要删除的大小要大一个，这样可以直接用后面那个的next来删除，省却了后面跟一个伴随指针来做删除。所以你看到n+1

**注意看它的动图，它最后q指针指向了null，我感到困惑：指到5不就行了吗？**

**注意他这里是q，而不是q->next。所以指到5之后还要进行一次while循环，因为q不为空嘛！**

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //ListNode *temp = head;
       ListNode *temp = new ListNode(0);
       temp -> next = head;
       ListNode *last = temp;
       ListNode *first = temp;
        for(int i = 0; i < n+1 ; i++)
        {
            first = first->next;
        }

        while(first)
        {
            last = last->next;
            first = first->next;
        }
			ListNode *delNode = last->next;
			last->next = delNode->next;
			delete delNode;
			
			ListNode *retNode = temp->next;
			delete temp;
			
			return retNode;
        
    }
};
```



举个例子，遍历经过 IVIV 的时候先记录 II 的对应值 11 再往前移动一步记录 IVIV 的值 33，加起来正好是 IVIV 的真实值 44。max 函数在这里是为了防止遍历第一个字符的时候出现 [-1:0][−1:0] 的情况

```
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<string, int> m = {{"I", 1}, {"IV", 3}, {"IX", 8}, {"V", 5}, {"X", 10}, {"XL", 30}, {"XC", 80}, {"L", 50}, {"C", 100}, {"CD", 300}, {"CM", 800}, {"D", 500}, {"M", 1000}};
        int r = m[s.substr(0, 1)];
        for(int i=1; i<s.size(); ++i){
            string two = s.substr(i-1, 2);
            string one = s.substr(i, 1);
            r += m[two] ? m[two] : m[one];
        }
        return r;
    }
};
```

## [旋转链表](https://leetcode-cn.com/problems/rotate-list/)

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL

 

```c
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
    if (head == NULL) return NULL;
    if (head->next == NULL) return head;
    ListNode* temp;
    temp = head;
    int length = 1;

        while (temp->next)
        {
            ++length;
            temp = temp->next;
        }
        temp->next = head;
        if (k%=length)
        {
            for (int i = 0; i < length - k; ++i)
            {
                temp = temp->next;
            }
        }
        ListNode* res = temp->next;
        temp->next = NULL;
    return res;
    }
};
```

这个代码有以下几个值得学习的地方：

将链表做成一个回环：注意空链表与单链表特例

使用++len而不是len++，省却拷贝花销

这里的k%=len很巧妙：其一是对于0和链表长度的k不进行处理--因为就算翻转过来也和原链表一样

其二是将k值重新设置为小于等于len的数值，防止下面len-k出现溢出

还有一点需要注意的是每次你想设置一个节点来追踪前链表元素的时候，不妨考虑一下少走一步？

我本来for循环里是写的head= head->next，前面设置一个节点来做游标，不如人家这个直接使用temp尾节点来做游标好一些。。。

## 快速排序  从数组里面找出K大的数

快排是这样解决的，假设做正序排序：

> 在数组的头部和尾部分别设置一个`哨兵`，同时向对方走去。尾部的哨兵如发现有比基准数小的数，停下。头部的哨兵如发现有比基准数大的数，停下。交换两个数。再重新走重复前面的交换过程。直到两个哨兵相遇，交换基准数和尾哨兵。

```c
class Solution {
public:
    int quickSelect(vector<int>& nums, int left, int right, int target){
        int q = randomPartition(nums, left, right);
        if(q == target){
            cout << q << endl;
            for(auto& i : nums)
                cout << i << "  ";
            return nums[q];
        }            
        else
            return q > target? quickSelect(nums, left, q-1, target):quickSelect(nums, q+1, right, target);
    }
    int randomPartition(vector<int>& nums, int left, int right){
        int i = rand() % (right - left + 1) + left;
        //cout << i << " ";
        swap(nums[i], nums[right]); 
        int k = left;
        for(int j = left; j <= right; ++j){
            if(nums[j] < nums[right]){
                swap(nums[k], nums[j]);
                k++;
            }
        }
        swap(nums[k], nums[right]); 
        return k;
    }
    int findKthLargest(vector<int>& nums, int k) {
        //srand(time(0));
        return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);
    }
};
//补充关于rand（）：生成一个在 0 - RAND_MAX 之间的伪随机数； srand():种植随机数种子

//当我们任意选取一个随机索引 i ，将nums[i]（枢轴） 与 nums[right] 进行交换，然后从 left 开始遍历，碰到比枢轴 大 的元素 还好，因为我们最后的结果就是让枢轴左边的元素都小于枢轴，枢轴右边的元素都大于枢轴。所以当所有的元素都大于枢轴时最后只需要将枢轴和 [0] 元素进行交换就好了。但是碰到比枢轴 小 的元素时就要将它与前面比枢轴大的元素进行交换。k 所指的元素就是前面大的元素的下标，碰到第一个大的它就不走了。
```

我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 $n$ 的问题我们都划分成 $1$ 和 $n - 1$，每次递归的时候又向 $n - 1$ 的集合中递归，这种情况是最坏的，时间代价是 $O(n ^ 2) $,我们可以引入随机化来加速这个过程，它的时间代价的期望是$ O(n)$ 

快速排序算法对于长度已经确定的数组是有效的，但是对于动态数组只能用下面的堆排序了； 

rand() 的内部实现是用线性同余法做的，它不是真的随机数，因其周期特别长，故在一定的范围里可看成是随机的。

rand() 返回一随机数值的范围在 0 至 RAND_MAX 间。RAND_MAX 的范围最少是在 32767 之间(int)。用 unsigned int 双字节是 65535，四字节是 4294967295 的整数范围。0~RAND_MAX 每个数字被选中的机率是相同的。

用户未设定随机数种子时，系统默认的随机数种子为 1。

rand() 产生的是伪随机数字，每次执行时是相同的; 若要不同, 用函数 srand() 初始化它。

这道题是面试高频题目，其实主要是考察堆排序的：

堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：

## 堆排序

https://zhuanlan.zhihu.com/p/45725214

堆排序分为三个步骤：1）建堆 2）调整堆 3）排序

建堆时要从第一个非叶子节点从下至上，从右至左调整，第一个非叶子节点就是数组长度的一半 - 1

```c
//1.构建大顶堆
for(int i=arr.length/2-1;i>=0;i--){
    //从第一个非叶子结点从下至上，从右至左调整结构
    adjustHeap(arr,i,arr.length);
}

void adjustHeap(vector<int>& a, int i, int heapSize) {
    int l = i * 2 + 1, r = i * 2 + 2, largest = i;
    if (l < heapSize && a[l] > a[largest]) {//限制叶子节点
        largest = l;
    } 
    if (r < heapSize && a[r] > a[largest]) {
        largest = r;
    }
    if (largest != i) {
        swap(a[i], a[largest]);
        maxHeapify(a, largest, heapSize);
    }
}
for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {
    swap(nums[0], nums[i]);
    //cout << nums[i];
    --heapSize;
    maxHeapify(nums, 0, heapSize);
}

```



## 冒泡排序

冒泡排序是由两个for循环构成，第一个for循环的变量 i 表示总共需要多少轮比较，第二个for循环的变量 j 表示每轮参与比较的元素下标【0,1，......，length-i】，因为每轮比较都会出现一个最大值放在最右边，所以每轮比较后的元素个数都会少一个，这也是为什么 j 的范围是逐渐减小的。



```java
package bublesort;
public class bublesort{
    //遍历显示数组
    public static void display(int[] array){
        for(int i = 0 ; i < array.length ; i++){
            System.out.print(array[i]+" ");
        }
        System.out.println();
    }
	public static int[] sort(int[] array){
		for(int i=1;i<array.length;i++){
			for(int j=0;j<array.length - i;j++){
				if(array[j]>array[j+1]){
					int temp;
					temp = array[j+1];
					array[j+1] = array[j];
					array[j] = temp;					 
				}
			}
			display(array);
		}
		
		return array;	
	}
	public static void main(String[] args) {
		int[] aaa={32,34,12,3,56,4,7};
		 sort(aaa);
		 
	}
}
```

//内层循环控制 元素 进行比较交换的次数；i为什么从1开始？你要看最后那个 4，5这两个元素，只要比较4和5就行了，5之后就不用比较了。。。

//外层循环控制

```c
void BubbleSort(int arr[], int n)
{
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

05-31:突然发现这种{}的锁进方式也不失为一个良好的选择--通过}与 for if 的对齐来进行辨别，减少代码行数，有利于阅读

如何考虑 n 和 n - 1 呢？

其实就是看最后一个元素也要参与进去吗？在冒泡排序里面，最后一个元素是不用参与比较的，所以这里是 n - 1；

## 归并排序：补充：关于end - start 

一直以来困惑于个数和长度的计算，比如 start = 71, end = 253,问你中间有多少个元素啊？

很简答：253 - 71 = 182

这样做忽略了 start = 71这个元素的基石作用，实际上是在它的基础上才有了这么多元素，所以最后要加 1 =》 183

```c
void Merge(int arr[], int reg[], int start, int end) {
    if (start >= end)return;
    int len = end - start, mid = (len >> 1) + start;

    //分成两部分
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
    //然后合并
    Merge(arr, reg, start1, end1);
    Merge(arr, reg, start2, end2);


    int k = start;
    //两个序列一一比较,哪的序列的元素小就放进reg序列里面,然后位置+1再与另一个序列原来位置的元素比较
    //如此反复,可以把两个有序的序列合并成一个有序的序列
    while (start1 <= end1 && start2 <= end2)
        reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];

    //然后这里是分情况,如果arr2序列的已经全部都放进reg序列了然后跳出了循环
    //那就表示arr序列还有更大的元素(一个或多个)没有放进reg序列,所以这一步就是接着放
    while (start1 <= end1)
        reg[k++] = arr[start1++];

    //这一步和上面一样
    while (start2 <= end2)
        reg[k++] = arr[start2++];
    //把已经有序的reg序列放回arr序列中
    for (k = start; k <= end; k++)
        arr[k] = reg[k];
}

void MergeSort(int arr[], const int len) {
    //创建一个同样长度的序列,用于临时存放
    int  reg[len];
    Merge(arr, reg, 0, len - 1);
}

```

## 向下向右走的动态规划

这类经典的题目需要注意以下几点：

1：你可以使用滚动数组，滚动数组的形式是dp[j] = dp[j] + dp[j-1]; 这个形式是跟 `dp[i][j]=dp[i][j-1]+dp[i-1][j]` 有关的；

这个dp[j-1]是更新过的,就是这行，相当于`dp[i][j-1]`,而dp[j] 是没有更新过的，就是上一行老值，相当于`dp[i-1][j]`

>![image-20200714093330347](https://i.loli.net/2020/07/14/rVjFalX6ivC7KYt.png)
>
>#### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

2：你也可以使用二维数组，注意申请数组时容量大小要不要比size 大1？就是看最后要不要考虑length+1这个元素

3：边界条件的判断中，格外注意一下最上边一行，最右边一列，以及开头元素的特殊处理，这些可以通过在for 循环中加 if 条件判断，也可以在之前额外加一个循环单独处理这些边界条件，最后从1开始，

4：有些题目（勇士救公主[174. 地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)）从开头进行动态规划比较复杂，可以换个思路从终点往起点往回推

## 手写strcpy()

```c
#include<iostream>
using namespace std;

char* strcpy(char *strSrc, char *strDest)
{
	if ((strSrc == NULL) || (strDest == NULL))
		return NULL;
	char *strDestCopy = strDest;
	while ((*strDest++ = *strSrc++) != '\0');
		return strDestCopy;
}


int main()
{
	char strSrc[] = "Hello World!";
	char strDest[20];
	strcpy(strSrc, strDest);
	cout << "strDest: " << strDest << endl;
	return 0;
}
```






## 链表相邻元素翻转

输入 bacd 输出 abdc

```c
#include <iostream>
#include <string>
 
using namespace std;
 
struct linknode{
	char data;
	linknode * next;
};
 
int main() {
	linknode* head = NULL;
	linknode* tail = NULL;
	string chs;
	cin>>chs;
	for(int i=0;i<chs.size();i++){
		linknode* newNode=(linknode*)malloc(sizeof(linknode));
		newNode->data=chs[i];
		newNode->next=NULL;
		if(tail==NULL)
			head=tail=newNode;
		else
		{
			tail->next=newNode;
			tail=newNode;
		}
	}
	if(head==NULL) 
		return 0;
	linknode *q=head,*pre=NULL;
	while(q && q->next)
	{
		linknode *p1=q,*p2=q->next;
		q=p2->next;
		p1->next=p2->next;
		p2->next=p1;
		if (pre == NULL) 
			head = p2;
		else		 
			pre->next = p2;
		pre = p1;
	}
 
	while(head!=NULL){
		cout<<head->data;
		head=head->next;
	}
	cout << endl;
	return 0;
}
```

## 合并两个有序链表

```c
ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
    if ((!a) || (!b)) return a ? a : b;
    ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
    while (aPtr && bPtr) {
        if (aPtr->val < bPtr->val) {
            tail->next = aPtr; aPtr = aPtr->next;
        } else {
            tail->next = bPtr; bPtr = bPtr->next;
        }
        tail = tail->next;
    }
    tail->next = (aPtr ? aPtr : bPtr);
    return head.next;
}
```



# 字符匹配

题目：glob是一种Unix风格的路径匹配模式，其规则如下：
        1.字符/作为分隔符存在
        2.字符\*匹配除/之外的任意长度的任意字符
        3.字符？匹配除/之外的单个长度的任意字符
        4.中括号[]用来转移‘\*’、‘？’、‘['、’]‘这四个特殊字符，一次转义一个字符
        5.其他字符保持原有含义
        6.对’.‘号开头的文件夹或者文件名，规则1，2不生效
输入1：“pattern. \*”,"pattern.txt"
输出1：true

输入2：“dir/\*”,"dir/.env"
输出2：false

# 二叉树中的列表

方法一：枚举
枚举二叉树中的每个节点为起点往下的路径是否有与链表相匹配的路径。为了判断是否匹配我们设计一个递归函数 dfs(rt,\textit{head})dfs(rt,head) ，其中 rtrt 表示当前匹配到的二叉树节点，headhead 表示当前匹配到的链表节点，整个函数返回布尔值表示是否有一条该节点往下的路径与 headhead 节点开始的链表匹配，如匹配返回 \textit{true}true，否则返回 \textit{false}false ，一共有四种情况：

链表已经全部匹配完，匹配成功，返回 \textit{true}true

二叉树访问到了空节点，匹配失败，返回 \textit{false}false

当前匹配的二叉树上节点的值与链表节点的值不相等，匹配失败，返回 \textit{false}false

前三种情况都不满足，说明匹配成功了一部分，我们需要继续递归匹配，所以先调用函数 dfs(rt\rightarrow left,head\rightarrow next)dfs(rt→left,head→next) ，其中 rt\rightarrow leftrt→left 表示该节点的左儿子节点， head\rightarrow nexthead→next 表示下一个链表节点，如果返回的结果是 \textit{false}false，说明没有找到相匹配的路径，需要继续在右子树中匹配，继续递归调用函数 dfs(rt\rightarrow right,head\rightarrow next)dfs(rt→right,head→next) 去找是否有相匹配的路径，其中 rt\rightarrow rightrt→right 表示该节点的右儿子节点， head\rightarrow nexthead→next 表示下一个链表节点。

匹配函数确定了，剩下只要枚举即可，从根节点开始，如果当前节点匹配成功就直接返回 \textit{true}true ，否则继续找它的左儿子和右儿子是否满足，也就是代码中的 dfs(root,head) || isSubPath(head,root->left) || isSubPath(head,root->right) ，然后不断的递归调用。

这样枚举所有节点去判断即能找出是否有一条与链表相匹配的路径。



```c
class Solution {
    bool dfs(TreeNode* rt, ListNode* head) {
        // 链表已经全部匹配完，匹配成功
        if (head == NULL) return true;
        // 二叉树访问到了空节点，匹配失败
        if (rt == NULL) return false;
        // 当前匹配的二叉树上节点的值与链表节点的值不相等，匹配失败
        if (rt->val != head->val) return false;
        return dfs(rt->left, head->next) || dfs(rt->right, head->next);
    }
public:
    bool isSubPath(ListNode* head, TreeNode* root) {
        if (root == NULL) return false;
        return dfs(root, head) || isSubPath(head, root->left) || isSubPath(head, root->right);
    }
};
```

![image-20200601160459921](https://i.loli.net/2020/06/01/HI7MFQz4kvUqD82.png)

## 1. Pattern: Sliding window，**滑动窗口类型**

经典题目：

Maximum Sum Subarray of Size K (easy)

Smallest Subarray with a given sum (easy)

Longest Substring with K Distinct Characters (medium)

Fruits into Baskets (medium)

No-repeat Substring (hard)

Longest Substring with Same Letters after Replacement (hard)

Longest Subarray with Ones after Replacement (hard)



## 2. Pattern: two points, **双指针类型**

经典题目：

Pair with Target Sum (easy)

Remove Duplicates (easy)

Squaring a Sorted Array (easy)

Triplet Sum to Zero (medium)

Triplet Sum Close to Target (medium)

Triplets with Smaller Sum (medium)

Subarrays with Product Less than a Target (medium)

Dutch National Flag Problem (medium)



## 3. Pattern: Fast & Slow pointers, **快慢指针类型**

经典题目：

LinkedList Cycle (easy)

Start of LinkedList Cycle (medium)

Happy Number (medium)

Middle of the LinkedList (easy)



## 4. Pattern: Merge Intervals，**区间合并类型**

经典题目：

Merge Intervals (medium)

Insert Interval (medium)

Intervals Intersection (medium)

Conflicting Appointments (medium)



## 5. Pattern: Cyclic Sort，**循环排序**

经典题目：

Cyclic Sort (easy)

Find the Missing Number (easy)

Find all Missing Numbers (easy)

Find the Duplicate Number (easy)

Find all Duplicate Numbers (easy)



## 6. Pattern: In-place Reversal of a LinkedList，**链表翻转**

经典题目：

Reverse a LinkedList (easy)

Reverse a Sub-list (medium)

Reverse every K-element Sub-list (medium)



## 7. Pattern: Tree Breadth First Search，**树上的BFS**

经典题目：

Binary Tree Level Order Traversal (easy)

Reverse Level Order Traversal (easy)

Zigzag Traversal (medium)

Level Averages in a Binary Tree (easy)

Minimum Depth of a Binary Tree (easy)

Level Order Successor (easy)

Connect Level Order Siblings (medium)



## 8. Pattern: Tree Depth First Search，**树上的DFS**

经典题目：

Binary Tree Path Sum (easy)

All Paths for a Sum (medium)

Sum of Path Numbers (medium)

Path With Given Sequence (medium)

Count Paths for a Sum (medium)



## 9. Pattern: Two Heaps，**双堆类型**

经典题目：

Find the Median of a Number Stream (medium)

Sliding Window Median (hard)

Maximize Capital (hard)



## 10. Pattern: Subsets，**子集类型，一般都是使用多重DFS**

经典题目：

Subsets (easy)

Subsets With Duplicates (easy)

Permutations (medium)

String Permutations by changing case (medium)

Balanced Parentheses (hard)

Unique Generalized Abbreviations (hard)



## 11. Pattern: Modified Binary Search，**改造过的二分**

经典题目：

Order-agnostic Binary Search (easy)

Ceiling of a Number (medium)

Next Letter (medium)

Number Range (medium)

Search in a Sorted Infinite Array (medium)

Minimum Difference Element (medium)

Bitonic Array Maximum (easy)



## 12. Pattern: Top ‘K’ Elements，**前K个系列**

经典题目：

Top ‘K’ Numbers (easy)

Kth Smallest Number (easy)

‘K’ Closest Points to the Origin (easy)

Connect Ropes (easy)

Top ‘K’ Frequent Numbers (medium)

Frequency Sort (medium)

Kth Largest Number in a Stream (medium)

‘K’ Closest Numbers (medium)

Maximum Distinct Elements (medium)

Sum of Elements (medium)

Rearrange String (hard)



## 13. Pattern: K-way merge，**多路归并**

经典题目：

Merge K Sorted Lists (medium)

Kth Smallest Number in M Sorted Lists (Medium)

Kth Smallest Number in a Sorted Matrix (Hard)

Smallest Number Range (Hard)



## 14. Pattern: 0/1 Knapsack (Dynamic Programming)，**0/1背包类型**

经典题目：

0/1 Knapsack (medium)

Equal Subset Sum Partition (medium)

Subset Sum (medium)

Minimum Subset Sum Difference (hard)



## 15. Pattern: Topological Sort (Graph)，**拓扑排序类型**

经典题目：

Topological Sort (medium)

Tasks Scheduling (medium)

Tasks Scheduling Order (medium)

All Tasks Scheduling Orders (hard)

Alien Dictionary (hard)





### 0604

今天和7楼另外一个去阿里的学长交流了一下，他拿了阿里腾讯的sp，华为的ssp

> 1、Linux多线程编程 muduo库 10元（已出）
> 2、Unix环境高级编程 10元（已出）
> 3、Unnix网络编程 卷一+卷二 两本一共15元
> 4、C++ Primer 15元（已出）
> 5、Tcp/Ip详解 + Tcp/Ip网际互联 两本一共12元（已出）
>
> 这几本书研一研二就应该看完
>
> 程序员自我修养 Effective C++ + more effective C++ 两本 这几本书应该在找工作前看三遍以上，剑指offer 也是，面试时这些C++ 的基础并不会问的很深，但是这几本书会问的很深

