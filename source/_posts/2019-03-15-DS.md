---
title:  "数据结构"
date:   2019-03-15 10:06:18 +0800
categories:
- Data_Structure
tags:
- Data_Structure
---

本文主要关于数据结构（java），数据结构是指数据存储的组织方式。大致上分为线性表、栈（Stack）、队列、树（tree）、图（Map）。

<!--more-->









## 二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```java
public class BinaryTree<T> {

    private Node<T> root;

    public BinaryTree() {
        root = null;
    }

    public BinaryTree(Node root) {
        this.root = root;
    }

    public void inOrder() {
        inOrder(root);
    }

    public void preOrder() {
        preOrder(root);
    }

    public void postOrder() {
        postOrder(root);
    }

    private void preOrder(Node node) {
        if (node == null) {
            return;
        }
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }

    private void inOrder(Node node) {
        if (node == null) {
            return;
        }
        inOrder(node.left);
        System.out.print(node.data + " ");
        inOrder(node.right);
    }

    private void postOrder(Node node) {
        if (node == null) {
            return;
        }
        postOrder(node.left);
        postOrder(node.right);
        System.out.print(node.data + " ");
    }

    // 节点
    static class Node<T> {
        T data;
        Node<T> left;
        Node<T> right;

        Node(T data) {
            this(data, null, null);
        }

        Node(T data, Node<T> left, Node<T> right) {
            this.data = data;
            this.left = left;
            this.right = right;
        }
    }

    public static void main(String[] args) {
        Node<Integer> node1 = new Node(2, new Node(4), new Node(5));
        Node<Integer> node2 = new Node(3, new Node(6), new Node(7));
        Node<Integer> root = new Node(1, node1, node2);
        BinaryTree<Integer> tree = new BinaryTree(root);
        tree.inOrder();
        System.out.println();
        tree.preOrder();
        System.out.println();
        tree.postOrder();
    }
}
```

## 冒泡排序

冒泡排序是由两个for循环构成，第一个for循环的变量 i 表示总共需要多少轮比较，第二个for循环的变量 j 表示每轮参与比较的元素下标【0,1，......，length-i】，因为每轮比较都会出现一个最大值放在最右边，所以每轮比较后的元素个数都会少一个，这也是为什么 j 的范围是逐渐减小的。



```java
package bublesort;
public class bublesort{
    //遍历显示数组
    public static void display(int[] array){
        for(int i = 0 ; i < array.length ; i++){
            System.out.print(array[i]+" ");
        }
        System.out.println();
    }
	public static int[] sort(int[] array){
		for(int i=1;i<array.length;i++){
			for(int j=0;j<array.length - i;j++){
				if(array[j]>array[j+1]){
					int temp;
					temp = array[j+1];
					array[j+1] = array[j];
					array[j] = temp;					 
				}
			}
			display(array);
		}
		
		return array;	
	}
	public static void main(String[] args) {
		int[] aaa={32,34,12,3,56,4,7};
		 sort(aaa);
		 
	}
}
```



## 求一个字符串中连续出现次数最多的子串

例如字符串“abababc”,最多连续出现的为ab，连续出现三次。要和求一个字符串中的最长重复子串区分开来，还是上面的字符串，那么最长的重复子串为abab。两个题目的解法有些类似，都用到了后缀数组这个数据结构。求一个字符串中连续出现的次数最多的子串，首先生成后缀数组例如上面的字符串为:

```c
abababc
bababc
ababc
babc
abc
bc
c
```

可以看出第一个后缀数组和第三个后缀数组的起始都为ab，第5个后缀数组也为ab。可以看出规律来，一个字符串s，如果第一次出现在后缀数组i的前面，那么如果它重复出现，下一次出现应该在第i+len(s)个后缀数组的前面。

```c
#include <iostream>
#include <cstring>
#include <utility>
#include <string>
#include <vector>
using namespace std;

pair<int, string> fun(const string& str)
{
    vector<string> subs;
    int len = str.size();
    for (int i = 0; i < len; i++)
    {
        subs.push_back(str.substr(i));
    }

    int count = 1;
    int maxCount = 1;
    string sub;

    for (int i = 0; i < len; i++)
    {
        for (int j = i + 1; j < len; j++)
        {
            count = 1;
            if (subs[i].substr(0, j - i) == subs[j].substr(0, j - i))
            {
                ++count;
                //j-i为子串长度
                for (int k = j + j - i; k < len; k += j - i)
                {
                    if (subs[i].substr(0, j - i) == subs[k].substr(0, j - i))
                    {
                        ++count;
                    }
                    else
                    {
                        break;
                    }
                }
                if (count > maxCount)
                {
                    maxCount = count;
                    sub = subs[i].substr(0, j - i);
                }
            }
        }
    }

    return make_pair(maxCount, sub);
}

int main()
{
    string str;
    pair<int, string> rs;
    while (cin>>str)
    {
        rs = fun(str);
        cout<<rs.second<<":"<<rs.first<<endl;
    }

    return 0;
}
```

## 不含有重复字符的 最长子串 

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

![image-20200417085840556](https://i.loli.net/2020/04/17/RDhsTeHlZnBGOAu.png)

```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //s[start,end) 前面包含 后面不包含
        int start(0), end(0), length(0), result(0);
        int sSize = int(s.size());
        while(end < sSize)
        {
            char tempChar = s[end];
            for(int index = start;index < end;index++)
            {//去滑动窗口里面去看看有么有重复的元素
                if(tempChar == s[index])
                {
                    start = index + 1;
                    length=end - start;
                    break;                   
                }
            }
        end++;
        length++;
        result = max(result,length);//有可能后面的窗口越来越小，所以要保留前面的最大值            
        }
    return result;
    }
};
-----------------------------
Hashmap
-----------------------------
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //s[start,end) 前面包含 后面不包含
        int start(0), end(0), length(0), result(0);
        unordered_map<char,int> hash;
        int sSize = s.length();
        while(end < sSize)
        {
            char tempChar = s[end];
            if(hash.find(tempChar) != hash.end() && hash[tempChar] > start)
            {
                    start = hash[tempChar] + 1;
                    length=end - start;                
            }
        hash[tempChar] = end;
        end++;
        length++;
        result = max(result,length);            
        }
    return result;
    }
};
```

## 最长回文子串



# 找出数组中出现奇数次的元素(WeGame)

给定一个含有n个元素的整型数组a，其中只有一个元素出现奇数次，找出这个元素。

因为对于任意一个数k，有k ^ k = 0，k ^ 0 = k，所以将a中所有元素进行异或，那么个数为偶数的元素异或后都变成了0，只留下了个数为奇数的那个元素。

```c
#include <stdio.h>
int FindElementWithOddCount(int* a, int n)
{
	int r = a[0];
	for (int i = 1; i < n; ++i)
	{
		r ^= a[i];
	}
	return r;
}
int main()
{
	int array[] = { 1, 2, 2, 3, 3, 4, 1 };
	int len = sizeof(array) / sizeof(array[0]);
	printf("%d\n", FindElementWithOddCount(array, len));
	getchar();
	return 0;
}
```

## 从数组里面找出K大的数