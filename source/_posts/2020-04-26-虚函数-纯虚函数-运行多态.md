---
title: 虚函数/纯虚函数/运行多态
tags:
  - C++
  - VTBL
  - VPTR
categories:
  - C++
date: 2020-04-26 18:47:27
---

这篇文章记述了关于虚函数/纯虚函数的知识点。

<!--more-->



# C++类对象内存分布

http://nightn.com/2018/08/05/cpp-object-memory-1/

- **虚表的 -1 位置**。细心的读者可能会发现，虚表第一个虚函数的上面还有一个地址，它其实指向的是这个类的 `type_info` 对象，`type_info` 对象描述了类的简要信息（如 name, hash_code 等），用以支持 `RTTI(runtime type identification)` 。我们使用的 `typeid` 运算符，应该就是通过访问 `type_info` 对象实现的。
- **虚表是类层面上的，而不是对象层面上的**。即同一个类的不同对象，共享同一个虚表。

先选择左侧的C/C++->命令行，然后在其他选项这里写上/d1 reportAllClassLayout，它可以看到所有相关类的内存布局，如果写上/d1 reportSingleClassLayoutXXX（XXX为类名），则只会打出指定类XXX的内存布局。

![image-20200408220704507](https://i.loli.net/2020/04/08/EUFLn3IeTGxRVC1.png)

下面可以定义一个类，像下面这样：



```cpp
class Base
{
	int a;
	int b;
public:
	void CommonFunction();
};
```

然后编译一下，可以看到输出框里面有这样的排布：

```c
class Base Size（8）：
	+---
0  | a
4  | b
	+---
```

再看下继承：



```cpp
class Base
{
	int a;
	int b;
public:
	void CommonFunction();
};
class DerivedClass : public Base
{
	int c;
public:
	void DerivedCommonFunction();
};
```

编译，然后看到如下的内存分布（父类的内存分布不变，这里只讨论子类成员变量的内存分布）：

![image-20200408230007485](https://i.loli.net/2020/04/08/9ndhA5vNu2Y3Z4b.png)

可以看到子类继承了父类的成员变量，在内存排布上，先是排布了父类的成员变量，接着排布子类的成员变量，同样，成员函数不占字节。(创建对象不会为成员函数分配空间。成员函数放在代码区，多个对象共享。函数本身是用来操作数据的，函数本身并不占用内存，只有再运行时才占用一点堆栈空间和寄存器空间~)

下面给基类加上虚函数，暂时注释掉DerivedClass，看一下这时的内存排布：

![image-20200408221832508](https://i.loli.net/2020/04/08/sdKoWFVOIyLJeNf.png)

这个内存结构图分成了两个部分，上面是内存分布，下面是虚表，我们逐个看。VS所带编译器是把虚表指针放在了内存的开始处（0地址偏移），然后再是成员变量；下面生成了虚表，紧跟在&Base1_meta后面的0表示，这张虚表对应的虚指针在内存中的分布，下面列出了虚函数，左侧的0是这个虚函数的序号，这里只有一个虚函数，所以只有一项，如果有多个虚函数，会有序号为1，为2的虚函数列出来。

编译器是在构造函数中创建这个虚表指针以及虚表的。

**那么编译器是如何利用虚表指针与虚表来实现多态的呢**？

是这样的，当创建一个含有虚函数的父类的对象时，编译器在对象构造时将虚表指针指向父类的虚函数表；

同样，当创建子类的对象时，编译器在构造函数里将虚表指针指向子类的虚表（这个虚表里面的虚函数入口地址是子类的）。

所以，如果是调用Base * p = new Derived();生成的是子类的对象，

在构造时，子类对象的虚指针指向的是子类的虚表，

接着由Derived * 到Base*的转换并没有改变虚表指针，

所以这时候p->VirtualFunction，实际上是p->vfptr->VirtualFunction，

它在构造的时候就已经指向了子类的VirtualFunction，

所以调用的是子类的虚函数，这就是多态了。

```cpp
class Base
{
	int a;
	int b;
public:
	void CommonFunction();
	void virtual VirtualFunction();
}
```

下面加上子类，并在子类中添加虚函数，像下面这样：



```cpp
class Base
{
	int a;
	int b;
public:
	void CommonFunction();
	void virtual VirtualFunction();
};
class DerivedClass : public Base
{
	int c;
public:
	void DerivedCommonFunction();
	void virtual VirtualFunction();
};
```

可以看到子类内存的排布如下：

![image-20200408223716252](https://i.loli.net/2020/04/08/1w8OVhK3Zt7uXMj.png)

上半部是子类的内存分布，可以看到，虚表指针被继承了，且仍位于内存排布的起始处，下面是父类的成员变量a和b，最后是子类的成员变量c，注意虚表指针只有一个，子类并没有再生成虚表指针了；下半部的虚表情况与父类是一样的。

我们把子类换个代码，像这样：

```cpp
class DerivedClass1 : public Base
{
	int c;
public:
	void DerivedCommonFunction();
	void virtual VirtualFunction2();
};
```

注意到这时我们并没有覆写父类的虚方法，而是重声明了一个新的子类虚方法，内存分布如下：

![image-20200408223948030](https://i.loli.net/2020/04/08/GwLDUsXnCmYANkZ.png)

还是只有一个虚表指针，但是下方虚表的内容变化了，虚表的0号是父类的VirtualFunction，而1号放的是子类的VirtualFunction2。也就是说，如果定义了DerivedClass的对象，那么在构造时，虚表指针就会指向这个虚表，以后如果调用的是VirtualFunction，那么会从父类中寻找对应的虚函数，如果调用的是VirtualFunction2，那么会从子类中寻找对应的虚函数。

更多关于虚继承、多重继承请参阅https://blog.csdn.net/songshiMVP1/article/details/51253387



## 一般把析构函数写成虚函数是为什么

答：动态绑定时如果基类指针如果指向派生类对象，不是虚函数的话只会调用基类析构，而是虚函数的话就能正确调用派生类的析构

# 虚函数与纯虚函数

![image-20200408092835255](https://i.loli.net/2020/04/08/zArc8lmLiNwWB51.png)



5. 子类可**自主选择**是否要提供一份属于自己的个性化虚函数实现。
6. 子类**必须提供**一份属于自己的个性化纯虚函数实现。



![B33DC6CEA3480F8E912BDF9B93AAC158](https://i.loli.net/2020/04/08/7bUA4gKm98EFpYq.png)

C++的编译器一旦发现一个类型中有虚函数，会为该类型生成虚函数表（vtbl），并在该类型的每一个实例中添加一个指向虚函数表的指针（vptr）。

通常，编译器处理虚函数的方法是：
　　给每个对象添加一个隐藏成员；隐藏成员中保存了一个指向函数地址数组的指针。
　　其实这里的函数地址数组指的就是虚函数表（virtual function table),vtbl。
　　虚函数表中存储了为类对象进行声明的虚函数的地址。

　　例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。
　　如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址，如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。
　　如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中，注意，无论类中包含的虚函数是一个还是多个，都只需要在对象中添加一个地址成员，只是表的大小不同。

------------------------------------------------

1. 每个对象都将增大，增大量为存储地址的空间
2. 对每个类，编译器都创建一个虚函数的地址表
3. 每个函数调用都需要执行一步额外的操作，即到表中查找地址

### 析构函数必须为虚函数

如果不是虚函数，则使用时可能存在内在泄漏的问题。

如果我们以下面这种方式创建对象，不管析构函数是否是虚函数，delete时基类和子类都会被释放。

```C++
SubClass* pObj = new SubClass();
delete pObj;
```

```c++
BaseClass* pObj = new SubClass();
delete pObj;
```

- 若析构函数是虚函数，delete时基类和子类都会被释放；
- 若析构函数不是虚函数，delete时只释放基类，不释放子类；

怪不得在调试的时候明明我没写虚函数，但是还是会有一个vptr，原来是析构函数的呀

## 虚函数

定义一个函数为虚函数，不代表函数为不被实现的函数。
定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

>这里补充一下抽象类和接口的异同：
>
>抽象类（abstract）是只能继承一次，接口却可以实现多个；
>
>接口是个集合，并不是类，类描述了属性和方法，而接口只包含方法（未实现的方法）;
>
>接口和抽象类一样不能被实例化，因为不是类;
>
>但是接口可以被实现（使用 implements 关键字）。
>
>实现某个接口的类必须在类中实现该接口的全部方法。
>
>
>
>抽象类虽然不能实例化来使用，但是可以被继承，让子类来具体实现父类的所有抽象方法。有点像老子没完成的梦想交给儿子来完成，但是如果子类将抽象方法没有全部实现，就必须把自己也修饰成抽象类，交于继承它的子类来完成实现。就相当于，儿子能力不够也没完成老爹的梦想，现在儿子等着再生儿子（被继承），然后让孙子去完成。以此类推，直到没有抽象函数。
>
>接口的实现，通过implements关键字。实现该接口的类，必须把接口中的所有方法给实现。不能再推给下一代。和抽象类相比，抽象类是将梦想传给家族，一代一代去完成。那么接口就是掌门人找大师兄来完成帮派的鸿星伟业，这时候就只有一次希望，要么有能力就实现，没能力就不要接。
>
>
>
>作者：IT废柴
>链接：https://www.jianshu.com/p/038f0b356e9a
>来源：简书
>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 纯虚函数

虚函数的声明以`=0`结束，便可将它声明为纯虚函数。包含纯虚函数的类不允许实例化，称为**抽象类**。 事实上纯虚函数提供了面向对象中接口的功能。当然，这样的接口是以继承的方式实现的。

纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”



虚函数的意义，就在于定义了一个从最早的父类，到最后的子类，都必须具备的一个功能（函数），只是在不断的进化（继承）中，这个功能会略微发生改变。通过虚函数，我们在调用不同的衍生类的时候，可以拥有不同的功能。然后我会说：这么麻烦，干脆每个继承类都重写命名一个函数么算了，只要知道重命名的函数有这个功能就行了不是？理论上来说，完全可以，在一个父类和其继承类不多的项目中，这么做完全可以，只要你自己能熟记或者找到这个重命名函数是干嘛用的；但是在大一点的项目中，由于类中的函数成百上千，恐怕你就会为此疯狂。另外还有一点，是重命名函数无法做到的，这一点我会在纯虚函数中一并解释。

纯虚函数，就是虚函数了以后，末尾还要加=0的那一类函数。我一直没想通的是，既然这个函数完全没有实现方法，那么定义这个函数有个蛋用啊？我也曾经试着在网上搜索过纯虚函数的意义和作用，回答大多千篇一律照本宣科。于是我渐渐的也就无视这个纯虚函数了。直到现在我开始写一个PSO算法的时候，才发现天哪这居然是一个完全不可或缺的东西！如果说虚函数还可以用重命名作为另外一种解决方法，那么纯虚函数则是没有第二种可以替代的方法。我可以拿一个非常简单的代码说明一下：

```c++
class test{ 
public:
	virtual void print();
   virtual void order()=0; 
   int array[20]; 
 };
```

上面声明了一个非常简单的类，它只有两个函数，其中一个是虚函数：打印，另外一个是纯虚函数：排序。其中打印函数的定义如下:

```c++
void test::print(){ 
order();
printf('打印结果： '); 
for(int i=0; i<20; i++) 
	printf('%d ', array);
 }
```

在这个打印函数中，调用了order函数对array进行了排序，然后输出结果。问题是：我根本不知道order函数是什么算法，或者说order函数因人而异，所以无法确定！于是网上照本宣科的内容就出来：当函数没有实现方法或者需要子类来定义实现方法的时候，可以在父类中定义纯虚函数。就是这么简单！于是当不同的子类继承这个父类的时候，定义不同的实现方法，那么实例化这个子类的时候，这个纯虚函数就有了不同的方法。这也解释了为什么包含纯虚函数的抽象类为什么不能实例化，因为它中间有函数根本不知道是怎么个实现！当然我们可以用其他方法避免使用纯虚函数，比方说在子类中重写print方法，但是这样一来等于除了order函数代码以外所有的代码都要重新复制一遍，当继承类越来越多的时候，要修改print等于这一堆继承类都要修改，会疯的！所以说纯虚函数是一个很神奇的用法，也是简化了编程使得面向对象的方法更加灵活。

至于接口，这是一个只有JAVA中才用到的概念，C++中不存在接口，与接口相似的是：抽象类。因为JAVA不允许多重继承类，但可以继承多个接口。关于接口，在我编写JAVA SERVLET的时候，碰到过一个httpservlet，用户需要为doget和dopost等函数编写实现方法。而这些函数就可以看成是纯虚函数，它在HTTPservlet也类似于上述代码的order函数，有着在局部函数中的作用。

面向对象编程确实很有意思，虽然从某种程度上来说，和面向过程也差不多，但是灵活多变的设计方法，也许也是C++（面向对象）比C（面向过程）强大的地方.

## 虚函数总结0409

基类如果有函数前面加了virtual，那么构造器会为每个基类的实例增加一个隐藏的虚函数表指针，指向一张虚函数表，虚函数表记录着基类的虚函数信息。当派生类继承基类的时候，也会把基类的虚函数表指针继承下来，就不生成新的指针了。该指针就指向派生类自己的虚函数表，如果派生类选择重写基类的虚函数，那么就会在自己的虚函数表里新增一个自己的虚函数记录！如果选择不重写，那么派生类也会有一个指向基类虚函数的指针！
当我们new一个派生类对象并且把它的引用赋值给基类引用时，它的虚函数表指针指向的还是自己的虚函数，所以就可以实现通过基类的引用或指针来调用派生类的方法从而实现运行时多态了……
由于函数只是对数据的加工，编译的时候会放到代码段，所以内存模型里不会出现函数……