---
title: static
tags:
  - null
categories:
  - null
date: 2020-06-09 20:54:38
---

这篇文章记述了关于XXX的知识点。

<!--more-->



## 类中的静态变量

由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量**由对象共享。**对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。

```c
// variables inside a class 

#include<iostream> 
using namespace std; 

class Apple 
{ 
    public: 
        static int i; 

        Apple() 
        { 
            // Do nothing 
        }; 
}; 

int main() 
{ 
    Apple obj1; 
    Apple obj2; 
    obj1.i =2; 
    obj2.i = 3; 

    // prints value of i 
    cout << obj1.i<<" "<<obj2.i; 
} 
--------------------
/tmp/cc6TTR48.o: In function `main':
/home/acewzj/CPlusPlusThings/basic_content/static/static_error_variable.cpp:21: undefined reference to `Apple::i'
/home/acewzj/CPlusPlusThings/basic_content/static/static_error_variable.cpp:22: undefined reference to `Apple::i'
/home/acewzj/CPlusPlusThings/basic_content/static/static_error_variable.cpp:25: undefined reference to `Apple::i'
/home/acewzj/CPlusPlusThings/basic_content/static/static_error_variable.cpp:25: undefined reference to `Apple::i'
collect2: error: ld returned 1 exit status
终端进程已终止，退出代码: 1  
```

您可以在上面的程序中看到我们已经尝试为多个对象创建静态变量i的多个副本。但这并没有发生。因此，类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化，如下所示：

```c
#include<iostream> 
using namespace std; 

class Apple 
{ 
public: 
    static int i; 

    Apple() 
    { 
        // Do nothing 
    }; 
}; 

int Apple::i = 1; 

int main() 
{ 
    Apple obj; 
    // prints value of i 
    cout << obj.i; 
} 
---------------
    1
```

**静态成员**

## 类对象为静态

就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。

考虑以下程序，其中对象是非静态的。

```c
#include<iostream> 
using namespace std; 

class Apple 
{ 
    int i; 
    public: 
        Apple() 
        { 
            i = 0; 
            cout << "Inside Constructor\n"; 
        } 
        ~Apple() 
        { 
            cout << "Inside Destructor\n"; 
        } 
}; 

int main() 
{ 
    int x = 0; 
    if (x==0) 
    { 
        Apple obj; 
    } 
    cout << "End of main\n"; 
} 
---------------
Inside Constructor
Inside Destructor
End of main
```

在上面的程序中，对象在if块内声明为非静态。因此，变量的范围仅在if块内。因此，当创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用，因为对象的范围仅在声明它的if块内。 如果我们将对象声明为静态，现在让我们看看输出的变化。

```c
#include<iostream> 
using namespace std; 

class Apple 
{ 
    int i; 
    public: 
        Apple() 
        { 
            i = 0; 
            cout << "Inside Constructor\n"; 
        } 
        ~Apple() 
        { 
            cout << "Inside Destructor\n"; 
        } 
}; 

int main() 
{ 
    int x = 0; 
    if (x==0) 
    { 
        static Apple obj; 
    } 
    cout << "End of main\n"; 
} 
--------------
Inside Constructor
End of main
Inside Destructor
```

您可以清楚地看到输出的变化。现在，在main结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期。

## 类中的静态函数

就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和'.'来调用静态成员函数。但建议使用类名和范围解析运算符调用静态成员。

允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。

```c
#include<iostream> 
using namespace std; 

class Apple 
{ 
    public: 
        // static member function 
        static void printMsg() 
        {
            cout<<"Welcome to Apple!"; 
        }
}; 

// main function 
int main() 
{ 
    // invoking a static member function 
    Apple::printMsg(); 
} 
------------------------
Welcome to Apple!
```

# static_cast

当编译器隐式执行类型转换时，大多数的编译器都会给出一个警告：

```
e:\vs 2010 projects\static_cast\static_cast\static_cast.cpp(11): warning C4244: “初始化”: 从“double”转换到“int”，可能丢失数据
```

　　使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的，也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽。