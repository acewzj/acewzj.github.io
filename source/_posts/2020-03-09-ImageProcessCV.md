---
title:  "图像处理与视频分析的笔记"
date:   2020-03-09 10:16:18 +0800
categories:
- C++
tags:
- CV 


---

这篇文章主要记述了图像处理与视频分析的一些笔记。

<!--more-->



![](https://i.loli.net/2020/03/29/LQ1ElHr5utv6wVo.png)

## 卷积

数字图像处理第一课，卷积也叫模板匹配（后者就好理解了）。比如有一张包含人脸的图像，如果你拿一个和它一模一样的模板和它卷积，只有当模板滑动到人脸上的时候产生的响应是最大的。

模板匹配就是在大图中找小图，也就说在一幅图像中寻找另一幅模板图像的位置

![1583803163978](https://i.loli.net/2020/03/29/GemhlwytQV26dCS.png)

整幅图像的响应如下图，越亮的地方响应越大，正是人脸被匹配的地方，

![1583803192621](https://i.loli.net/2020/03/29/Czr5m6Lt3K2xcTE.png)

## 傅里叶级数与变换

傅里叶级数是针对周期性函数分解成正弦与余弦函数加和：其中频谱和相位谱都是离散的（相位谱就是正弦函数从哪个度数开始分解的，也就是相位）

![1583762624300](https://i.loli.net/2020/03/29/Wr6TonlXmSDg8JY.png)

傅里叶变换是针对非周期性函数进行分解，其中利用了欧拉公式的概念，其中频谱和相位谱都是连续的，所以使用了积分

![1583762608395](https://i.loli.net/2020/03/29/xlcsPt5Lr4OKJg3.png)

n**空间是三维的，图像是二维的，因此空间中物体在另一个维度上的关系就必须由梯度来表示。**

> 当然，更重要的意义在于复数运算保留了二维信息。假如我让你计算3+5，虽然你可以轻松的计算出8，但是如果让你分解8你会有无数种分解的方法，3和5原始在各自维度上的信息被覆盖了。
> 但是计算3+5i的话，你依然可以分解出实部和虚部，就像上图那样。基于以上两个理由，用复数来描述电场与磁场简直完美到爆棚！
> 我们即可以让电场强度与复数磁场强度相加而不损失各自的信息，又满足了电场与磁场90度垂直的要求。另外，一旦我们需要让任何一个场旋转90度，只要乘一个“i”就可以了

![](https://i.loli.net/2020/03/29/JYAXVhyWIqENZCK.jpg)

![Fourier_series_square_wave_circles_animation](https://i.loli.net/2020/03/29/jSQH4AFwTLR7EkC.gif)

![](https://i.loli.net/2020/03/29/Jb1NsPBE6MDo4K5.png)

![1583120066486](https://i.loli.net/2020/03/29/1BqD9X5CYzPNEMl.png)

![1583120081343](https://i.loli.net/2020/03/30/5Bzd1ai6f8XreU7.png)

对比度：最高值/最低值亮度

![1583120235702](https://i.loli.net/2020/03/29/Lol5gGtI6pqAYbK.png)

![1583120275933](https://i.loli.net/2020/03/29/dbSviEHRD4U87r5.png)

中值滤波就是取一个窗口排序中间像素的灰度值作为当前像素的灰度值，所以在面对椒盐噪声时由于椒盐噪声就是黑白差异很大的点肯定不会在排序的中间，处理效果较好。

![1583462273037](https://i.loli.net/2020/03/29/Wfl4J6mI358pRNw.png)

![1583462410564](https://i.loli.net/2020/03/29/PkjKEndWhywIGZ6.png)



## 高通滤波

中间比较粗用多圈的滤波器

![1583721403547](https://i.loli.net/2020/03/29/ceTdXmZtYDjFRQK.png)

![1583895066834](https://i.loli.net/2020/03/29/Rjme4ygfMbuYkcD.png)

## 

## 为什么用齐次坐标？

![1583908903979](https://i.loli.net/2020/03/29/keny1zaYUdqwKJ4.png)

用四维矩阵能更好的表示，如果用三维的话x怎么减TX？所以表示起来比较统一

![1583909031048](https://i.loli.net/2020/03/29/GeKl6O1axRkiZT7.png)

![1583910982943](https://i.loli.net/2020/03/30/oj7V2dzcyh6vHZM.png)

## 傅里叶频谱

仔细观察这幅图，频谱就是一幅图片各个频率的条纹？波分解出来的频率-幅值（也有频率-相位）图，只不过是将原点移位到了图像中心。下面这幅图可以看见有明显的横向条纹，你可以把它想象成频率很小的波，为什么很小呢？因为你都肉眼可见了，频率肯定比那些肉眼不可见的条纹频率小了啊。所以在频谱图上的体现就是靠近原点的小范围内的幅值出现了白色的竖直条纹：白色代表值很高 啊。去掉这些竖直白色条纹之后效果好多了吧哈哈~

![1584071227285](https://i.loli.net/2020/03/29/QKo5IV2duZpWfJz.png)

![1584071419230](https://i.loli.net/2020/03/29/WaSvxglpwyZJ6rY.png)



## Cannny边缘检测

边缘检测就是靠边缘像素突变进行检测的。可以利用一阶偏导来检测这个突变。步骤如下：

第一步目的是滤波，如果图像中存在噪声，就会导致一阶导数不平滑，进而导致边缘的误检测。

第二步的目的是求二阶偏导：先求x方向的偏导，再求Y方向的偏导；最后再合成出梯度图，找到梯度方向，把XY方向的两幅图进行叠加会发现边缘有的变胖了，如图中的美女的腿

第三步的目的是让边缘变瘦，你的像素强度肯定是最亮的，直接忽略掉他们选择自己就行了。如果梯度方向上不存在什么临近的邻居点，可以通过插值的方式（灰色的点就是左右黑色像素插值插出来的）来进行找邻居点

第四步的目的是利用延滞性来让粗的边后面紧接着的边不要突然变得那么细，好让他稍微连续一点。

![image-20200318211947596](https://i.loli.net/2020/03/29/5ydvkmcprGHxDK4.png)

![image-20200318212351664](https://i.loli.net/2020/03/29/MfN9ywCEmLQtSzp.png)

![image-20200318212543634](https://i.loli.net/2020/03/29/cyzf4n57aWKNsQD.png)

![image-20200318212404405](https://i.loli.net/2020/03/29/wi8aVJrkDZCSetv.png)

![image-20200318212554994](https://i.loli.net/2020/03/29/k8Zpm3R6ohXE4FY.png)

![1583219058702](https://i.loli.net/2020/03/29/EWbTVU72Z9tdwpv.png)

## 特征点检测

![image-20200319195331162](https://i.loli.net/2020/03/29/U2WI8HvEXL1Cg4b.png)

## 直方图规定化的实现

直方图均衡化是将原图像的直方图通过变换函数修正为均匀的直方图， 然后按均衡直方图修正原
图像。图像均衡化处理后，图像的直方图是平直的，即各灰度级具有近似相同的出现频数。那么，由于灰度级具有均匀的概率分布，图像看起来就更清晰了。直方图均衡化通常用来增加许多图像的局部对比度，尤其是当图像的有用数据的对比度相当接近的时候。通过这种方法，亮度可以更好地在直方图上分布。这样就可以用于增强局部的对比度而不影响整体的对比度，

![1583635716616](https://i.loli.net/2020/03/29/6Q3IA1DTVdfeOPx.png)

直方图规定化的实现可以分为一下三步：

- 计算原图像的累积直方图
- 计算规定直方图的累积直方图
- 计算两累积直方图的差值的绝对值
- 根据累积直方图差值建立灰度级的映射

![image-20200320095548295](https://i.loli.net/2020/03/29/s4ficKjC35TnHG9.png)

![image-20200320095640085](https://i.loli.net/2020/03/29/bzfmiWqpRI4oevH.png)

![image-20200320095654277](https://i.loli.net/2020/03/29/OasYy1k2oNUXHZP.png)

![image-20200320095708679](https://i.loli.net/2020/03/29/K8spTLgZ9VPaS1Y.png)

## 直方图均衡化

BINS
BINS：上面的直方图显示了每个像素值的像素数，从0到255。您需要256个值来显示以上的直方图。但是，考虑一下，如果您不需要单独查找所有像素值的像素数量，而是在一个像素值区间内的像素数量，该怎么办？例如，你需要找到介于0到15之间的像素数，然后是16到31……240到255。您只需要16个值来表示这个直方图。OpenCV Tutorials on histograms中展示了这个例子。

所以你要做的就是把整个直方图分成16个子部分，每个子部分的值是所有像素数的和。每个子部分都被称为“BIN”。在第一种情况下，BINS的数量是256(每个像素一个)，而在第二种情况下，它只有16个。在OpenCV文档中，用术语 histSize 表示 BINS

#### DIMS

DIMS：它是我们收集数据的参数的个数。在这种情况下，我们收集的数据只有一件事，强度值。所以这里是1。

#### RANGE

RANGE：它是你想测量的强度值的范围。通常，它是 [ 0，256 ]，也就是所有的强度值。

![image-20200320102057476](https://i.loli.net/2020/03/30/UtedMlqc7QNEKrR.png)

# 关于命名空间

命名空间是可以不断进行扩充的，并不是一次就定义好命名空间里所有的东西。

尽量少的使用Using namespace std;等全局的引入，因为这样的引入多了之后，还是会产生命名污染。最好是你用哪里的变量，在前面写上命名空间。

`error C2872: ACCESS_MASK: 不明确的符号。`
有点懵，来不及懵。

当一个函数没有在编译头文件中找到定义时，一般就会报错：未标识的符号。
至于报错不明确的符号，那可能是因为，工程的编译文件里有多个该符号定义。
笔者没那么聪明，是在前辈基础经验上总结的。
opencv3.0的cv “ACCESS_MASK”冲突

不想打开链接可以直接看原文截图：


瞧见没？是因为winnt.h里边定义了cv，它的cv空间里有一个符号叫ACCESS_MASK；
opencv函数里边也定义了命名空间cv，它的cv空间里也有一个符号叫ACCESS_MASK。
那么我的项目如果同时包含这两个头文件，计算机是否知道我要调用哪个ACCESS_MASK吗？

回想平时写代码习惯性的：

using namespace std;
using namespace cv;
1
2
因为opencv里边很多函数，诸如imread，imshow，waitkey，Rect，Point，在使用频率上比较高，每次把它所在的命名空间书写有点麻烦，所以就习惯性的一次性了。
可惜懒人没懒福，这样的报错遇到过很多次，一直在回避。
改完这六百多个报错，以后还是一次性写清楚吧，不要给自己留隐患了。

# 关于OPENCV

通过观察opencv的源代码我们发现了一些很有意思的事情：

- 形参采用了const：const可以保证该形参不会被缺心眼的程序员在接下来给修改了，毕竟你像原始图片这样的非常重要的形参如果被修改一下，后面都白做了，相当于一个保险措施吧。
- 传照片过来时，是一个mat类型的指针：
- 函数内部局部变量命名很有特点，以下划线开头：就是为了避免命名冲突

## 关于VS调试Opencv源码无法进行单步调试的解决办法

右键项目属性--链接--输入--外部依赖项--将opencv_world340d.lib放在最下面，因为你如果把他放在最上面的话，它里面就包含了opencv所有的符号表，其他静态库就不用加载了，自然也加载不了pdb文件调试了。

开启源服务器支持，将CMake好后生成的bin目录添加到相应目录下。

# C++中const的作用

**1. const可以定义常量**。const定义的常量编译器可以对其进行静态数据类型安全检查。

**2. const修饰函数形式参数**。当输入参数为用户自定义类型和抽象数据类型时，应该将值传递改为"cosnt & 传递"，可以提高效率。比如：

```c
void fun(A a);
void fun(A const &a);
```

第一个效率低，因为函数体内产生A类型的临时对象用于复制参数a，临时对象的构造、复制、析构过程都将消耗时间。第二个是引用传递，不需要产生临时对象，节省了临时对象的构造、复制、西沟过程消耗的时间。但是只用引用有可能改变a，因此加const。

## CV_DbAssert

OpenCV中经常会碰见CV_DbAssert，来谈一谈opencv中Mat类的CV_DbAssert

```c++
_Tp& Mat::at(int i0, int i1)
{
//1.如果维度越界
CV_DbgAssert(dims <= 2);
//2.如果数据为空
CV_DbgAssert(data);
//3.如果i0越界
CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
//4.如果i1越界
CV_DbgAssert((unsigned)(i1 * DataType<_Tp>::channels) < (unsigned)(size.p[1] * channels()));
//5.elemSize1为Mat中一个通道中一个元素的所占内存大小的值。
CV_DbgAssert(CV_ELEM_SIZE1(traits::Depth<_Tp>::value) == elemSize1());
//6.返回该点对应的值
return ((_Tp*)(data + step.p[0] * i0))[i1];
}
```

首先，这个断言官方的解释是只在调试阶段运行，在发布版本不运行，但是很有可能会引起程序的崩溃。
主要的目的就是防止越界。

首先，这个断言官方的解释是只在调试阶段运行，在发布版本不运行，但是很有可能会引起程序的崩溃。
主要的目的就是防止越界。

## 在VS2017中实现OpenCV源码级调试

0.需要把`opencv`的源码路径加上，在`配置属性->vc++目录->源目录`，`C:\Program Files\opencv\sources\modules`

1.`cmake`编译`opencv`源码，如果是`OpenCV3.0`以上版本可以勾选`Build OpenCV_World`选项，这样可以使得编译的最终结果是一个总的`dll`等文件，省的一个一个`dll`文件添加了。然后打开`opencv.sln`，`Debug`，`release`下都`build`一遍。这时会出现`bin`文件，`lib`文件，以及`install`文件：`bin文件`你会发现有了`dll`，还有`pdb`文件，一一对应，`lib`文件同样也多了`exp`文件；
而install文件你会发现和一键安装opencv时生成的文件一样， 有lib include bin；

2.打开`工具->选项->调试->符号`，在`Microsoft`符号服务器下右上角有个添加，我输入`opencv_world340d.pdb`，然后运行，看输出窗口还是提示说 无法查找或打开 `PDB `文件，，又发现右上角是文件夹的新建,接着把debug的pdb路径输入，在运行程序加断点，完美，输出窗口 

3.在opencv自带函数处加断点，F11，哇，cvLoadImage(), 调到opencv的src文件内的`d:\opencv340\opencv\sources\modules\highgui\src\loadsave.cpp`，可以看到`oepncv`自带函数的实现了，点云库`PCL`想看源码，也一样

- debug下，F11单步执行才可以进入opencv源码的cpp.

> 之前怎么也不成功是因为生成的Opencv_world340d.dll不对，正经生成出来的是150M

![image-20191219213007592](https://i.loli.net/2020/03/29/1LGB6ygPmpOlSKs.png)

## OpencvCmake

- 如果根据上面设置之后，编译还会有同样的错误，可以直接注释发生错误的地方。 经过一番搜索之后，发现是因为vtk8.10之后的版本中将vtkMapper的ImmediateModeRenderingOff()方法移除了，所以为了让pcl1.9.1代码编译通过，只需要将错误提示中对应的那一行代码注释掉即可，或者更换为更低版本的vtk也行。我是通过注释掉上述出错的两行代码，因为ImmediateModeRenderingOff()方法不是必须的操作，最后通过了编译。
- libConfig++，注意生成的要是64位的Lib&DLL
- boost连接