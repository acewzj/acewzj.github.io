---
title:  "图像处理与视频分析的笔记"
date:   2020-03-09 10:16:18 +0800
categories:
- C++
tags:
- CV 


---

这篇文章主要记述了图像处理与视频分析的一些笔记。

<!--more-->



![](https://i.loli.net/2020/03/29/LQ1ElHr5utv6wVo.png)

## 卷积

数字图像处理第一课，卷积也叫模板匹配（后者就好理解了）。比如有一张包含人脸的图像，如果你拿一个和它一模一样的模板和它卷积，只有当模板滑动到人脸上的时候产生的响应是最大的。

模板匹配就是在大图中找小图，也就说在一幅图像中寻找另一幅模板图像的位置

![1583803163978](https://i.loli.net/2020/03/29/GemhlwytQV26dCS.png)

整幅图像的响应如下图，越亮的地方响应越大，正是人脸被匹配的地方，

![1583803192621](https://i.loli.net/2020/03/29/Czr5m6Lt3K2xcTE.png)

## 傅里叶级数与变换

傅里叶级数是针对周期性函数分解成正弦与余弦函数加和：其中频谱和相位谱都是离散的（相位谱就是正弦函数从哪个度数开始分解的，也就是相位）

![1583762624300](https://i.loli.net/2020/03/29/Wr6TonlXmSDg8JY.png)

傅里叶变换是针对非周期性函数进行分解，其中利用了欧拉公式的概念，其中频谱和相位谱都是连续的，所以使用了积分

![1583762608395](https://i.loli.net/2020/03/29/xlcsPt5Lr4OKJg3.png)

n**空间是三维的，图像是二维的，因此空间中物体在另一个维度上的关系就必须由梯度来表示。**

> 当然，更重要的意义在于复数运算保留了二维信息。假如我让你计算3+5，虽然你可以轻松的计算出8，但是如果让你分解8你会有无数种分解的方法，3和5原始在各自维度上的信息被覆盖了。
> 但是计算3+5i的话，你依然可以分解出实部和虚部，就像上图那样。基于以上两个理由，用复数来描述电场与磁场简直完美到爆棚！
> 我们即可以让电场强度与复数磁场强度相加而不损失各自的信息，又满足了电场与磁场90度垂直的要求。另外，一旦我们需要让任何一个场旋转90度，只要乘一个“i”就可以了

![](https://i.loli.net/2020/03/29/JYAXVhyWIqENZCK.jpg)

![Fourier_series_square_wave_circles_animation](https://i.loli.net/2020/03/29/jSQH4AFwTLR7EkC.gif)

![](https://i.loli.net/2020/03/29/Jb1NsPBE6MDo4K5.png)

![1583120066486](https://i.loli.net/2020/03/29/1BqD9X5CYzPNEMl.png)

![1583120081343](https://i.loli.net/2020/03/30/5Bzd1ai6f8XreU7.png)

对比度：最高值/最低值亮度

![1583120235702](https://i.loli.net/2020/03/29/Lol5gGtI6pqAYbK.png)

![1583120275933](https://i.loli.net/2020/03/29/dbSviEHRD4U87r5.png)

中值滤波就是取一个窗口排序中间像素的灰度值作为当前像素的灰度值，所以在面对椒盐噪声时由于椒盐噪声就是黑白差异很大的点肯定不会在排序的中间，处理效果较好。

![1583462273037](https://i.loli.net/2020/03/29/Wfl4J6mI358pRNw.png)

![1583462410564](https://i.loli.net/2020/03/29/PkjKEndWhywIGZ6.png)



## 高通滤波

中间比较粗用多圈的滤波器

![1583721403547](https://i.loli.net/2020/03/29/ceTdXmZtYDjFRQK.png)

世界坐标系很好理解：就是物体在三维世界中的位置坐标系；

相机坐标系呢？我的理解是你的相机可以左右摇晃，从而决定哪些物体出现在取景框里，这些出现在取景框里的物体可以看成是在相机所处的一个坐标系里。你忘了图形学老师演示的Maya：之所以在模型的内部设立一个坐标系就是为了方便表示的，省却了相对偏移的烦恼。

图像坐标系很好理解：就是CMOS感光芯片的坐标系，注意起始点

像平面坐标系：

下面这幅图有针孔成像

## ![image-20200414104118313](../../../../../../../windows/system32/upload/image-20200414104118313.png)

## 为什么用齐次坐标？

![1583908903979](https://i.loli.net/2020/03/29/keny1zaYUdqwKJ4.png)

用四维矩阵能更好的表示，如果用三维的话x怎么减TX？所以表示起来比较统一

![1583909031048](https://i.loli.net/2020/03/29/GeKl6O1axRkiZT7.png)

![1583910982943](https://i.loli.net/2020/03/30/oj7V2dzcyh6vHZM.png)

## 傅里叶频谱

仔细观察这幅图，频谱就是一幅图片各个频率的条纹？波分解出来的频率-幅值（也有频率-相位）图，只不过是将原点移位到了图像中心。下面这幅图可以看见有明显的横向条纹，你可以把它想象成频率很小的波，为什么很小呢？因为你都肉眼可见了，频率肯定比那些肉眼不可见的条纹频率小了啊。所以在频谱图上的体现就是靠近原点的小范围内的幅值出现了白色的竖直条纹：白色代表值很高 啊。去掉这些竖直白色条纹之后效果好多了吧哈哈~

![1584071227285](https://i.loli.net/2020/03/29/QKo5IV2duZpWfJz.png)

![1584071419230](https://i.loli.net/2020/03/29/WaSvxglpwyZJ6rY.png)



## Cannny边缘检测

边缘检测就是靠边缘像素突变进行检测的。可以利用一阶偏导来检测这个突变。步骤如下：

第一步目的是滤波，如果图像中存在噪声，就会导致一阶导数不平滑，进而导致边缘的误检测。

第二步的目的是求二阶偏导：先求x方向的偏导，再求Y方向的偏导；最后再合成出梯度图，找到梯度方向，把XY方向的两幅图进行叠加会发现边缘有的变胖了，如图中的美女的腿

第三步的目的是让边缘变瘦，你的像素强度肯定是最亮的，直接忽略掉他们选择自己就行了。如果梯度方向上不存在什么临近的邻居点，可以通过插值的方式（灰色的点就是左右黑色像素插值插出来的）来进行找邻居点

第四步的目的是利用延滞性来让粗的边后面紧接着的边不要突然变得那么细，好让他稍微连续一点。

![image-20200318211947596](https://i.loli.net/2020/03/29/5ydvkmcprGHxDK4.png)

![image-20200318212351664](https://i.loli.net/2020/03/29/MfN9ywCEmLQtSzp.png)

![image-20200318212543634](https://i.loli.net/2020/03/29/cyzf4n57aWKNsQD.png)

![image-20200318212404405](https://i.loli.net/2020/03/29/wi8aVJrkDZCSetv.png)

![image-20200318212554994](https://i.loli.net/2020/03/29/k8Zpm3R6ohXE4FY.png)

![1583219058702](https://i.loli.net/2020/03/29/EWbTVU72Z9tdwpv.png)

## 特征点检测

![image-20200319195331162](https://i.loli.net/2020/03/29/U2WI8HvEXL1Cg4b.png)

## 直方图规定化的实现

直方图均衡化是将原图像的直方图通过变换函数修正为均匀的直方图， 然后按均衡直方图修正原
图像。图像均衡化处理后，图像的直方图是平直的，即各灰度级具有近似相同的出现频数。那么，由于灰度级具有均匀的概率分布，图像看起来就更清晰了。直方图均衡化通常用来增加许多图像的局部对比度，尤其是当图像的有用数据的对比度相当接近的时候。通过这种方法，亮度可以更好地在直方图上分布。这样就可以用于增强局部的对比度而不影响整体的对比度，

![1583635716616](https://i.loli.net/2020/03/29/6Q3IA1DTVdfeOPx.png)

直方图规定化的实现可以分为一下三步：

- 计算原图像的累积直方图
- 计算规定直方图的累积直方图
- 计算两累积直方图的差值的绝对值
- 根据累积直方图差值建立灰度级的映射

![image-20200320095548295](https://i.loli.net/2020/03/29/s4ficKjC35TnHG9.png)

![image-20200320095640085](https://i.loli.net/2020/03/29/bzfmiWqpRI4oevH.png)

![image-20200320095654277](https://i.loli.net/2020/03/29/OasYy1k2oNUXHZP.png)

![image-20200320095708679](https://i.loli.net/2020/03/29/K8spTLgZ9VPaS1Y.png)

## 直方图均衡化

BINS
BINS：上面的直方图显示了每个像素值的像素数，从0到255。您需要256个值来显示以上的直方图。但是，考虑一下，如果您不需要单独查找所有像素值的像素数量，而是在一个像素值区间内的像素数量，该怎么办？例如，你需要找到介于0到15之间的像素数，然后是16到31……240到255。您只需要16个值来表示这个直方图。OpenCV Tutorials on histograms中展示了这个例子。

所以你要做的就是把整个直方图分成16个子部分，每个子部分的值是所有像素数的和。每个子部分都被称为“BIN”。在第一种情况下，BINS的数量是256(每个像素一个)，而在第二种情况下，它只有16个。在OpenCV文档中，用术语 histSize 表示 BINS

#### DIMS

DIMS：它是我们收集数据的参数的个数。在这种情况下，我们收集的数据只有一件事，强度值。所以这里是1。

#### RANGE

RANGE：它是你想测量的强度值的范围。通常，它是 [ 0，256 ]，也就是所有的强度值。

![image-20200320102057476](https://i.loli.net/2020/03/30/UtedMlqc7QNEKrR.png)



## 关于VS调试Opencv源码无法进行单步调试的解决办法

右键项目属性--链接--输入--外部依赖项--将opencv_world340d.lib放在最下面，因为你如果把他放在最上面的话，它里面就包含了opencv所有的符号表，其他静态库就不用加载了，自然也加载不了pdb文件调试了。

开启源服务器支持，将CMake好后生成的bin目录添加到相应目录下。



## CV_DbAssert

OpenCV中经常会碰见CV_DbAssert，来谈一谈opencv中Mat类的CV_DbAssert

```c++
_Tp& Mat::at(int i0, int i1)
{
//1.如果维度越界
CV_DbgAssert(dims <= 2);
//2.如果数据为空
CV_DbgAssert(data);
//3.如果i0越界
CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
//4.如果i1越界
CV_DbgAssert((unsigned)(i1 * DataType<_Tp>::channels) < (unsigned)(size.p[1] * channels()));
//5.elemSize1为Mat中一个通道中一个元素的所占内存大小的值。
CV_DbgAssert(CV_ELEM_SIZE1(traits::Depth<_Tp>::value) == elemSize1());
//6.返回该点对应的值
return ((_Tp*)(data + step.p[0] * i0))[i1];
}
```

首先，这个断言官方的解释是只在调试阶段运行，在发布版本不运行，但是很有可能会引起程序的崩溃。
主要的目的就是防止越界。

首先，这个断言官方的解释是只在调试阶段运行，在发布版本不运行，但是很有可能会引起程序的崩溃。
主要的目的就是防止越界。

## 作业一：低频高频融合

### 1、padding

```python
#在数组A的边缘填充constant_values指定的数值
#（3,2）表示在A的第[0]轴填充（二维数组中，0轴表示行），即在0轴前面填充3行0，后面填充2行0
#（2,3）表示在A的第[1]轴填充（二维数组中，1轴表示列），即在1轴前面填充2列0，后面填充3列0
np.pad(A,((3,2),(2,3)),'constant',constant_values = (0,0))  #constant_values表示填充值，且(before，after)的填充值等于（0,0）

array([[ 0,  0,  0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0,  0,  0],
       [ 0,  0, 95, 96,  0,  0,  0],
       [ 0,  0, 97, 98,  0,  0,  0],
       [ 0,  0,  0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0,  0,  0]])
```

