---
title:  "计算机图形学"
date:   2019-03-06 09:49:18 +0800
categories:
- Other
tags:
- Bresenham
---

本文主要记述了计算机图形学的一些知识点。

<!--more-->





# 1、Bresenham算法

**常见的直线有三种扫描算法：DDA算法，中点画线法，Bresenham算法。下面来看看Bresenham算法。**

过各行各列象素中心构造一组虚拟网格线。按直线从起点到终点的顺序计算直线与各垂直网格线的交点，然后根据误差项的符号确定该列象素中与此交点最近的象素。

![1576647567737](https://i.loli.net/2020/03/30/CLwiaVfpqB2vUOy.png)

[](http://photo.blog.sina.com.cn/showpic.html#blogid=73428e9a01016gnp&url=http://s1.sinaimg.cn/orignal/73428e9a4ca1c662241c0)

**核心思想：**
假设：k=dy/dx。因为直线的起始点在象素中心，所以误差项d的初值d0＝0。
 X下标每增加1，d的值相应递增直线的斜率值k，即d＝d＋k。一旦d≥1，就把它减去1，这样保证d在0、1之间。
 当d≥0.5时，最接近于当前象素的右上方象素（x+1,y+1）
 而当d<0.5时，更接近于右方象素(x+1,y）

为方便计算，令`e＝d-0.5`，
 e的初值为-0.5，增量为k。
 当e≥0时，取当前象素（xi，yi）的右上方象素（x+1,y+1）
 而当e<0时，更接近于右方象素(x+1,y）


可以改用整数以避免除法。由于算法中只用到误差项的符号，因此可作如下替换：
`e1 = 2*e*dx`

**算法代码：**

```c
void Bresenhamline (int x0,int y0,int x1, int y1,int color)
 { 
  int x, y, dx, dy;
  float k, e;
  dx = x1-x0, dy = y1- y0, k=dy/dx;
  e=-0.5, x=x0, y=y0;
  for (i=0; i<=dx; i++)
  {    drawpixel (x, y, color);
  x=x+1，e=e+k;
  if (e>=0)
  { y++, e=e-1;}
  }
 }
 //或者将e扩大2dx倍；



void Bresenhamline (int x0,int y0,int x1, int y1,int color)
 {
 int x, y, dx, dy;
 float k, e;
 dx = x1-x0, dy = y1- y0, k=dy/dx;
 e=-dx, x=x0, y=y0;
 for (i=0; i<=dx; i++)
 { drawpixel (x, y, color);
 x=x+1，e=e+2dy;
 if (e>=0)
 { y++, e=e-2dx;}
 }
```

![1576647586467](https://i.loli.net/2020/03/30/85ejMKYNJOnEBiF.png)



## 2、种子填充算法的递归关系

```c++
void boundaryFill4(int x, int y, Color fillColor, Color boarderColor) {
	Color interiorColor;
	getpixel(x, y, interiorColor);
	if (compareColor(interiorColor, fillColor) == 0 && compareColor(interiorColor, boarderColor) == 0) {
		setpixel(x, y);
		boundaryFill4(x - 1, y, fillColor, boarderColor);
		boundaryFill4(x, y + 1, fillColor, boarderColor);
		boundaryFill4(x + 1, y, fillColor, boarderColor);
		boundaryFill4(x, y - 1, fillColor, boarderColor);
	}

}
```

我原来以为的填充顺序是这样的：

![](https://i.loli.net/2019/12/14/CJPutDZ51m39TBz.png)

结果是这样的：

![](https://i.loli.net/2019/12/14/298AvhzrgjlEBsY.png)

## 点云

利用PCL的IO接口，将数据倒腾到PCD文件（PCD采用binary形式保存，ASCII性能实在太差）

![](https://i.loli.net/2019/12/17/1XTI8fLA4JKcYM3.png)

1. 首先，读取参考点云（reference,target）和目标点云（current,object）数据，在上述代码中分别对应ptCloudRef与ptCloudCurrent；
2. 去除体外孤点（可选，速度较慢）
3. 降采样，上述代码中采用的是网格采样的方法（除此之外，matlab point cloud processing还自带random方法，并且更加推荐使用random）。网格采样大体思路是件点云数据划分为正方体网格，每个网格内输出一个3D数据点，该点的位置则由网格中所有点平均得来。

## 3、超像素（Super Pixel）与亚像素（Sub Pixel）

本来看像素就是一个一个的二维像素点，但是超像素就是将相同的区域分割到了一起

![](https://pic3.zhimg.com/v2-4588a384c16721fa03ed0127ef13a982_r.jpg)

![](https://pic1.zhimg.com/v2-70bf0b56df5e5ba07f9719f15abaf681_r.jpg)

面阵摄像机的成像面以像素为最小单位。例如某[CMOS](https://baike.baidu.com/item/CMOS/428167)摄像芯片，其像素间距为5.2微米。摄像机拍摄时，将物理世界中连续的图像进行了[离散化](https://baike.baidu.com/item/离散化/10501557)处理。到成像面上每一个像素点只代表其附近的颜色。至于“附近”到什么程度？就很困难解释。两个像素之间有5.2微米的距离，在宏观上可以看作是连在一起的。但是在[微观](https://baike.baidu.com/item/微观/4542832)上，它们之间还有无限的更小的东西存在。这个更小的东西我们称它为“亚像素”。实际上“亚像素”应该是存在的，只是硬件上没有个细微的传感器把它检测出来。于是软件上把它近似地计算出来。

[数码摄像机](https://baike.baidu.com/item/数码摄像机/10935797)的成像面的分辨率以像素数量来衡量。隔行TV的分辨率是576x768个像素。 像素中心之间的距离有几个至十几个微米不等。为了最大限度利用图像信息来提高分辨率，有人提出了Sub-Pixel概念。意思是说，在两个物理像素之间还有像素，称之为Sub-Pixel，它完全是通过计算方法得出来的。这里提出计算方法。

如果原始图像是n行m列的，希望做k细分的Sub-Pixel，这样就有新的行N和列M，有

N = k*n

M = k*m

原来相邻4个像素包含的区域变成了(k+1)*(k+1)的区域了；要填满这个(k+1)*(k+1)的区域，实际上就是从一个小正方形映照到一个大正方形的过程。在数学上用双线性插值得算法可以轻松搞定。(二次或者三次[样条曲线](https://baike.baidu.com/item/样条曲线))。



