<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="acewzj C++ Linux TCP/IP" />










<meta name="description" content="acewzj">
<meta property="og:type" content="website">
<meta property="og:title" content="acewzj">
<meta property="og:url" content="http://acewzj.github.io/page/2/index.html">
<meta property="og:site_name" content="acewzj">
<meta property="og:description" content="acewzj">
<meta property="og:locale" content="zh">
<meta property="article:author" content="acewzj">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://acewzj.github.io/page/2/"/>





  <title>acewzj</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">acewzj</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">王忠杰</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acewzj.github.io/2019/12/18/2019-12-20-StereoVision/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="acewzj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acewzj">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/18/2019-12-20-StereoVision/" itemprop="url">Stereo_Vision</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-18T10:16:18+08:00">
                2019-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>这篇文章主要记述了双目立体视觉的一些笔记。</p>
<h2 id="论文摘抄"><a href="#论文摘抄" class="headerlink" title="论文摘抄"></a>论文摘抄</h2><p>立体匹配是计算机视觉中研究最广泛的问题之一。<br>立体匹配算法设计中的两个主要问题是匹配精度和处理效率。<br>尽管每年都会引入许多算法，但是在报告的结果中这两个问题往往是矛盾的：准确的立体方法通常很耗时，而基于GPU的方法实现了较高的处理速度，并且视差相对较低精度]。据我们所知，大多数排名前10的Middlebridge算法至少需要10秒才能处理384×288图像对，排名前20的基于GPU的仅有两种方法是CostFilter [9]和Plane-FitBP 。 两者都具有接近实时的性能。<br>该矛盾背后的原因很简单：准确的立体算法采用的某些关键技术不适合并行GPU实现。对领先的Middlebury算法的仔细分析表明，这些算法在匹配过程中具有几种常用技术：它们使用大的支持窗口进行稳健的成本汇总；他们将视差计算步骤公式化为能量最小化问题，并使用慢速收敛的优化器对其进行求解。</p>
<h2 id="Realistic-CG-Stereo-Image-Dataset-with-Ground-Truth-Disparity-Maps"><a href="#Realistic-CG-Stereo-Image-Dataset-with-Ground-Truth-Disparity-Maps" class="headerlink" title="Realistic CG Stereo Image Dataset with Ground Truth Disparity Maps"></a>Realistic CG Stereo Image Dataset with Ground Truth Disparity Maps</h2><p>双目匹配问题是计算机视觉领域最热门的研究方向之一。随着一系列和双目匹配相关的算法被研究出来，由于可用的真实视差图的立体数据集数量有限，该领域的一些分支的研究受到了限制。拥有一个具有真实视差图的大型立体图像数据集将促进对新的立体匹配方法的研究，例如，基于机器学习的方法。在这项工作中，我们使用高度真实的计算机图形技术开发了一个很大的数据集与真实地图。我们还应用一些最常见的立体匹配技术到我们的数据集，以确认我们的高度逼真的cg立体图像仍然具有现实世界立体图像的挑战性。这个数据集对摄像机跟踪算法也有很大的用处，因为我们在每帧中都提供了精确的相机位置和旋转角度。</p>
<p>立体视觉是一个非常活跃的研究课题，每年都会介绍几种新的立体匹配方法。这些立体匹配算法的目标是准确地生成一个密集的视差图，该视差图描述了左右摄像头看到的对应特征在位置上的差异。为了测量和比较这些算法的性能，必须知道地面真值视差图。一些具有已知地面真值非奇偶校验图的立体数据集是可用的[5,6]，但立体成像的数量非常有限。这个限制限制了t</p>
<p>该数据集的目的是提供地面真实数据，这些数据可用于评估计算机视觉算法的性能，尤其是对于立体视觉和摄像机跟踪方法。本节介绍我们为这个数据集生成的不同类型的地面真实数据。图4描述了此数据集可用的一些groundtruth数据。</p>
<p>地面真值视差图可用于评价立体匹配算法的整体质量。在对场景建模之后，渲染引擎的输出为每一帧提供两个RGB图像和两个灰度图像。灰度图像cre-ated使用自定义渐变着色器和代表的depthmap场景(图5)。这个深度地图可以eas-ily变成差距地图知道cam-era固有参数(成立于相机prop-erties CG软件)和以下公式foreach像素的深度图像</p>
<p><img src="https://i.loli.net/2020/03/29/YFRG3gsWqcaKNHS.png" alt="image-20191223150640328"></p>
<p>但是，这种方法有一个小限制：渲染的深度图的分辨率只有8位，这意味着只有256种可能的值来表示深度，这很快就不足以表示所有深度值。 一个大场景，这反过来会导致视差图不正确。</p>
<p>我们通过迭代绘制深度图来解决这个问题，改变近距离和远距离剪切平面的值，使得两个平面之间的距离很小足够有一个良好的深度分辨率，只有256个值。然后，我们得到一个单一的视差映射使用上述公式和所有深度映射不同配置的剪切平面。迭代渲染深度图部分的方法允许我们生成任意分辨率的地面真值视差图。在这项工作中，我们生成了具有像素精度的非奇偶映射(亚像素精度有待进一步的工作)。我们为左右摄像头提供视差图。见图4</p>
<p>除了视差图之外，对于立体匹配方法的评估，有一个无遮挡的区域蒙版是很有趣的。这个遮罩用白色表示场景中两个摄像头都能看到的像素，用黑色表示只能从一个摄像头看到的像素。为了得到无遮挡的区域蒙版，我们简单地交叉检查了左右的视差图。在两个相机中可见的像素在两个视差图中具有相同的值，但是对于被遮挡的像素，左右视差值将不同。立体匹配算法的性能涉及领域</p>
<p>如果在其他图像上看不到像素中的一个像素，则很难找到它的匹配点。我们为左右相机提供了非遮挡区域遮罩。 见图4.3.3。 近深度不连续区域蒙版与视差图和非遮挡区域蒙版一起，近深度不连续区域蒙版是用于标准立体匹配算法评估的第三类地面真实数据。 这种遮罩允许在接近深度不连续性（即对象的边界）的区域内评估算法的性能。 这是特别有趣的，因为大多数方法在这些区域中表现较差。要获得这种蒙版，我们检测了非遮挡蒙版的边界。 这样，灰度值代表两个摄像机都可见的像素，黑色像素代表被遮挡的像素，白色像素代表被遮挡/不被遮挡的像素之间的过渡附近的像素。 。 参见图4</p>
<h2 id="On-Building-an-Accurate-Stereo-Matching-System-on-Graphics-Hardware"><a href="#On-Building-an-Accurate-Stereo-Matching-System-on-Graphics-Hardware" class="headerlink" title="On Building an Accurate Stereo Matching System on Graphics Hardware"></a>On Building an Accurate Stereo Matching System on Graphics Hardware</h2><p>本文提出了一种基于gpu的立体匹配系统，该系统具有良好的精度和速度性能。匹配的成本体积初始化与AD-Censusmeasure，聚集在动态的交叉区域，并在扫描线优化框架生产的差异结果。对视差结果中的各种误差进行了多步细化处理。该系统的每个阶段都采用并行设计，这样计算就可以通过CUDA实现来加速。实验结果验证了该方法的准确性和有效性</p>
<p>立体匹配是计算机视觉[11]中最广泛研究的问题之一。立体匹配算法设计的两个主要问题是匹配精度和处理效率。尽管每年都会引入许多算法，但在报告的结果中，这两个问题往往是矛盾的:精确的立体方法通常很耗时[6,17,20]，而基于gpu的方法则可以在相对较低的视差精度下实现较高的处理速度[10,18,24]。据我们所知，大多数top10Middlebury算法至少需要10秒来处理a384 288imag</p>
<p>∙一个系统的优化过程，可通过迭代区域投票，插值，深度不连续调整和子像素增强来处理各种视差误差。<br>事实证明，此多步骤过程对于改善视差结果非常有效。 </p>
<p><img src="https://i.loli.net/2020/03/29/SzqEX9Fcrp6boJv.png" alt="image-20191228192736094"></p>
<p>立体匹配算法分类：从算法本身的角度来说，立体匹配从大的方面分为两种，全局匹配和局部匹配。全局匹配比较经典的有动态规划、图割和置信度传播等，全局匹配算法优点是精度高，缺点是计算速度慢，实时性差；而局部匹配又分为基于区域的匹配，基于特征的匹配等。局部匹配优点是速度快，可以满足实时的要求，但是精度不如前者，基于区域的匹配精度尚可以接受，基于特征的匹配则只能得到稀疏的视差，需要靠插值完成视差图重建，如果要考察整个图的视差精度，则基于特征法不可靠。</p>
<p>图割，置信传播等全局优化立体匹配算法，由于运算过程中需要迭代求精，运算时间长，无法达到实时计算立体匹配的需求，然而实时性需求却广泛存在立体匹配的应用场景中。很多基于局部匹配的算法虽然运算时间短，但由于仅考虑匹配窗内的代价聚合，效果很差，视差图只有很多稀疏的视差点，还要经过插值计算，显然无法用于汽车导航，目标拾取等需要精确结果且对运算速度有一定要求的场景。</p>
<h3 id="1局部代价聚合"><a href="#1局部代价聚合" class="headerlink" title="1局部代价聚合"></a>1局部代价聚合</h3><p>基于窗结构局部立体匹配算法，按照匹配约束来搜索最佳的匹配点，在搜索求取左右两幅图像在视差d下一点的匹配代价时，实际是求得以该点为中心的匹配窗内所有点的代价的平均值（或者其他的度量方式）。如图（4-1）：<br><img src="https://i.loli.net/2020/03/29/UM7wueaFz8NYHOh.png" alt="image-20191228192046004"><br>图 4-1 局部匹配算法的代价传递<br>Figure 4-1 Cost delivery of local aggregation<br>我们把这一过程叫做代价聚类（Cost aggregation），这种基于区域的匹配方法利用局部窗口之间的相似性度量来匹配对应基元的空间坐标，对于连续性细节明显的区域效果较好。显然，此类方法对于匹配窗以外的点却无法影响该点的代价值，使得代价聚类的值不具有全局特性，也就丧失了匹配基元的全局结构特性，因此在纹理特征较低的区域非常容易产生误匹配。<br>如何在代价聚类中获取匹配基元的全局特征，进而使得局部代价聚合方法克服上述缺点，本章相对于基于区域的局部窗立体匹配方法，采用图论中的最小生成树方法，利用树结构进行全局代价聚合。</p>
<p>双边滤波（Bilateral filter）是一种可以保边去噪的滤波器。简单的说就是一种同时考虑了像素空间差异与强度差异的滤波器，因此具有保持图像边缘的特性。该滤波器可以由两个滤波参数进行控制。一个控制几何空间距离。另一个控制像素差。</p>
<p><img src="https://i.loli.net/2020/03/29/e5UZLkOwYBDEnxR.png" alt="image-20191228192031108"></p>
<p>公式（4-1）是一个归一加权平均，和分别衡量图像I的滤除量，前者控制距离信息的权重，后者控制颜色信息的权重。因此总体而言，在像素强度变换不大的区域，双边滤波有类似于高斯滤波的效果，而在图像边缘等强度梯度较大的地方，可以保持梯度。该特性在立体匹配问题中可以取代图像分割方法，或者作为图像分割方法的预处理手段，降低核心匹配算法的计算量。</p>
<h2 id="12-21-工作汇报"><a href="#12-21-工作汇报" class="headerlink" title="12-21-工作汇报"></a>12-21-工作汇报</h2><p>最近根据标准<a href="http://vision.middlebury.edu/stereo/data/scenes2014/" target="_blank" rel="noopener">双目数据集</a>利用一系列双目匹配算法进行了实验，本次实验共选取BM、SGBM、GC算法进行比较。其中各个算法的原理论文分别为:</p>
<ul>
<li>BM:<a href="http://vision.deis.unibo.it/~smatt/Seminars/StereoVision.pdf" target="_blank" rel="noopener">介绍双目匹配原理非常清晰的PDF</a></li>
<li>SGBM:<a href="https://ieeexplore.ieee.org/abstract/document/4359315/" target="_blank" rel="noopener">Stereo Processing by Semi-global Matching and Mutual Information</a></li>
<li>GC:<a href="http://www.cvlab.cs.tsukuba.ac.jp/~kfukui/english/epapers/trakmark2012.pdf" target="_blank" rel="noopener">Realistic CG Stereo Image Dataset with Ground Truth Disparity </a></li>
</ul>
<p>以上原理的论文资料均已整理至/reference文件夹内.</p>
<blockquote>
<p>另外关于近20年双目匹配的<a href="https://blog.csdn.net/xuyuhua1985/article/details/26283389" target="_blank" rel="noopener">论文整理</a></p>
</blockquote>
<h3 id="论文实验结果如下："><a href="#论文实验结果如下：" class="headerlink" title="论文实验结果如下："></a>论文实验结果如下：</h3><p>我们采用的数据集标准图片为:</p>
<p><img src="https://i.loli.net/2020/03/29/vbdLBYe2RDNMkQx.png" alt="image-20191219222637363"></p>
<p><strong>SADWindowSize</strong>：匹配代价计算的窗口的大小,容许范围是<code>[5,255]</code>，一般应该在 <code>5x5</code> 至<code>21x21</code>之间，参数必须是奇数.<code>blockSize(SADWindowSize)</code> 越小，也就是匹配代价计算的窗口越小，视差图噪声越大；<code>blockSize</code>越大，视差图越平滑；太大的<code>size</code>容易导致过平滑，并且误匹配增多，体现在视差图中空洞增多；</p>
<p><strong>numberOfDisparities</strong>:控制视差的数量.最大的深度值减去最小得到的值</p>
<h3 id="使用BM算法"><a href="#使用BM算法" class="headerlink" title="使用BM算法:"></a>使用BM算法:</h3><p><img src="https://i.loli.net/2020/03/29/8OfCBzF9gtiLvZ4.png" alt="image-20191221161231075"></p>
<h3 id="使用SGBM算法"><a href="#使用SGBM算法" class="headerlink" title="使用SGBM算法:"></a>使用SGBM算法:</h3><p><img src="https://i.loli.net/2020/03/29/buKD1eiTymXoNBQ.png" alt="image-20191221161355163"></p>
<h3 id="使用GC算法"><a href="#使用GC算法" class="headerlink" title="使用GC算法:"></a>使用GC算法:</h3><p><img src="https://i.loli.net/2020/03/30/NDTKwRxUpfnjHBY.png" alt=""></p>
<p><img src="https://i.loli.net/2020/03/29/pxrBIXukhefKE36.png" alt="image-20191219222703531"></p>
<h2 id="接下来工作进展"><a href="#接下来工作进展" class="headerlink" title="接下来工作进展:"></a>接下来工作进展:</h2><p>进一步理解<code>SGB</code>算法代码实现原理,采用自己拍摄的牙齿图片用上述算法进行测试,进而整理出文档出来.</p>
<h2 id="12-25-工作汇报"><a href="#12-25-工作汇报" class="headerlink" title="12-25-工作汇报"></a>12-25-工作汇报</h2><ul>
<li><p>移植了<code>ADCensus</code>算法，算法相关原理参考论文 <a href="http://www.nlpr.ia.ac.cn/2011papers/gjhy/gh75.pdf" target="_blank" rel="noopener">On Building an Accurate Stereo Matching System on Graphics Hardware</a></p>
<blockquote>
<p><code>ADCensus</code>双目立体匹配算法曾一度排在<code>MiddleBurry</code>官网上第一的位置，引用量很高。其主要优点是并行加速，精度又好，能有效兼顾这两点。</p>
<p><a href="https://www.cnblogs.com/sinbad360/p/7842009.html" target="_blank" rel="noopener">ADCensus详细介绍链接</a></p>
</blockquote>
</li>
<li><p>对<code>ADCensus</code>进行标准<code>midleburry</code>数据集测试，测试结果如下图：</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/03/29/ukBfDqr6tngUMS8.png" alt="image-20191225220436594"></p>
<blockquote>
<p>使用标准数据集进行匹配可以看出匹配效果还不错。</p>
</blockquote>
<ul>
<li>对<code>ADCensus</code>进行双目相机测试，测试结果如下图：</li>
</ul>
<p><img src="https://i.loli.net/2020/03/29/UKDT5LXv3ey8Cm2.png" alt="image-20191225220552499"></p>
<blockquote>
<p>使用自己买的双目相机进行匹配可以看出匹配效果非常不好。</p>
</blockquote>
<p>我开始猜想可能是因为我的双目相机左右成像色调差别太大导致的，根据<code>PS</code>调出的直方图可以看出标准数据集的左右照片直方图相似度很高；而我们自己买的双目相机拍出来的左右相机的直方图差别却很大。</p>
<p><img src="https://i.loli.net/2020/03/29/qjcZ2mADX1WGdYU.png" alt="image-20191225210751049"></p>
<p><img src="https://i.loli.net/2020/03/29/QrKXDnvIfiLy3ux.png" alt="image-20191225210727207"></p>
<p><img src="https://i.loli.net/2020/03/30/BxdLDkMjN7eynX4.png" alt="image-20191225210823719"></p>
<p><img src="https://i.loli.net/2020/03/29/5EHZ1xgz8nPMjGt.png" alt="image-20191225210808554"></p>
<p>为了验证自己的猜想，我又选取了另外一套用于自动驾驶的双目数据集<code>KITTI</code>，在经过<code>ADCensus</code>算法运行之后，匹配效果如图：</p>
<p><img src="https://i.loli.net/2020/03/29/N4CMjAUvXw8GthK.png" alt="image-20191225221540846"></p>
<blockquote>
<p>可以看出使用<code>KITTI</code>数据集匹配的效果也还不错。</p>
</blockquote>
<p>综上：我打算接下来将自己买的双目相机拍出来的左右照片进行一下直方图匹配，看一下<code>ADCensus</code>算法在牙齿模型的匹配效果究竟如何，然后撰写最近一个星期的工作总结。</p>
<p>另外，我重新整理了<code>SVN</code>的代码与参考资料，对<code>OpenCV</code>3.40重新<code>CMake</code>，对于一些将来可能会用到的<code>CUDA</code>模块熟悉了一下。</p>
<h2 id="12-28工作汇报"><a href="#12-28工作汇报" class="headerlink" title="12-28工作汇报"></a>12-28工作汇报</h2><p>1.发现David 3D对于牙齿的建模效果不错，于是调研了一下：它们是采用双目相机+结构光来对牙齿模型进行建模的。</p>
<p><img src="https://i.loli.net/2020/03/30/D2h5xj9TqAXUzLH.png" alt=""></p>
<blockquote>
<p><strong>DAVID Laserscanner</strong> is a software package for low-cost 3D laser scanning. It allows scanning and digitizing of three-dimensional objects using a camera (e.g. a web cam), a hand-held <a href="https://en.wikipedia.org/wiki/Line_laser" target="_blank" rel="noopener">line laser</a> (i.e. one that projects a line, not just a point), and two plain boards in the background. Its most distinctive feature is that the laser line can simply be swept over the object by hand (like a virtual brush) until the results are satisfactory. At the same time, DAVID Laserscanner generates 3D data in real time and shows them on the computer screen.</p>
<p>The resulting 3D mesh can be exported into well-known file formats and can thus be imported and processed in most 3D applications. The software is also able to grab the texture and “stitch together” scans made from different viewing directions.</p>
</blockquote>
<p><a href="https://www.bilibili.com/video/av80957886/" target="_blank" rel="noopener">关于David 3D的视频的详细介绍Intro to DAVID SLS-2 3D Scanner</a></p>
<p><img src="https://i.loli.net/2020/03/29/CwR4hsUfi8edvNF.png" alt="image-20191228122640270"></p>
<p>2.联系了深圳威鑫视界公司对之前购买的双目摄像头重新进行烧录，这是烧录之前一对有着明显色调差异的双目照片：</p>
<p><img src="https://i.loli.net/2020/03/29/UkrpEWsePXwxvS3.png" alt="image-20191227204722135"></p>
<p>经过对方重新烧录之后，可以看出两幅图片起码色调一致了：</p>
<p><img src="https://i.loli.net/2020/03/29/3E2MwSqzFOnZe4R.png" alt="image-20191228213354929"></p>
<p>接着重新进行相机的标定与图片的矫正，此次共拍摄8组照片，双目匹配结果如下：</p>
<p><img src="https://i.loli.net/2020/03/29/4x3DJ7bXTQYpq6A.png" alt="image-20191228213816820"></p>
<p><img src="https://i.loli.net/2020/03/29/uqhUwGvLtXzBTcC.png" alt="image-20191228213855628"></p>
<p><img src="https://i.loli.net/2020/03/29/Qqct3xFmIMSEobJ.png" alt="image-20191228214240868"></p>
<blockquote>
<p>可以看出前两幅图建的不好，原因是左右图没有经过预处理，左右直方图区别过大导致匹配效果不好。从《基于双目立体视觉的三维重建方法研究_党乐》一文中可以根据他的做法进行左右图的预处理。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/29/Og7HRikLVJTIjYs.png" alt="image-20191227161700855"></p>
<p><img src="https://i.loli.net/2020/03/29/x7RoVkEubmIpc1h.png" alt="image-20191227161716225"></p>
<p>3.下一步计划看一下下面的这个方法：</p>
<blockquote>
<p>Tatsunori Taniai, Yasuyuki Matsushita, Yoichi Sato, and Takeshi Naemura. <a href="http://taniai.space/projects/stereo/" target="_blank" rel="noopener">Continuous 3D label stereo matching using local expansion moves</a>. PAMI 40(11):2725-2739, 2018. <a href="https://github.com/t-taniai/LocalExpStereo" target="_blank" rel="noopener">Code</a>.</p>
</blockquote>
<p>以及经过预处理之后的牙齿匹配结果如何。</p>
<p>4.一些走的弯路;</p>
<blockquote>
<p>双目经过棋盘格标定之后，在拍摄牙齿模型时，由于双目相机不具备自动变焦功能导致看不清楚，所以会手动拧镜头螺纹导致焦距发生变化，之前标定好的和焦距相关的数据有的就会发生变化，进而导致后续的工作出现差错。</p>
<p>和学姐讨论了一波，之所以我们双目匹配的效果不如人家的标准数据集好，是因为标准数据集经过了非常严格的光线调节，它们的左右图差距很小，这一点从直方图就可以看出来。我们能不能达到这样好的效果呢？一部分取决于预处理的效果，一部分取决于摄像头：如果摄像头拍的特别差，后期软件再怎么处理也是收效甚微。</p>
</blockquote>
<h2 id="1-3工作汇报"><a href="#1-3工作汇报" class="headerlink" title="1-3工作汇报"></a>1-3工作汇报</h2><h5 id="全像素点云及重建结果"><a href="#全像素点云及重建结果" class="headerlink" title="全像素点云及重建结果"></a>全像素点云及重建结果</h5><p><img src="https://i.loli.net/2020/03/29/pOWLxoZuMC3wznc.png" alt="image-20200104163734005"></p>
<p><img src="https://i.loli.net/2020/03/30/ZLKUYolNk7cRisA.png" alt="image-20200104165024323"></p>
<h5 id="0度像素点云及重建结果"><a href="#0度像素点云及重建结果" class="headerlink" title="0度像素点云及重建结果"></a>0度像素点云及重建结果</h5><p><img src="https://i.loli.net/2020/03/30/nSOd2vy9PKWCwxE.png" alt="image-20200104163806059"></p>
<p><img src="https://i.loli.net/2020/03/29/wFSm389bdTJezrM.png" alt="image-20200104165929665"></p>
<h5 id="45度点云及重建结果"><a href="#45度点云及重建结果" class="headerlink" title="45度点云及重建结果"></a>45度点云及重建结果</h5><p><img src="https://i.loli.net/2020/03/29/gqirTzsxBR6E1YC.png" alt="image-20200104171514994"></p>
<p><img src="https://i.loli.net/2020/03/29/zhZuJtaCAKXcEjT.png" alt="image-20200104171921350"></p>
<h5 id="90度点云及重建结果（失败）"><a href="#90度点云及重建结果（失败）" class="headerlink" title="90度点云及重建结果（失败）"></a>90度点云及重建结果（失败）</h5><p><img src="https://i.loli.net/2020/03/29/VwMlQpBmTrznWAt.png" alt="image-20200104172657147"></p>
<p><img src="https://i.loli.net/2020/03/29/3gVdlc8LJRo21qW.png" alt="image-20200104173018825"></p>
<h5 id="135度点云及重建结果（失败）"><a href="#135度点云及重建结果（失败）" class="headerlink" title="135度点云及重建结果（失败）"></a>135度点云及重建结果（失败）</h5><p><img src="https://i.loli.net/2020/03/29/EFmLYzlXK4AUhuJ.png" alt="image-20200104181416265"></p>
<hr>
<h5 id="预处理左右原图："><a href="#预处理左右原图：" class="headerlink" title="预处理左右原图："></a>预处理左右原图：</h5><p><img src="https://i.loli.net/2020/03/30/D2LWKHYrcu9UAPg.png" alt="image-20191231132610545"></p>
<p><img src="https://i.loli.net/2020/03/30/ny5pbPQoXRIKFqE.png" alt="image-20191231132624181"></p>
<h5 id="经过中值滤波之后："><a href="#经过中值滤波之后：" class="headerlink" title="经过中值滤波之后："></a>经过中值滤波之后：</h5><p><img src="https://i.loli.net/2020/03/29/yFfm3vZC5eaE4nb.png" alt="image-20191231132210206"></p>
<p><img src="https://i.loli.net/2020/03/29/ghKbdeqAX5DwLkG.png" alt="image-20191231132223593"></p>
<h5 id="经过clahe直方图均衡化之后"><a href="#经过clahe直方图均衡化之后" class="headerlink" title="经过clahe直方图均衡化之后"></a>经过clahe直方图均衡化之后</h5><p><img src="https://i.loli.net/2020/03/29/AfmkbQCPGzBViN7.png" alt="image-20191231134546847"></p>
<p><img src="https://i.loli.net/2020/03/29/iawqlndyt3g2GcU.png" alt="image-20191231134602453"></p>
<h5 id="经过直方图匹配之后："><a href="#经过直方图匹配之后：" class="headerlink" title="经过直方图匹配之后："></a>经过直方图匹配之后：</h5><p><img src="https://i.loli.net/2020/03/29/QWEwaCDkbfeLJ1v.png" alt="image-20191231134624053"></p>
<p><img src="https://i.loli.net/2020/03/29/oXs5JEiKnPQcOA3.png" alt="image-20191231134647789"></p>
<h5 id="unsharpMasking之后："><a href="#unsharpMasking之后：" class="headerlink" title="unsharpMasking之后："></a>unsharpMasking之后：</h5><p><img src="https://i.loli.net/2020/03/29/9eZdbnQas5SjIBY.png" alt="image-20191231135358167"></p>
<p><img src="https://i.loli.net/2020/03/29/iRJLwet3TKaINzS.png" alt="image-20191231135407136"></p>
<p><img src="https://i.loli.net/2020/03/29/TrBQMzuCO3E46LK.png" alt="image-20191227161730595"></p>
<p><img src="https://i.loli.net/2020/03/29/fCDUd5GLIs8olg7.png" alt="image-20191227161754508"></p>
<pre><code>IplImage * img1 = cvLoadImage(&quot;../../DataSets/Tooth/Rectified/08left_picture.png&quot;, CV_LOAD_IMAGE_GRAYSCALE);
IplImage * img2 = cvLoadImage(&quot;../../DataSets/Tooth/Rectified/08right_picture.png&quot;, CV_LOAD_IMAGE_GRAYSCALE);</code></pre><p>此步骤计算初始匹配成本量。<br>由于可以在每个像素和每个视差级别同时执行计算，因此此步骤本质上是并行的。<br>我们主要关注的是开发一种具有高匹配质量的成本衡量方法。<br>通用成本度量包括绝对差（AD），Birchfield和Tomasi的不采样抽样度量（BT），基于梯度的度量以及诸如等级和人口普查之类的非参数转换[22]。<br>在Hirschmuller和Scharstein的最新评估中[3]，人口普查显示了局部和全局立体匹配方法的最佳总体结果。<br>尽管合并成本度量以提高准确性的想法似乎很简单，但是相对较少的工作探讨了该主题。<br>克劳斯等。<br>文献[6]提出将SAD和基于梯度的度量线性组合以进行成本计算。<br>他们的差异结果令人印象深刻，但是合并的好处却没有明确阐述。<br>人口普查使用像素强度的相对顺序（而不是强度值本身）对局部图像结构进行编码，因此可以容忍由于辐射度变化和图像噪声引起的异常值。<br>但是，此资产也可能在具有重复或类似局部结构的图像区域中引入匹配的歧义。<br>为了解决这个问题，应在该措施中纳入更详细的信息。<br>对于具有相似局部结构的图像区域，颜色（或强度）信息可能有助于减轻匹配的歧义。<br>而对于具有相似颜色分布的区域，通过窗口进行的普查变换比基于像素的强度差更鲁棒。<br>这种观察激发了一种综合措施。</p>
<p><img src="https://i.loli.net/2020/03/29/OEkSHUCpNmuW3RX.png" alt="image-20191224213727896"></p>
<h2 id="关于imwrite写入异常情况的处理"><a href="#关于imwrite写入异常情况的处理" class="headerlink" title="关于imwrite写入异常情况的处理"></a>关于imwrite写入异常情况的处理</h2><p>这是因为第一个参数path不给人家设置图片后缀格式导致人家找不到对应的解析器，所以抛出异常来了</p>
<p><img src="https://i.loli.net/2020/03/29/ymxC36JlchMZ7Ba.png" alt="image-20191223230727334"></p>
<h2 id="完成双目匹配到点云拼接的流程"><a href="#完成双目匹配到点云拼接的流程" class="headerlink" title="完成双目匹配到点云拼接的流程"></a>完成双目匹配到点云拼接的流程</h2><p><a href="http://vision.middlebury.edu/stereo/eval3/" target="_blank" rel="noopener">双目跑分</a>NOSS-ROB</p>
<ul>
<li>Superpixel alpha-expansion and normal adjustment for stereo matching</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (scale != <span class="number">1.f</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Mat temp1, temp2;</span><br><span class="line">	<span class="keyword">int</span> method = scale &lt; <span class="number">1</span> ? INTER_AREA : INTER_CUBIC;</span><br><span class="line">	resize(img1, temp1, Size(), scale, scale, method);</span><br><span class="line">	img1 = temp1;</span><br><span class="line">	resize(img2, temp2, Size(), scale, scale, method);</span><br><span class="line">	img2 = temp2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内参intrinsics-yml"><a href="#内参intrinsics-yml" class="headerlink" title="内参intrinsics.yml"></a>内参intrinsics.yml</h2><p>M1:3行3列的那个标定矩阵</p>
<p>D1:就是那个畸变参数<code>distCoeff</code>，注意是5个的还是9个的</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void compute( InputArray leftarr, InputArray rightarr, OutputArray disparr )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="constructor">CV_INSTRUMENT_REGION()</span></span><br><span class="line"></span><br><span class="line">       Mat left = leftarr.get<span class="constructor">Mat()</span>, right = rightarr.get<span class="constructor">Mat()</span>;</span><br><span class="line">       <span class="constructor">CV_Assert( <span class="params">left</span>.<span class="params">size</span>()</span><span class="operator"> == </span>right.size<span class="literal">()</span><span class="operator"> &amp;&amp; </span>left.<span class="keyword">type</span><span class="literal">()</span><span class="operator"> == </span>right.<span class="keyword">type</span><span class="literal">()</span> &amp;&amp;</span><br><span class="line">                  left.depth<span class="literal">()</span><span class="operator"> == </span>CV_8U );</span><br><span class="line"></span><br><span class="line">       disparr.create( left.size<span class="literal">()</span>, CV_16S );</span><br><span class="line">       Mat disp = disparr.get<span class="constructor">Mat()</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(params.mode==MODE_SGBM_3WAY)</span><br><span class="line">           compute<span class="constructor">Disparity3WaySGBM( <span class="params">left</span>, <span class="params">right</span>, <span class="params">disp</span>, <span class="params">params</span>, <span class="params">buffers</span>, <span class="params">num_stripes</span> )</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(params.mode==MODE_HH4)</span><br><span class="line">           compute<span class="constructor">DisparitySGBM_HH4( <span class="params">left</span>, <span class="params">right</span>, <span class="params">disp</span>, <span class="params">params</span>, <span class="params">buffer</span> )</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           compute<span class="constructor">DisparitySGBM( <span class="params">left</span>, <span class="params">right</span>, <span class="params">disp</span>, <span class="params">params</span>, <span class="params">buffer</span> )</span>;</span><br><span class="line"></span><br><span class="line">       median<span class="constructor">Blur(<span class="params">disp</span>, <span class="params">disp</span>, 3)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>( params.speckleWindowSize &gt; <span class="number">0</span> )</span><br><span class="line">           filter<span class="constructor">Speckles(<span class="params">disp</span>, (<span class="params">params</span>.<span class="params">minDisparity</span> - 1)</span>*StereoMatcher::DISP_SCALE, params.speckleWindowSize,</span><br><span class="line">                          StereoMatcher::DISP_SCALE*params.speckleRange, buffer);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="SAD方法就是以左目图像的源匹配点为中心，定义一个窗口D，其大小为（2m-1）-2n-1-，"><a href="#SAD方法就是以左目图像的源匹配点为中心，定义一个窗口D，其大小为（2m-1）-2n-1-，" class="headerlink" title="SAD方法就是以左目图像的源匹配点为中心，定义一个窗口D，其大小为（2m+1） (2n+1)，"></a>SAD方法就是以左目图像的源匹配点为中心，定义一个窗口D，其大小为（2m+1） (2n+1)，</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">统计其窗口的灰度值的和，然后在右目图像中逐步计算其左右窗口的灰度和的差值，</span><br><span class="line">最后搜索到的差值最小的区域的中心像素即为匹配点。</span><br><span class="line">基本流程：</span><br><span class="line">  <span class="number">1.</span>构造一个小窗口，类似与卷积核。</span><br><span class="line">  <span class="number">2.</span>用窗口覆盖左边的图像，选择出窗口覆盖区域内的所有像素点。</span><br><span class="line">  <span class="number">3.</span>同样用窗口覆盖右边的图像并选择出覆盖区域的像素点。</span><br><span class="line">  <span class="number">4.</span>左边覆盖区域减去右边覆盖区域，并求出所有像素点差的绝对值的和。</span><br><span class="line">  <span class="number">5.</span>移动右边图像的窗口，重复<span class="number">3</span>，<span class="number">4</span>的动作。（这里有个搜索范围，超过这个范围跳出）</span><br><span class="line">  <span class="number">6.</span>找到这个范围内SAD值最小的窗口，即找到了左边图像的最佳匹配的像素块。</span><br></pre></td></tr></table></figure>



<h2 id="img1-w-r-t-img2-and-write-it-to-disp1buf-就…而言with-respect-to"><a href="#img1-w-r-t-img2-and-write-it-to-disp1buf-就…而言with-respect-to" class="headerlink" title="img1 w.r.t. img2 and write it to disp1buf 就…而言with respect to"></a>img1 w.r.t. img2 and write it to disp1buf 就…而言with respect to</h2><h2 id="OpenCV提供了以下四种立体匹配算法的函数："><a href="#OpenCV提供了以下四种立体匹配算法的函数：" class="headerlink" title="OpenCV提供了以下四种立体匹配算法的函数："></a>OpenCV提供了以下四种立体匹配算法的函数：</h2><ol>
<li>Block Matching（BM） StereoBM</li>
<li>Semi-Global Block Matching（SGBM） StereoSGBM</li>
<li>Graph Cut（GC）cvStereoGCState()</li>
<li>Dynamic Programming（DP）cvFindStereoCorrespondence()</li>
</ol>
<p>第一种就是简单的块匹配，第三，四种是基于全局的匹配，以下简单介绍一下第二种算法。我们知道局部匹配计算量小速度快，而全局匹配计算量大速度慢，所以作者提出了SGBM算法[5]: 第一步对每一个Pixel使用块匹配BM进行匹配，得到了全部Pixel的disparity map。</p>
<p>第二步对Disparity map建立图，用Graph Cut对其进行全局优化。利用Rectification将二维转化为一维：则对每一个像素的可能的Disparity值d，从以下4中里面选取一个最小值：</p>
<ul>
<li>左相邻像素disparity取值为d时，其最小的cost值。</li>
<li>左相邻像素disparity取值为d-1时，其最小的cost值+惩罚1。</li>
<li>左相邻像素disparity取值为d+1时，其最小的cost值+惩罚1。</li>
<li>左相邻像素disparity取值为其他时，其最小的cost值+惩罚2。</li>
</ul>
<p>它与GC的区别在于它的左相邻像素的Disparity是已知的（根据块匹配结果），而GC是未知的，所以GC要对每一种取值进行一次计算，计算量比SGBM要大得多。</p>
<p>[5]H. Hirschmuller, Stereo Processing by Semi-global Matching and Mutual Information,”IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol. 30, Issue 2, pp. 328-341, Feb. 2008.</p>
<p>下图给出了各种不同算法的结果比较：</p>
<p>左右原图如下：</p>
<p><img src="https://i.loli.net/2020/03/29/RlzvDBSPuYpndfg.png" alt="image-20191219222650653"></p>
<h2 id="这个程序缺校正对齐那块以及自动调节参数那块内容"><a href="#这个程序缺校正对齐那块以及自动调节参数那块内容" class="headerlink" title="这个程序缺校正对齐那块以及自动调节参数那块内容"></a>这个程序缺校正对齐那块以及自动调节参数那块内容</h2><p>由于berry数据集不需要校正，所以和其他的程序有所不一样</p>
<p>如果把那些值设为0会怎么样？–可以绕过校正那一步直接到深度计算</p>
<p>添加一个可以在命令行动态修改参数的程序便于修改参数</p>
<p><img src="https://i.loli.net/2020/03/30/uHJs1AY9hOvNpgB.jpg" alt="SGBM-9-32"></p>
<h3 id="CommandLineParser"><a href="#CommandLineParser" class="headerlink" title="CommandLineParser"></a>CommandLineParser</h3><p>比如说”{ c | camera | 0 | use camera or not}”都是用大括号和双引号引起来，然后中间的内容分成4断，用”|”分隔开，分别表示简称，文件来源，文件值和帮助语句。第二行和第三行表示打开摄像头和打开文件，文件的文件名等都在keys指针中了。</p>
<h2 id="双目原理"><a href="#双目原理" class="headerlink" title="双目原理"></a>双目原理</h2><h2 id="numberOfDisparities等参数"><a href="#numberOfDisparities等参数" class="headerlink" title="numberOfDisparities等参数"></a>numberOfDisparities等参数</h2><p><code>left07.png right07.png --algorithm=bm --blocksize=9 --max-disparity=32 --scale=1 -i=intrinsics.yml -e=extrinsics.yml -o=diaparity.txt -p=pcl</code></p>
<p>参数-algorithm共有<strong>STEREO_BM</strong>、<strong>STEREO_SGBM</strong>、<strong>STEREO_HH</strong>、<strong>STEREO_VAR</strong>、<strong>STEREO_3WAY</strong></p>
<blockquote>
<p>OpenCV中SGBM算法的MODE_SGBM模式，实现了5个方向搜索，MODE_HH实现了8个方向搜索（可通过注释掉代码中部分，观察任一方向搜索得到的结果），这部分的代码，我已加了部分注释，可结合OpenCV源码对照观看，如下所示。</p>
<p>MODE_SGBM_3WAY模式，顾名思义，从左侧、上侧和右侧三个方向进行搜索，代码中有并行处理部分，速度很快。</p>
<p>MODE_HH4模式从上下左右四个方向搜索，代码中有并行处理部分，速度依旧很快。</p>
</blockquote>
<p>\1. blockSize(SADWindowSize) 越小，也就是匹配代价计算的窗口越小，视差图噪声越大；blockSize越大，视差图越平滑；太大的size容易导致过平滑，并且误匹配增多，体现在视差图中空洞增多；<br>\2. 惩罚系数控制视差图的平滑度，P2&gt;P1，P2越大则视差图越平滑；<br>\3. 八方向动态规划较五方向改善效果不明显，主要在图像边缘能够找到正确的匹配；</p>
<p>max-disparity**:必须为16的倍数</p>
<p><strong>blocksize</strong>：匹配块的大小 Matched block size. It must be an odd number &gt;=1 . Normally, it should be somewhere in the 3..11 range. SAD代价计算窗口大小，默认为5。窗口大小为奇数，一般在3<em>3 到21</em>21之间；1. blockSize(SADWindowSize) 越小，也就是匹配代价计算的窗口越小，视差图噪声越大；blockSize越大，视差图越平滑；太大的size容易导致过平滑，并且误匹配增多，体现在视差图中空洞增多；</p>
<p><strong>no-display</strong>：管是否显示的</p>
<p><strong>scale</strong>：调节图像大小的</p>
<p><strong>minDisparity</strong>：最小的深度值，通常情况下为0，但是一些校正算法有时会使图片变形，所以你得根据实际情况进行设置</p>
<p><strong>numDisparities</strong>：最大的深度值减去最小得到的值</p>
<p><strong>P1</strong>：The first parameter controlling the disparity smoothness. See below.</p>
<p><strong>P2</strong>：The second parameter controlling the disparity smoothness. The larger the values are, the smoother the disparity is.P1是相邻像素间差值变化正负1的惩罚。P2是相邻像素之间视差变化超过1的惩罚。The algorithm requires P2 &gt; P1 .</p>
<p><strong>uniquenessRatio</strong>：最佳（最小）计算成本函数值应“赢得”次优值以认为找到的匹配正确的百分比裕度。 通常，在5到15范围内的值就足够了。Margin in percentage by which the best (minimum) computed cost function value should “win” the second best value to consider the found match correct. Normally, a value within the 5-15 range is good enough.</p>
<p><strong>speckleWindowSize</strong>：Maximum size of smooth disparity regions to consider their noise speckles and invalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in the 50-200 range.</p>
<p><strong>mode</strong>:将其设置为StereoSGBM :: MODE_HH即可运行满量程两遍动态编程算法。 它将消耗O（W * H * numDisparities）字节，对于640x480立体来说很大，而对于HD尺寸的图片来说很大。 默认情况下，它设置为false。</p>
<p>其中<code>minDisparity</code>是控制匹配搜尋的第一個引數，代表了匹配搜蘇從哪裡開始，numberOfDisparities表示最大搜尋視差數uniquenessRatio表示匹配功能函式，這三個引數比較重要，可以根據實驗給予引數值。</p>
<p>// 预处理滤波参数</p>
<p><code>preFilterType</code>：预处理滤波器的类型，主要是用于降低亮度失真（photometric distortions）、消除噪声和增强纹理等, 有两种可选类型：CV_STEREO_BM_NORMALIZED_RESPONSE（归一化响应） 或者 CV_STEREO_BM_XSOBEL（水平方向Sobel算子，默认类型）, 该参数为 int 型；<br><strong>preFilterSize</strong>：预处理滤波器窗口大小，容许范围是[5,255]，一般应该在 5x5…21x21 之间，参数必须为奇数值, int 型<br><strong>preFilterCap</strong>：预处理滤波器的截断值，预处理的输出值仅保留[-preFilterCap, preFilterCap]范围内的值，参数范围：1 - 31（文档中是31，但代码中是 63）, int</p>
<p><strong>SADWindowSize：SAD</strong>窗口大小，容许范围是[5,255]，一般应该在 5x5 至 21x21 之间，参数必须是奇数，int 型<br>minDisparity：最小视差，默认值为 0, 可以是负值，int 型<br>numberOfDisparities：视差窗口，即最大视差值与最小视差值之差, 窗口大小必须是 16 的整数倍，int 型<br>// 后处理参数</p>
<p><strong>textureThreshold</strong>：低纹理区域的判断阈值。如果当前SAD窗口内所有邻居像素点的x导数绝对值之和小于指定阈值，则该窗口对应的像素点的视差值为 0（That is, if the sum of absolute values of x-derivatives computed over SADWindowSize by SADWindowSize pixel neighborhood is smaller than the parameter, no disparity is computed at the pixel），该参数不能为负值，int 型<br><strong>uniquenessRatio</strong>：视差唯一性百分比， 视差窗口范围内最低代价是次低代价的(1 + uniquenessRatio/100)倍时，最低代价对应的视差值才是该像素点的视差，否则该像素点的视差为 0 （the minimum margin in percents between the best (minimum) cost function value and the second best value to accept the computed disparity, that is, accept the computed disparity d^ only if SAD(d) &gt;= SAD(d^) x (1 + uniquenessRatio/100.) for any d != d<em>+/-1 within the search range ），该参数不能为负值，一般5-15左右的值比较合适，int 型<br>*</em>speckleWindowSize<strong>：检查视差连通区域变化度的窗口大小, 值为 0 时取消 speckle 检查，int 型<br>**speckleRange</strong>：视差变化阈值，当窗口内视差变化大于阈值时，该窗口内的视差清零，int 型<br>// OpenCV2.1 新增的状态参数</p>
<p><strong>roi1, roi2</strong>：左右视图的有效像素区域，一般由双目校正阶段的 cvStereoRectify 函数传递，也可以自行设定。一旦在状态参数中设定了 roi1 和 roi2，OpenCV 会通过cvGetValidDisparityROI 函数计算出视差图的有效区域，在有效区域外的视差值将被清零。<br><strong>disp12MaxDiff</strong>：左视差图（直接计算得出）和右视差图（通过cvValidateDisparity计算得出）之间的最大容许差异。超过该阈值的视差值将被清零。该参数默认为 -1，即不执行左右视差检查。int 型。注意在程序调试阶段最好保持该值为 -1，以便查看不同视差窗口生成的视差效果。具体请参见《使用OpenGL动态显示双目视觉三维重构效果示例》一文中的讨论。<br>在上述参数中，对视差生成效果影响较大的主要参数是 SADWindowSize、numberOfDisparities 和 uniquenessRatio 三个，一般只需对这三个参数进行调整，其余参数按默认设置即可。</p>
<p><img src="https://i.loli.net/2020/03/29/pePqy1cVSBmUvFK.png" alt="image-20191221154914385"></p>
<p><img src="https://i.loli.net/2020/03/29/FmCKeQ5tTMzbWk2.png" alt="image-20191221155003546"></p>
<p><img src="https://i.loli.net/2020/03/29/nkRLmKpv5Q2UwoB.png" alt="image-20191220104349530"></p>
<p>原来视差（disparity）指的是同一特征点在左右相机成像像素的距离差啊，我之前以为是求出来的灰度值是视差，天哪,这里越近的点越亮该如何理解？下面的图很好的给出了诠释。</p>
<blockquote>
<p>The disparity is the difference between the x coordinate of two corresponding points; it is typically encoded with greyscale image (closer points are brighter).</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/30/KS6mMe3yThlEuRH.png" alt="image-20191220104922045"></p>
<p><img src="https://i.loli.net/2020/03/29/xdQYebCsry4mO3K.png" alt="image-20191220105323391"></p>
<p>还有一个问题，我之前在计算的时候有考虑过两个摄像头之间的那个间距b吗？</p>
<p><a href="http://vision.deis.unibo.it/~smatt/stereo.htm" target="_blank" rel="noopener">双目照片</a></p>
<p><img src="https://i.loli.net/2020/03/29/avcsrYTZi8o6fFG.png" alt="image-20191220110305832"></p>
<p>通常会有一个预处理阶段主要是消除一些光学的扭曲：</p>
<p>典型的方法包括：</p>
<ul>
<li><p>Laplacian of Gaussian (LoG) filtering</p>
</li>
<li><p>Subtraction of mean values computed in nearby pixels</p>
</li>
<li><p>双边滤波</p>
</li>
<li><p>Census transform </p>
</li>
</ul>
<p>A、匹配代价计算</p>
<p><img src="https://i.loli.net/2020/03/29/93peBV8jldiboHA.png" alt="image-20191220111053226"></p>
<p><img src="https://i.loli.net/2020/03/29/yLuBJrV8DnoMlt5.png" alt="image-20191220111116408"></p>
<p><img src="https://i.loli.net/2020/03/30/1l7JwnKTRIfXW4P.png" alt="image-20191220111153031"></p>
<p>怎样去提升土办法的表现呢？主要有两个不同的方法（非互相排斥）？</p>
<p>局部算法使用了WTA策略。但是减少了模棱两可的东西（通过在支持窗口上聚集匹配代价增加了信噪比的信号？）也就是内核或相关窗口。有时采用平滑项</p>
<blockquote>
<p>Local algorithms use the simple WTA disparity selection  strategy but reduce ambiguity (increasing the signal to  noise ratio (SNR)) by aggregating matching costs over a  support window (aka kernel or correlation window).  Sometime a smoothness term is adopted. Steps 1+2 (+ WTA)</p>
</blockquote>
<p>全局或者半全局算法会通过使在整个双目匹配对的能量函数最小的的方法去寻找视差，</p>
<blockquote>
<p>algorithms search for disparity  assignments that minimize an energy function over the whole  stereo pair using a pixel-based matching cost (sometime the  matching cost is aggregated over a support). Steps 1+3</p>
</blockquote>
<p>两个方法都假设屏幕是逐段的平滑。有时这个假设并不成立</p>
<p>局部算法隐式的假设，全局算法显式的进行假设</p>
<p>实际上，直接对一点来进行匹配，百分百会出现各种各样的问题，这个时候我们选择用一个固定窗口来替代一点，如下图所示。Warning,这样做就隐含了一个假设，认为窗口内部视差值相同，但是，显然的，这种假设太过想当然，也使得算法实际效果不好。</p>
<p><img src="https://i.loli.net/2020/03/29/JO5B36srdezMhLE.png" alt="image-20191220160220994"></p>
<p><img src="https://i.loli.net/2020/03/29/AI9FgxoERXMOGdj.png" alt="image-20191220113042597"></p>
<p><img src="https://i.loli.net/2020/03/29/VKzC7keTPbHntOR.png" alt="image-20191220113011574"></p>
<p>常用的聚合方式包括，SSD的直接求和、DP搜索等等。SGBM用到的就是多方向DP搜索方法</p>
<p><img src="https://i.loli.net/2020/03/29/LcZkbJvSgmuRCzr.png" alt="image-20191220113421395"></p>
<p>最小值{求当前像素与右边像素的差值的最小值，求当前像素与左边像素的最小值}</p>
<p><img src="https://i.loli.net/2020/03/29/2dTaJ4kSLPsqYwO.png" alt="image-20191220142057081"></p>
<p>DSI是一个三维矩阵，每一个元素代表左边参考像素的光照强度与右边目标像素滑动距离d的光照强度之差</p>
<p>固定窗口为什么会表现的不尽如人意呢？</p>
<p><img src="https://i.loli.net/2020/03/29/4JWyClMSIPQdDKo.png" alt="image-20191220142653422"></p>
<p>1.是因为固定窗口只会在前表面平行的进行移动，然而很多情况是物体表面是凹凸不平的，有时候物体是倾斜的，理想的情况是窗口也是倾斜的。</p>
<p>2.是因为固定窗口忽视了深度的不连续，在一个窗口内就有两种不同深度的背景</p>
<p><img src="https://i.loli.net/2020/03/29/ZAserD1ohnIYtzx.png" alt="image-20191220143111375"></p>
<p><img src="https://i.loli.net/2020/03/29/tcJA3rQspfKbYG8.png" alt="image-20191220143129084"></p>
<p>理想的cost aggregation strategy 应该尽可能的扩展具有相同深度的像素到它的区域里</p>
<p><img src="https://i.loli.net/2020/03/29/JshpvSeCFaMHWyz.png" alt="image-20191220143400586"></p>
<p><img src="https://i.loli.net/2020/03/29/TuWz7rU1gIAbtaF.png" alt="image-20191220145500641"></p>
<p><img src="https://i.loli.net/2020/03/29/1GKs75YTejSfZqo.png" alt="image-20191220151510820"></p>
<p>匹配代价计算是整个立体匹配算法的基础，实际是对不同视差下进行灰度相似性测量。常见的方法有灰度差的平方SD（squared intensity differences），灰度差的绝对值AD（absolute intensity differences）等。另外，在求原始匹配代价时可以设定一个上限值，来减弱叠加过程中的误匹配的影响。以AD法求匹配代价为例，可用下式进行计算，其中T为设定的阈值。</p>
<p><img src="https://i.loli.net/2020/03/30/XCAEOnS5UhcoK8H.png" alt="image-20191220110712285"></p>
<h1 id="QT-KITTI"><a href="#QT-KITTI" class="headerlink" title="QT  KITTI"></a>QT  KITTI</h1><p>其中：</p>
<ul>
<li>S_xx：1x2 矫正前的图像xx的大小</li>
<li>K_xx：3x3 矫正前摄像机xx的校准矩阵</li>
<li>D_xx：1x5 矫正前摄像头xx的失真向量</li>
<li>R_xx：3x3 （外部）的旋转矩阵(从相机0到相机xx)</li>
<li>T_xx：3x1 （外部）的平移矢量(从相机0到相机xx)</li>
<li>S_rect_xx：1x2 矫正后的图像xx的大小</li>
<li>R_rect_xx：3x3 纠正旋转矩阵(使图像平面共面)</li>
<li>P_rect_xx：3x4 矫正后的投影矩阵</li>
</ul>
<p>S_00: 640 480</p>
<p>DEFAULT_CAM_TO_CAM_TXT_PATH //<br>DEFAULT_IMU_TO_VELO_TXT_PATH //<br>DEFAULT_VELO_TO_CAM_TXT_PATH //<br>    读取了一个时间戳image_timestamp_files<br>    image_00 //left camera<br>    image_01 //right camera</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acewzj.github.io/2019/12/18/2019-12-02-EverNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="acewzj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acewzj">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/18/2019-12-02-EverNote/" itemprop="url">印象笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-18T10:16:18+08:00">
                2019-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>这篇文章主要记述了之前记录于印象笔记里的一些内容。</p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>1.先生成秘钥</p>
<p>ssh-keygen -t rsa -C “<a href="mailto:xxxxx@xxxxx.com">xxxxx@xxxxx.com</a>“  </p>
<p># Generating public/private rsa key pair…</p>
<p># 三次回车即可生成 ssh key</p>
<ol>
<li>$ git clone “SSH地址”</li>
<li>#git pull origin master</li>
<li>#git add .</li>
<li>#git commit -m ‘init’</li>
<li>#git push origin master</li>
<li>git checkout -b ‘name’</li>
</ol>
<p><a href="https://www.cnblogs.com/riverdubu/p/6491944.html" target="_blank" rel="noopener">https://www.cnblogs.com/riverdubu/p/6491944.html</a></p>
<h2 id="传递参数的方法："><a href="#传递参数的方法：" class="headerlink" title="传递参数的方法："></a><strong>传递参数的方法：</strong></h2><p>1.Params</p>
<p>由于动态路由也是传递params的，所以在 this.$router.push() 方法中path不能和params一起使用，否则params将无效。需要用name来指定页面。</p>
<p>及通过路由配置的name属性访问</p>
<p><strong>在路由配置文件中定义参数：</strong></p>
<p><img src="https://i.loli.net/2020/03/30/lYf4VonRmkptNLS.png" alt="image-20191218170051967"></p>
<p><strong>通过name获取页面，传递params：</strong></p>
<p><img src="https://i.loli.net/2020/03/30/Vb6jedOBaAEZDfF.png" alt="image-20191218170126558"></p>
<p><strong>在目标页面通过this.$route.params获取参数：</strong></p>
<p><img src="https://i.loli.net/2020/03/30/9O2HjZEFt15lRJa.png" alt="image-20191218170146300"></p>
<p><strong>2.Query</strong></p>
<p><strong>页面通过path和query传递参数，该实例中row为某行表格数据</strong></p>
<p><img src="https://i.loli.net/2020/03/30/F6tmPowgrpLNlkC.png" alt="image-20191218170211945"></p>
<p><strong>在目标页面通过this.$route.query获取参数：</strong></p>
<p><strong>this</strong>.<strong>$route</strong>.query.row.xxx</p>
<h2 id="前端设计"><a href="#前端设计" class="headerlink" title="前端设计"></a>前端设计</h2><p><img src="https://i.loli.net/2020/03/30/oHqOlGZWaPI7wV9.png" alt="1576645387066"></p>
<p>padding就是与上一个父级元素的距离</p>
<p><img src="https://i.loli.net/2020/03/30/xsRetKAzTHUhvPn.png" alt="1576645411047"></p>
<p><img src="https://i.loli.net/2020/03/30/pzYWPd9mtyocbv1.png" alt="1576645429672"></p>
<p><img src="https://i.loli.net/2020/03/30/9Tu28hnrdx1QwBO.png" alt="1576645651793"></p>
<p><img src="https://i.loli.net/2020/03/30/vMXHlc7rGIySqoT.png" alt="1576645676226"></p>
<p><img src="https://i.loli.net/2020/03/30/Oemg4sIZLdTvlRP.png" alt="1576645705677"></p>
<p><img src="https://i.loli.net/2020/03/30/EwcmQ8r2un9Zbtg.png" alt="1576645725576"></p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>1.连接</p>
<p>进入bin，win+R cmd 输入net start mysql</p>
<p>2 输入 </p>
<p>mysql -h 127.0.0.1 -u root -p</p>
<p>password:root</p>
<p>查看所有的数据库,输入“show databases；”，注意一定要加上分号，因为mysql中是以分号来标志结束的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span>(userId <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,username <span class="built_in">varchar</span>(<span class="number">20</span>),passwd <span class="built_in">varchar</span>(<span class="number">20</span>),email <span class="built_in">varchar</span>(<span class="number">30</span>),grade <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'admin'</span>,<span class="string">'admin'</span>,<span class="string">'admina@163.com'</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'acewzj'</span>,<span class="string">'123'</span>,<span class="string">'acewzj@dlmu.edu.cn'</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<p>J2EE连接MySQL</p>
<p><img src="https://i.loli.net/2020/03/30/QfXIMVjSAecqsnw.png" alt="1576645570723"></p>
<p><img src="https://i.loli.net/2020/03/30/4Hd1ReOoLbNYmrB.png" alt="1576645588344"></p>
<p><img src="https://i.loli.net/2020/03/30/hUPfin6mLK5ODXj.png" alt="1576645597943"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//URL指向要访问的数据库名mydata</span><br><span class="line"></span><br><span class="line">​         String url = "jdbc:mysql://localhost:3306/test";</span><br><span class="line"></span><br><span class="line">​        //MySQL配置时的用户名</span><br><span class="line"></span><br><span class="line">​         String user = "root";</span><br><span class="line"></span><br><span class="line">​       //MySQL配置时的密码</span><br><span class="line"></span><br><span class="line">​         String password = "root";</span><br><span class="line"></span><br><span class="line">​      </span><br><span class="line"></span><br><span class="line">​       //1.加载驱动程序</span><br><span class="line"></span><br><span class="line">​       Class.forName("com.mysql.jdbc.Driver");</span><br><span class="line"></span><br><span class="line">​       </span><br><span class="line"></span><br><span class="line">​         //2.getConnection()方法，连接MySQL数据库！！</span><br><span class="line"></span><br><span class="line">​         Connection ct =  DriverManager.getConnection(url,user,password);</span><br><span class="line"></span><br><span class="line">​         //3.创建statement</span><br><span class="line"></span><br><span class="line">​         Statement sm = ct.createStatement();</span><br><span class="line"></span><br><span class="line">​         //4.查询</span><br><span class="line"></span><br><span class="line">​         ResultSet rs = sm.executeQuery("<span class="keyword">select</span> passwd <span class="keyword">from</span> <span class="keyword">users</span>  <span class="keyword">where</span> username=<span class="string">'" + u + "'</span><span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">create table users(</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">userid bigint primary key auto_increment,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">username varchar(30) not null unique,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">truename varchar(30) not null,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">passwd varchar(30) not null,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">email varchar(40)not null,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">phone varchar(20)not null,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">address varchar(30)not null,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">postcode char(6),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">grade int default 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">)AUTO_INCREMENT = 1;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">create table students(</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuPointer bigint primary key auto_increment,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuDepartment varchar(20),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuMajor varchar(20),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuGrade varchar(5),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">className varchar(20),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuNum varchar(10),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuName varchar(10),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuNamePinyin varchar(20),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuId varchar(18),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuGender varchar(2),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuNation varchar(6),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuBirth varchar(8),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stuPolitic varchar(5)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">)AUTO_INCREMENT = 1;</span></span><br></pre></td></tr></table></figure>



<p>如何将excel中的数据导入到mysql数据库中？</p>
<p>1，在mysql中新建一个和Excel表头一样的表。注意如果是中文的话，一个varchar存储一个中文字符，但是如果编码方式选择了utf-8，则一个varchar占据3个字节数据，如果是gb2312则占据两个字节数据</p>
<p>2，将Excel表只剩下数据另存为CSV（逗号分隔），然后使用记事本打开并且另存为utf-8格式</p>
<p>3，通过import wizard 导入CSV文件中的数据</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>从理论上来说，这三个概念很容易背的滚瓜烂熟，但是从大学毕业到现在，我都没真正搞明白这三个东西的出现，究竟是为了做到什么事情。</p>
<p>也许之前我很少写代码，更很少写面向对象的代码，即使有写多半也很容易写回到面向过程的老路上去。在写面向过程的代码的时候，根本不管什么函数重载和覆盖，想到要什么功能就变得法子的换个函数名字，心里想想：反正函数重载本质也就是入栈了两个不同的函数。</p>
<p>知道后来我才慢慢了解，这些概念的出现，完全就不是为了编程的功能实现，而是编程的易用和扩展，准确的来说是方便再次开发而提出的一种标准而已。如果仅仅只要写个自己用的功能性的程序，那的确可以用不到上面这些麻烦的东西。</p>
<p>回过头来讲，让我了解标题这三个概念的实际用处，还是在于我这第四次重写毕业论文的代码，将它改写成面向对象的时候，才理解的。在面向对象设计的过程中，类是从抽象逐渐具体起来的，父类可以是非常非常抽象的东西，而最终实例化的子类就非常具体了。在这个继承的过程中，不断的对父类进行填充丰富，最终得到的子类就是有血有肉的 - 我的理解。</p>
<p>虚函数的意义，就在于定义了一个从最早的父类，到最后的子类，都必须具备的一个功能（函数），只是在不断的进化（继承）中，这个功能会略微发生改变。通过虚函数，我们在调用不同的衍生类的时候，可以拥有不同的功能。然后我会说：这么麻烦，干脆每个继承类都重写命名一个函数么算了，只要知道重命名的函数有这个功能就行了不是？理论上来说，完全可以，在一个父类和其继承类不多的项目中，这么做完全可以，只要你自己能熟记或者找到这个重命名函数是干嘛用的；但是在大一点的项目中，由于类中的函数成百上千，恐怕你就会为此疯狂。另外还有一点，是重命名函数无法做到的，这一点我会在纯虚函数中一并解释。</p>
<p>纯虚函数，就是虚函数了以后，末尾还要加=0的那一类函数。我一直没想通的是，既然这个函数完全没有实现方法，那么定义这个函数有个蛋用啊？我也曾经试着在网上搜索过纯虚函数的意义和作用，回答大多千篇一律照本宣科。于是我渐渐的也就无视这个纯虚函数了。直到现在我开始写一个PSO算法的时候，才发现天哪这居然是一个完全不可或缺的东西！如果说虚函数还可以用重命名作为另外一种解决方法，那么纯虚函数则是没有第二种可以替代的方法。我可以拿一个非常简单的代码说明一下：</p>
<p>class test{ public: virtual void print(); virtual void order()=0; int array[20]; };</p>
<p>上面声明了一个非常简单的类，它只有两个函数，其中一个是虚函数：打印，另外一个是纯虚函数：排序。其中打印函数的定义如下</p>
<p>void test::print(){ order(); printf(‘打印结果： ‘); for(int i=0; i&lt;20; i++) printf(‘%d ‘, array); }</p>
<p>在这个打印函数中，调用了order函数对array进行了排序，然后输出结果。问题是：我根本不知道order函数是什么算法，或者说order函数因人而异，所以无法确定！于是网上照本宣科的内容就出来：当函数没有实现方法或者需要子类来定义实现方法的时候，可以在父类中定义纯虚函数。就是这么简单！于是当不同的子类继承这个父类的时候，定义不同的实现方法，那么实例化这个子类的时候，这个纯虚函数就有了不同的方法。这也解释了为什么包含纯虚函数的抽象类为什么不能实例化，因为它中间有函数根本不知道是怎么个实现！当然我们可以用其他方法避免使用纯虚函数，比方说在子类中重写print方法，但是这样一来等于除了order函数代码以外所有的代码都要重新复制一遍，当继承类越来越多的时候，要修改print等于这一堆继承类都要修改，会疯的！所以说纯虚函数是一个很神奇的用法，也是简化了编程使得面向对象的方法更加灵活。</p>
<p>至于接口，这是一个只有JAVA中才用到的概念，C++中不存在接口，与接口相似的是：抽象类。因为JAVA不允许多重继承类，但可以继承多个接口。关于接口，在我编写JAVA SERVLET的时候，碰到过一个httpservlet，用户需要为doget和dopost等函数编写实现方法。而这些函数就可以看成是纯虚函数，它在HTTPservlet也类似于上述代码的order函数，有着在局部函数中的作用。</p>
<p>面向对象编程确实很有意思，虽然从某种程度上来说，和面向过程也差不多，但是灵活多变的设计方法，也许也是C++（面向对象）比C（面向过程）强大的地方</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><a href="https://baike.baidu.com/item/JSON" target="_blank" rel="noopener">JSON</a>(<a href="https://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener">JavaScript</a> Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。 存储时，通过<strong>JSON.stringify()</strong>将对象转换为文本格式；读取时，通过<strong>JSON.parse()</strong>将文本转换回对象。</p>
<p>简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在函数之间轻松地传递这个字符串，或者在异步应用程序中将字符串从 Web 客户机传递给服务器端程序。这个字符串看起来有点儿古怪，但是JavaScript很容易解释它，而且 JSON 可以表示比”名称 / 值对”更复杂的结构。</p>
<p>对象：对象在 JS 中是使用花括号包裹 {} 起来的内容，数据结构为 {key1：value1, key2：value2, …} 的键值对结构。在面向对象的语言中，key 为对象的属性，value 为对应的值。键名可以使用整数和字符串来表示。值的类型可以是任意类型。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var text = '&#123;"employees":[' +</span><br><span class="line"></span><br><span class="line">​    '&#123;"name":"菜鸟教程","site":"[http://www.runoob.com](http://www.runoob.com/)" &#125;,' +</span><br><span class="line"></span><br><span class="line">​    '&#123;"name":"Google","site":"[http://www.Google.com](http://www.google.com/)" &#125;,' +</span><br><span class="line"></span><br><span class="line">​    '&#123;"name":"Taobao","site":"[http://www.taobao.com](http://www.taobao.com/)" &#125;]&#125;';</span><br><span class="line"></span><br><span class="line">obj = JSON.parse(text);</span><br><span class="line"></span><br><span class="line">document.getElementById("demo").innerHTML =</span><br><span class="line"></span><br><span class="line">​    obj.employees[0].name + " " + obj.employees[1].site;</span><br></pre></td></tr></table></figure>



<h2 id="站群系统"><a href="#站群系统" class="headerlink" title="站群系统"></a>站群系统</h2><p>站群系统就是一网站的集合，但是一定要统一，分级管理，信息共享，<a href="https://baike.baidu.com/item/单点登录/4940767" target="_blank" rel="noopener">单点登录</a>才可以。最初的<a href="https://baike.baidu.com/item/站群" target="_blank" rel="noopener">站群</a>由政府提出，现在已经应用领域范围很广，例如政府门户网站群、大型企事业网站群、行业网站群等。</p>
<p><a href="https://baike.baidu.com/item/站群" target="_blank" rel="noopener">站群</a>通常由几个到几百个网站组成，站群最简单的理解就是一群网站。而这些网站都是属于一个人的。那么这些网站就称之为此站长的站群。</p>
<p>站群，即一个人或一个团队操作多个网站，目的是通过搜索引擎获得大量流量，或者是将链接指向同一个网站，以提高搜索排名。</p>
<p>J2EE是一套全然不同于传统应用开发的技术架构，包含许多组件，主要可简化且规范应用系统的开发与部署，进而提高可移植性、安全与再用价值。</p>
<p>J2EE（Java 2 Platform, Enterprise Edition）是一个为大企业主机级的计算类型而设计的Java平台。Sun微系统（与其工业伙伴一起，例如IBM）设计了J2EE，以此来简化在受客户级环境下的应用开发。由于创造了标准的可重用模块组件以及由于构建出能自动处理编程中多方面问题的等级结构，J2EE简化了应用程序的开发，也降低了对编程和对受训的程序员的要求。</p>
<p><a href="https://baike.baidu.com/item/Sun公司" target="_blank" rel="noopener">Sun公司</a>在1998年发表JDK1.2版本的时候， 使用了新名称Java 2 Platform，即“Java2平台”，修改后的JDK称为Java 2 Platform Software Develping Kit，即<a href="https://baike.baidu.com/item/J2SDK" target="_blank" rel="noopener">J2SDK</a>。并分为标准版(Standard Edition，<a href="https://baike.baidu.com/item/J2SE" target="_blank" rel="noopener">J2SE</a>), 企业版(Enterprise Edition，J2EE)，微型版(MicroEdition，<a href="https://baike.baidu.com/item/J2ME" target="_blank" rel="noopener">J2ME</a>)。J2EE便由此诞生。</p>
<p>java包含三大分支:</p>
<p><a href="https://www.baidu.com/s?wd=手机游戏&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLryDLuj0vm19buyDkPh7b0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH63PWT3n1bs" target="_blank" rel="noopener">手机游戏</a></p>
<p>3.<a href="https://www.baidu.com/s?wd=J2EE&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLryDLuj0vm19buyDkPh7b0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH63PWT3n1bs" target="_blank" rel="noopener">J2EE</a> –java Enterprise Editon –一般为<a href="https://www.baidu.com/s?wd=服务器端&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLryDLuj0vm19buyDkPh7b0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH63PWT3n1bs" target="_blank" rel="noopener">服务器端</a>程序的应用:例如JSP站点!</p>
<p>Web服务器一般指网站服务器，是指驻留于<a href="https://baike.baidu.com/item/因特网" target="_blank" rel="noopener">因特网</a>上某种类型计算机的程序，可以向浏览器等Web客户端提供文档，[1]  也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个Web服务器是Apache Nginx IIS</p>
<p>Web服务器可以解析（handles)HTTP协议。当Web服务器接收到一个HTTP请求（request），会返回一个HTTP响应（response），例如送回一个HTML页面。为了处理一个请求（request），Web服务器可以响应（response）一个<a href="https://baike.baidu.com/item/静态页面" target="_blank" rel="noopener">静态页面</a>或图片，进行页面跳转(redirect），或者把动态响应（dynamic response）的产生委托（delegate）给一些其它的程序例如CGI脚本，JSP(JavaServer Pages）脚本，servlets，ASP(Active Server Pages）脚本，服务器端（server-side)JavaScript，或者一些其它的服务器端（server-side）技术。无论它们（译者注：脚本）的目的如何，这些服务器端（server-side）的程序通常产生一个HTML的响应（response）来让浏览器可以浏览。</p>
<p>要知道，Web服务器的代理模型（delegation model）非常简单。当一个请求（request）被送到Web服务器里来时，它只单纯的把请求（request）传递给可以很好的处理请求（request）的程序（译者注：服务器端脚本）。Web服务器仅仅提供一个可以执行服务器端（server-side）程序和返回（程序所产生的）响应（response）的环境，而不会超出职能范围。服务器端（server-side）程序通常具有事务处理（transaction processing），数据库连接（database connectivity）和消息（messaging）等功能。</p>
<p>虽然Web服务器不支持事务处理或<a href="https://baike.baidu.com/item/数据库连接池" target="_blank" rel="noopener">数据库连接池</a>，但它可以配置（employ）各种策略（strategies）来实现<a href="https://baike.baidu.com/item/容错性" target="_blank" rel="noopener">容错性</a>（fault tolerance）和可扩展性（scalability），例如<a href="https://baike.baidu.com/item/负载平衡" target="_blank" rel="noopener">负载平衡</a>（load balancing），缓冲（caching）。集群特征（clustering—features）经常被误认为仅仅是应用程序服务器专有的特征。</p>
<p><img src="https://i.loli.net/2020/03/30/EadoOnWz3FHrhSX.png" alt="1576646067050"></p>
<h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><p><img src="https://i.loli.net/2020/03/30/GikRcHbNUXpQ47t.png" alt="1576646789677"></p>
<p>两个进程进行通信最基本的一个前提是能够唯一的标示一个进程，在本地通信中可以用PID（Process ID）来唯一标示一个进程；但是网络中的两个进程PID冲突几率很大，我们知道IP层的IP地址可以唯一标示一台主机，而TCP层的协议和端口号可唯一的标示主机的一个进程，这样可以用IP地址+协议+端口号来唯一的标示网络中的一个进程。</p>
<ul>
<li><p>UDP：不靠谱的通信协议，不去理会数据是否传送到目的地，只管把数据打成包发送出去；</p>
</li>
<li><p>TCP：每次传输完成，等待一个应答，确保数据发送成功。</p>
</li>
<li><p>0-1024,端口是给操作系统用的，剩下的256*（256-1）给自己用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">​        setContentView(R.layout.main);</span><br><span class="line"></span><br><span class="line">​        startButton = (Button)findViewById(R.id.startListener);</span><br><span class="line"></span><br><span class="line">​        startButton.setOnClickListener(<span class="keyword">new</span> StartSocketListener());</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">class</span> <span class="title">StartSocketListener</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​           <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">​           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​                <span class="keyword">new</span> ServerThread().start();</span><br><span class="line"></span><br><span class="line">​           &#125;</span><br></pre></td></tr></table></figure>



<p>​    在实际应用中，当一个Activity结束前，如果需要保存状态，就在onsaveInsanceState中，将状态数据以key-value的形式放入到saveInsanceState中。这样，当一个Activity被创建时，就能从onCreate的参数saveInsanceState中获得状态数据。</p>
<p>​    状态这个参数在实现应用中有很大的用途，比如：一个游戏在退出前，保存一下当前游戏运行的状态，当下次开启时能接着上次的继续玩下去。再比如：电子书程序，当一本小说被阅读到第199页后退出了（不管是内存不足还是用户自动关闭程序），当下次打开时，读者可能已忘记了上次已阅读到第几页了，但是，读者想接着上次的读下去。如果采用saveInstallState参数，就很容易解决上述问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">服务器端代码如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​           <span class="comment">//声明一个ServerSocket对象</span></span><br><span class="line"></span><br><span class="line">​           ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">​           <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">​                <span class="comment">//创建一个ServerSocket对象，并让这个Socket在4567端口监听</span></span><br><span class="line"></span><br><span class="line">​                     serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">4567</span>);</span><br><span class="line"></span><br><span class="line">​                     <span class="comment">//调用ServerSocket的accept()方法，接受客户端所发送的请求</span></span><br><span class="line"></span><br><span class="line">​                     Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">​                     <span class="comment">//从Socket当中得到InputStream对象</span></span><br><span class="line"></span><br><span class="line">​                     InputStream inputStream = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">​                     <span class="keyword">byte</span> buffer [] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">​                     <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​                     <span class="comment">//从InputStream当中读取客户端所发送的数据</span></span><br><span class="line"></span><br><span class="line">​                     <span class="keyword">while</span>((temp = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">​                           System.out.println(<span class="keyword">new</span> String(buffer,<span class="number">0</span>,temp));</span><br><span class="line"></span><br><span class="line">​                     &#125;</span><br><span class="line"></span><br><span class="line">​                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">​                     <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"></span><br><span class="line">​                     e.printStackTrace();</span><br><span class="line"></span><br><span class="line">​                &#125;</span><br><span class="line"></span><br><span class="line">​                <span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">​                     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">​                           serverSocket.close();</span><br><span class="line"></span><br><span class="line">​                     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">​                           <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"></span><br><span class="line">​                           e.printStackTrace();</span><br><span class="line"></span><br><span class="line">​                     &#125;</span><br><span class="line"></span><br><span class="line">​                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">客户端代码如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">​                <span class="comment">//创建一个Socket对象，指定服务器端的IP地址和端口号</span></span><br><span class="line"></span><br><span class="line">​                Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.1.104"</span>,<span class="number">4567</span>);</span><br><span class="line"></span><br><span class="line">​                <span class="comment">//使用InputStream读取硬盘上的文件</span></span><br><span class="line"></span><br><span class="line">​                InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"f://file/words.txt"</span>);</span><br><span class="line"></span><br><span class="line">​                <span class="comment">//从Socket当中得到OutputStream</span></span><br><span class="line"></span><br><span class="line">​                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">​                <span class="keyword">byte</span> buffer [] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">​                <span class="keyword">int</span> temp = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">​                <span class="comment">//将InputStream当中的数据取出，并写入到OutputStream当中</span></span><br><span class="line"></span><br><span class="line">​                <span class="keyword">while</span>((temp = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">​                     outputStream.write(buffer, <span class="number">0</span>, temp);</span><br><span class="line"></span><br><span class="line">​                &#125;</span><br><span class="line"></span><br><span class="line">​                outputStream.flush();</span><br><span class="line"></span><br><span class="line">​           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">​                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"></span><br><span class="line">​                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">​           &#125;</span><br></pre></td></tr></table></figure>

<p>e为FileNotFoundException的对象<br> 当试图打开指定路径名表示的文件失败时，抛出此异常。<br> ——解决方法——————–<br> e 变量名，如果你不喜欢用 f，也是没关系的，主要可以用来获得一些异常的信息。<br> ——解决方法——————–<br> 简单地说，FileNotFoundException e，就相当于int e，或是Integer e；</p>
<p>声明一个变量而已。</p>
<p>printStackTrace()方法的意思是：在命令行打印异常信息在程序中出错的位置及原因。（这是白话解释，比较容易理解）</p>
<h2 id="premiere输出高清视频"><a href="#premiere输出高清视频" class="headerlink" title="premiere输出高清视频"></a>premiere输出高清视频</h2><p>在弹出的序列中选择HDV 720 25P的格式，这是一种常用格式。制作出来的视频尺寸是1280x720.</p>
<p>等制作完成后，选择【文件】–【导出】-【多媒体】。在弹出的导出设置中格式选择【H.264】，预设【HDTV 720P  25高品质】设置好后【导出】就可以了。</p>
<p><strong>常见的直线有三种扫描算法：DDA算法，中点画线法，Bresenham算法。下面来看看Bresenham算法。</strong></p>
<h2 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a><strong>Bresenham算法</strong></h2><p>过各行各列象素中心构造一组虚拟网格线。按直线从起点到终点的顺序计算直线与各垂直网格线的交点，然后根据误差项的符号确定该列象素中与此交点最近的象素。</p>
<p><img src="https://i.loli.net/2020/03/30/CLwiaVfpqB2vUOy.png" alt="1576647567737"></p>
<p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=73428e9a01016gnp&url=http://s1.sinaimg.cn/orignal/73428e9a4ca1c662241c0" target="_blank" rel="noopener"></a></p>
<p><strong>核心思想：</strong><br>假设：k=dy/dx。因为直线的起始点在象素中心，所以误差项d的初值d0＝0。<br> X下标每增加1，d的值相应递增直线的斜率值k，即d＝d＋k。一旦d≥1，就把它减去1，这样保证d在0、1之间。<br> 当d≥0.5时，最接近于当前象素的右上方象素（x+1,y+1）<br> 而当d&lt;0.5时，更接近于右方象素(x+1,y）</p>
<p>为方便计算，令<code>e＝d-0.5</code>，<br> e的初值为-0.5，增量为k。<br> 当e≥0时，取当前象素（xi，yi）的右上方象素（x+1,y+1）<br> 而当e&lt;0时，更接近于右方象素(x+1,y）</p>
<p>可以改用整数以避免除法。由于算法中只用到误差项的符号，因此可作如下替换：<br><code>e1 = 2*e*dx</code></p>
<p><strong>算法代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bresenhamline</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> x, y, dx, dy;</span><br><span class="line">  <span class="keyword">float</span> k, e;</span><br><span class="line">  dx = x1-x0, dy = y1- y0, k=dy/dx;</span><br><span class="line">  e=<span class="number">-0.5</span>, x=x0, y=y0;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=dx; i++)</span><br><span class="line">  &#123;    drawpixel (x, y, color);</span><br><span class="line">  x=x+<span class="number">1</span>，e=e+k;</span><br><span class="line">  <span class="keyword">if</span> (e&gt;=<span class="number">0</span>)</span><br><span class="line">  &#123; y++, e=e<span class="number">-1</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//或者将e扩大2dx倍；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bresenhamline</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> x, y, dx, dy;</span><br><span class="line"> <span class="keyword">float</span> k, e;</span><br><span class="line"> dx = x1-x0, dy = y1- y0, k=dy/dx;</span><br><span class="line"> e=-dx, x=x0, y=y0;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=dx; i++)</span><br><span class="line"> &#123; drawpixel (x, y, color);</span><br><span class="line"> x=x+<span class="number">1</span>，e=e+<span class="number">2</span>dy;</span><br><span class="line"> <span class="keyword">if</span> (e&gt;=<span class="number">0</span>)</span><br><span class="line"> &#123; y++, e=e<span class="number">-2</span>dx;&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/03/30/85ejMKYNJOnEBiF.png" alt="1576647586467"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acewzj.github.io/2019/12/16/2019-12-16-DockerMaven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="acewzj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acewzj">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/16/2019-12-16-DockerMaven/" itemprop="url">Docker</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-16T10:16:18+08:00">
                2019-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>这篇文章主要记述了docker容器的一些知识。</p>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p><img src="https://i.loli.net/2019/12/14/2IHTljsdOekP1VC.png" alt=""></p>
<p>–name 参数，这是给容器实例起了个名字方便后续的守护进程调用，如果不加这个参数会随机产生一个名字。如果加名字切记如果多次run会提示名字冲突，需要先删除之前run的实例。</p>
<ul>
<li><p>通过 <strong>docker ps -a</strong> 命令查看已经在运行的容器，然后使用容器 ID 进入容器。</p>
</li>
<li><p>使用“docker attach”命令进入container（容器）有一个缺点，那就是每次从container中退出到前台时，container也跟着退出了。要想退出container时，让container仍然在后台运行着，可以使用“docker exec -it”命令。每次使用这个命令进入container，当退出container后，container仍然在后台运行，命令使用方法如下：</p>
</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> exec -<span class="keyword">it </span>goofy_almeida /<span class="keyword">bin/bash</span></span><br><span class="line"><span class="keyword">goofy_almeida：要启动的container的名称</span></span><br></pre></td></tr></table></figure>

<p>/bin/bash：在container中启动一个bash shell</p>
<p>这样输入“exit”或者按键“Ctrl + C”退出container时，这个container仍然在后台运行，通过：<code>docker ps</code><br>就可以查找到</p>
<ul>
<li>elasticsearch 经常启动后退出，exit返回137，后来重启服务器就好了，推测可能跟虚拟内存有关，我的内存才2G。</li>
<li>docker: Error response from daemon: OCI runtime create failed: container_linux.go:346<strong>导致</strong>kibana安装失败</li>
</ul>
<p><img src="https://i.loli.net/2020/03/29/PmGn7tiMgNFvH3S.png" alt=""></p>
<p>这里有误应为<code>docker container cp ./mall.sql mysql:/</code></p>
<h4 id="让Docker支持http上传镜像"><a href="#让Docker支持http上传镜像" class="headerlink" title="让Docker支持http上传镜像"></a>让Docker支持http上传镜像</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">'&#123; "insecure-registries":["47.97.25.88:5000"] &#125;'</span> &gt; /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dockerHost&gt;http://47.97.25.88:2375&lt;/dockerHost&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Docker-Compose常用命令"><a href="#Docker-Compose常用命令" class="headerlink" title="Docker Compose常用命令"></a>Docker Compose常用命令</h2><h3 id="构建、创建、启动相关容器："><a href="#构建、创建、启动相关容器：" class="headerlink" title="构建、创建、启动相关容器："></a>构建、创建、启动相关容器：</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -d表示在后台运行docker-compose up -d</span></span><br></pre></td></tr></table></figure>

<h3 id="停止所有相关容器："><a href="#停止所有相关容器：" class="headerlink" title="停止所有相关容器："></a>停止所有相关容器：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="built_in">stop</span></span><br></pre></td></tr></table></figure>

<h3 id="列出所有容器信息："><a href="#列出所有容器信息：" class="headerlink" title="列出所有容器信息："></a>列出所有容器信息：</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker-compose ps</span></span><br></pre></td></tr></table></figure>

<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>为什么我已经有一个pom.xml了，每一个模块里面还有一个pom.xml?</p>
<ul>
<li><p>project：pom.xml的顶级元素。</p>
</li>
<li><p>groupId：指出创建这个工程的组织或团队的唯一标识。</p>
</li>
<li><p>plugins：插件。</p>
</li>
<li><p>artifactId：基本名称。</p>
</li>
<li><p>packaging：类型（如JAR、WAR、EAR等等），默认是JAR，所有带有子模块的项目的packaging</p>
<p>都为pom。</p>
</li>
<li><p>version：版本号。</p>
</li>
<li><p>modelVersion：指出POM使用哪个版本的对象模型。</p>
</li>
</ul>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>明白了反向代理，是通过nginx服务器代理，访问不同的域名不同的端口（多个服务器域名和端口不可能重复）之间转发，比如，我想用户访问域名为<a href="http://www.web.cn:8888，nginx会帮我转发请求到其中一个apache什么的web服务器，如果是www.java.cn:8080，nginx就帮我转发给其他一个tomcat服务器做处理。要做到这样多站点多域名的转发，我们只要配置一下nginx代理服务器的nginx.conf文件就可以了，可以直接在里面配置，也可以多建立几个conf文件，让nginx.conf文件include包含他们，系统会自动扫描那些conf文件。这样配置后，当我们访问某个域名时候，nginx会主动转发到配置那个域名的conf文件，里面的root配置的就是服务器指向的项目运行根目录，或者配置反向代理proxy_pass">www.web.cn:8888，nginx会帮我转发请求到其中一个apache什么的web服务器，如果是www.java.cn:8080，nginx就帮我转发给其他一个tomcat服务器做处理。要做到这样多站点多域名的转发，我们只要配置一下nginx代理服务器的nginx.conf文件就可以了，可以直接在里面配置，也可以多建立几个conf文件，让nginx.conf文件include包含他们，系统会自动扫描那些conf文件。这样配置后，当我们访问某个域名时候，nginx会主动转发到配置那个域名的conf文件，里面的root配置的就是服务器指向的项目运行根目录，或者配置反向代理proxy_pass</a> 转发的域名，这样就反向代理转发到你想转发的服务器路径。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部署多个应用</span></span><br><span class="line">docker run -p <span class="number">80</span>:<span class="number">80</span> --name nginxhtml \</span><br><span class="line">-v <span class="regexp">/mydata/</span>nginx<span class="regexp">/www/</span><span class="string">html:</span><span class="regexp">/usr/</span>share<span class="regexp">/nginx/</span>html \</span><br><span class="line">-v <span class="regexp">/mydata/</span>nginx<span class="regexp">/logs:/</span>var<span class="regexp">/log/</span>nginx  \</span><br><span class="line">-v <span class="regexp">/mydata/</span>nginx<span class="regexp">/conf:/</span>etc/nginx \</span><br><span class="line">-d <span class="string">nginx:</span><span class="number">1.10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原始的</span></span><br><span class="line">docker run -p <span class="number">10010</span>:<span class="number">80</span> --name nginxmall \</span><br><span class="line">-v <span class="regexp">/mydata/</span>nginx<span class="regexp">/html:/</span>usr<span class="regexp">/share/</span>nginx/html \</span><br><span class="line">-v <span class="regexp">/mydata/</span>nginx<span class="regexp">/logs:/</span>var<span class="regexp">/log/</span>nginx  \</span><br><span class="line">-v <span class="regexp">/mydata/</span>nginx<span class="regexp">/conf:/</span>etc/nginx \</span><br><span class="line">-d <span class="string">nginx:</span><span class="number">1.10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开启防火墙</span></span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">9200</span>/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h2 id="Linux查看某一端口被哪个进程占用"><a href="#Linux查看某一端口被哪个进程占用" class="headerlink" title="Linux查看某一端口被哪个进程占用"></a>Linux查看某一端口被哪个进程占用</h2><p><code>lsof -i:8080</code>lsof命令,即ls open files</p>
<p><code>netstat -tunpl | grep 端口号</code></p>
<h2 id="挖矿程序查杀"><a href="#挖矿程序查杀" class="headerlink" title="挖矿程序查杀"></a>挖矿程序查杀</h2><p>Linux的所有进程都保存在/proc/目录下，保存形式为：/proc/进程号。进入到进程号目录后，里面有一个cwd链接文件即指向的进程的的目录。</p>
<p><img src="https://i.loli.net/2020/03/30/bJABw2XkElynpzc.png" alt="image-20191223105729894"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acewzj.github.io/2019/12/02/2019-12-02-C++STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="acewzj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acewzj">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/02/2019-12-02-C++STL/" itemprop="url">C++ && STL 知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-02T10:16:18+08:00">
                2019-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>这篇文章主要记述了STL和一些算法和知识点。</p>
<h2 id="An-Overview-of-Programs-and-Programming-Languages"><a href="#An-Overview-of-Programs-and-Programming-Languages" class="headerlink" title="An Overview of Programs and Programming Languages"></a>An Overview of Programs and Programming Languages</h2><p><strong>Compiled languages</strong> are translated to the target machine’s native language by a program called a compiler. This can result in very fast code, especially if the compiler is effective at optimizing, however the resulting code may not port well across operating systems and the compilation process may take a while.<br><strong>Interpreted languages</strong> are read by a program called an interpreter and are executed by that program. While they are as portable as their interpreter and have no long compile times, interpreted languages are usually <em>much</em> slower than an equivalent compiled program.<br>Finally, <strong>just-in-time compiled</strong> (or JIT-compiled) languages are languages that are quickly compiled when programs written in them need to be run (usually with very little optimization), offering a balance between performance and portability.</p>
<p>High or Low Level Level, in this case, refers to how much the nature of the language reflects the underlying system. In other words, a programming language’s level refers to how similar the language is to a computer’s native language. The higher the level, the <em>less</em> similar it is.<br>A <strong>low-level language</strong> is generally quite similar to machine code, and thus is more suitable for programs like device drivers or very high performance programs that really need access to the hardware. Generally, the term is reserved for machine code itself and assembly languages, though many languages offer low-level elements. Since a low-level language is subject to all the nuances of the hardware it’s accessing, however, a program written in a low-level language is generally difficult to port to other platforms. Low level languages are practically never interpreted, as this generally defeats the purpose.<br>A <strong>high-level language</strong> focuses more on concepts that are easy to understand by the human mind, such as objects or mathematical functions. A high-level language usually is easier to understand than a low-level language, and it usually takes less time to develop a program in a high-level language than it does in a low-level language. As a trade-off one generally needs to sacrifice some degree of control over what the resulting program actually does. It is not, however, impossible to mix high-level and low-level functionality in a language.</p>
<p>Type System</p>
<p>A <strong>type system</strong> refers to the rules that the different types of variables of a language have to follow. Some languages (including most assembly languages) do not have types and thus this section does not apply to them. However, as most languages (including C++) have types, this information is important.</p>
<ul>
<li><strong>Type Strength: Strong or Weak</strong><br>A strong typing system puts restrictions on how different types of variables can be converted to each other without any converting statements. An ideal strong typing system would forbid implicit “casts” to types that do not make any sense, such as an integer to a Fruit object. A weak typing system would try to find some way to make the cast work.</li>
</ul>
<ul>
<li><strong>Type Expression: Manifest or Inferred</strong><br>This deals with how the compiler/interpreter for a language infers the types of variables. Many languages require variables’ types to be explicitly defined, and thus rely on manifest typing. Some however, will infer the type of the variable based on the contexts in which it is used, and thus use inferred typing.</li>
</ul>
<ul>
<li><strong>Type Checking: Static or Dynamic</strong><br>If a language is statically typed, then the compiler/interpreter does the type checking once before the program runs/is compiled. If the language is dynamically type checked, then the types are checked at run-time.</li>
</ul>
<ul>
<li><strong>Type Safety: Safe or Unsafe</strong><br>These refer to the degree to which a language will prohibit operations on typed variables that might lead to undefined behavior or errors. A safe language will do more to ensure that such operations or conversions do not occur, while an unsafe language will give more responsibility to the user in this regard.</li>
</ul>
<p>These typing characteristics are not necessarily mutually exclusive, and some languages mix them.</p>
<h2 id="The-Features-of-C-as-a-Language"><a href="#The-Features-of-C-as-a-Language" class="headerlink" title="The Features of C++ as a Language"></a>The Features of C++ as a Language</h2><p>Now that all the necessary theory has been covered, now it is possible to explain what C++ has to offer as a programming language. C++…</p>
<ul>
<li>…is an open ISO-standardized language.<br>For a time, C++ had no official standard and was maintained by a de-facto standard, however since 1998, C++ is standardized by a committee of the ISO. Their page may be accessed <a href="http://www.open-std.org/jtc1/sc22/wg21/" target="_blank" rel="noopener">here</a>.</li>
</ul>
<ul>
<li>…is a compiled language.<br>C++ compiles directly to a machine’s native code, allowing it to be one of the fastest languages in the world, if optimized.</li>
</ul>
<ul>
<li>…is a strongly-typed unsafe language.<br>C++ is a language that expects the programmer to know what he or she is doing, but allows for incredible amounts of control as a result.</li>
</ul>
<ul>
<li>…supports both manifest and inferred typing.<br>As of the latest C++ standard, C++ supports both manifest and inferred typing, allowing flexibility and a means of avoiding verbosity where desired.</li>
</ul>
<ul>
<li>…supports both static and dynamic type checking.<br>C++ allows type conversions to be checked either at compile-time or at run-time, again offering another degree of flexibility. Most C++ type checking is, however, static.</li>
</ul>
<ul>
<li>…offers many paradigm choices.<br>C++ offers remarkable support for procedural, generic, and object-oriented programming paradigms, with many other paradigms being possible as well.</li>
</ul>
<ul>
<li>…is <em>portable.</em><br>As one of the most frequently used languages in the world and as an open language, C++ has a wide range of <a href="http://www2.research.att.com/~bs/compilers.html" target="_blank" rel="noopener">compilers</a> that run on many different platforms that support it. Code that exclusively uses C++’s standard library will run on many platforms with few to no changes.</li>
</ul>
<ul>
<li>…is upwards compatible with C<br>C++, being a language that directly builds off C, is compatible with almost all C code. C++ can use C libraries with few to no modifications of the libraries’ code.</li>
</ul>
<ul>
<li>…has incredible library support.<br>A search for “library” on the popular project-management website <a href="http://www.sourceforge.net/" target="_blank" rel="noopener">SourceForge</a> will yield over 3000 results for C++ libraries. A link to the results of the search may be found <a href="http://sourceforge.net/directory/language:C%2B%2B/?q=library" target="_blank" rel="noopener">here</a>.</li>
</ul>
<p>STL有六种序列容器类型：</p>
<ul>
<li>1 Vector:相当于一个数组，在内存中分配一块连续的内存空间进行存储；STL内部实现时首先分配一个非常大的内存空间预备进行存储（可以通过capacity()函数返回其大小）</li>
<li>2 List：双向链表</li>
<li>3 Deque:双端队列<br>人们习惯上把程序员分三个等级，知其然，知其所以然，造其所以然</li>
</ul>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>hash也称散列，哈希。基本原理就是将<strong>任意长度</strong>的输入变成<strong>固定长度</strong>的输出。这个映射的规则就是哈希算法，而原始数据经过映射形成的二进制字符串就是哈希值。开发中的MD5和SHA都是历史悠久的哈希算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo md5(<span class="string">"This is a test md5!"</span>);</span><br><span class="line">//output <span class="number">2124968</span>af757ed51e7abecd04f98e</span><br></pre></td></tr></table></figure>



<h3 id="hash的优点"><a href="#hash的优点" class="headerlink" title="hash的优点"></a>hash的优点</h3><p>1 不能从hash值反向推导出原始的数据</p>
<p>2 输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值</p>
<p>3 哈希算法的执行效率要高效，长的文本也能快速的计算出哈希值</p>
<p>4 哈希算法的冲突概率要小</p>
<p>由于哈希的原理就是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间，根据鸽笼原理，一定会存在不同的输入被映射成相同输出的情况。</p>
<h3 id="hash碰撞的解决方案"><a href="#hash碰撞的解决方案" class="headerlink" title="hash碰撞的解决方案"></a>hash碰撞的解决方案</h3><p>前面提到了哈希算法是一定会有碰撞的，那么如果我们遇到了hash冲突需要解决的时候该怎么处理呢？常用的方法就是 <strong>链地址法</strong>和<strong>开放地址法</strong>。</p>
<p>开放地址法就是构造一个M的数组保存N个键值对（M&gt;N)。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所以方法统称为“开放地址法”。线性探测法，就是比较常见的一种实现方式。它的核心思想是当冲突发生时，顺序查看表的下一个单元，直到找到一个空单元或查遍全表。只要散列表足够大，空的散列地址总能找到。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>就是个数组，不能扩充。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>vector的增长是2倍2倍的扩充容量（capacity）,注意这里不是在原来的基础上成长：它是在另外的地方找一个两倍的空间然后一个一个元素搬过去。。。。。。所以vector的size是元素的数量，但是capacity却是扩充 的2的倍数。补充：容器的data指的是在内存中首元素的地址。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>list与vector不同，它是采用的环状双向链表</p>
<p>某些容器（如list）自带sort，这个要比全局的sort要快</p>
<p><img src="https://i.loli.net/2019/12/06/2eK3CMPjGTDgvmX.png" alt=""></p>
<p><img src="https://i.loli.net/2019/12/08/fK1yzJdoSA7VRWg.png" alt=""></p>
<p>c++中箭头运算符-&gt;，相当于把解引用和成员访问符两个操作符结合在一起，换句话说，</p>
<p>p-&gt;func()和(*p).func()所表示的意思一样。</p>
<p>地址-&gt;一个东西   <em>ite去解引用了ite这个地址<br>&amp;（</em>ite）又取回来这个地址</p>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>分段连续，类似于二维指针：由一个指针指向一个缓冲区</p>
<p><img src="https://i.loli.net/2019/12/02/G4CH2ypvqLIKT9M.png" alt=""></p>
<p><img src="https://i.loli.net/2019/12/08/qOHBIDR8TVUbaGp.png" alt=""></p>
<ul>
<li><p>这里：node指向deque的控制大脑，first指向某一段的开头，last指向某一段的结尾，前闭后开区间，cur指向当前的这一段里面的节点。当走到头时，会由node进行段的切换；</p>
</li>
<li><p>控制中心是一个vector。如果你想在前面插入的话，且前面空间不够了，你依旧也是需要开辟一个2倍原来空间的控制中心区域一个一个的拷贝构造一下。但是它很狡猾的拷贝到2倍区域的中段来，这样可以让首尾控制中心的扩充更为均衡一些；</p>
</li>
<li><p>start与finish指向的是deque中所有元素的首跟尾；</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/12/08/mDnCTt48ZzyhaXF.png" alt=""></p>
<ul>
<li><p>区分前++与后++的方法是：后++会传int的形参，这是规定</p>
</li>
<li><p>后++会生成一个临时的tmp对象，然后对原对象进行前++操作，再把tmp对象返回</p>
</li>
<li><h3 id="self的用处是？？？？？"><a href="#self的用处是？？？？？" class="headerlink" title="self的用处是？？？？？"></a>self的用处是？？？？？</h3></li>
</ul>
<p><img src="https://i.loli.net/2019/12/08/wAq2eMDOSRUjl5a.png" alt=""></p>
<p><img src="https://i.loli.net/2019/12/08/VQPYsLJjzCTWnfr.png" alt=""></p>
<p><img src="https://i.loli.net/2019/12/08/aKpUckOP2NVDQJl.png" alt="4.9"></p>
<p><img src="https://i.loli.net/2019/12/08/TQuPz1cew8p6atl.png" alt=""></p>
<p><img src="https://i.loli.net/2019/12/08/1ntR6YcLUVMK7WO.png" alt=""></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>multimap&lt;key,value&gt;//multi允许重复</p>
<p>snprintf(buf,10,”%d”,rand（）)；//如果格式化后的字符串长度 &gt;= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符(‘\0’)，返回值为欲写入的字符串长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line"> </span><br><span class="line">  i = <span class="built_in">snprintf</span>(a, <span class="number">13</span>, <span class="string">"%012d"</span>, <span class="number">12345</span>);  <span class="comment">// 第 1 种情况 12位宽</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i = %lu, a = %s\n"</span>, i, a);    <span class="comment">// 输出：i = 12, a = 000000012345</span></span><br><span class="line"> </span><br><span class="line">  i = <span class="built_in">snprintf</span>(a, <span class="number">9</span>, <span class="string">"%012d"</span>, <span class="number">12345</span>);   <span class="comment">// 第 2 种情况 0000 0001 2345</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i = %lu, a = %s\n"</span>, i, a);    <span class="comment">// 输出：i = 12, a = 00000001</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>c.insert(pair&lt;long,string&gt;(i,buf))</p>
<ul>
<li>multimap不可以用[作Insertion,map却可以，注意重复与不重复.</li>
</ul>
<h2 id="OOP：-amp-GP：Generic-Programming"><a href="#OOP：-amp-GP：Generic-Programming" class="headerlink" title="OOP：&amp;GP：Generic Programming"></a>OOP：&amp;GP：Generic Programming</h2><p>Object-Oriented-Programming</p>
<p>GP 可以使得两个团队可以专注于闭门造车</p>
<p>OOP相当于菜谱（数据相当于原材料，方法相当于烹饪步骤）</p>
<p>标准库用的全局的：：sort排序需要的是RandomAccessIterator，随机的迭代器，而list不能随意的像数组那样一下子蹦5个单元，所以List不能使用全局的：：sort排序。</p>
<h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><p>类模板与函数模板</p>
<p><img src="https://i.loli.net/2019/12/03/caYW31lkdThB7qR.jpg" alt=""></p>
<p><img src="https://i.loli.net/2019/12/03/NKdZD8fH1anhATQ.jpg" alt=""></p>
<p>类模板如果不进行<double> <int>的绑定，它不知道该给T初始化为多少？毕竟2.5初始化为float也行，初始化为double也行。</p>
<p>但是函数模板就不一样了，因为编译器可以进行类型推导，从r1那个Stone r1就可以推出T的类型，进而重载Stone类的&lt;操作符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;和下面相同  </span></span><br><span class="line"><span class="class"><span class="title">template</span>&lt;typename T&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">complex</span>&#123;</span>&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="泛化与特化"><a href="#泛化与特化" class="headerlink" title="泛化与特化"></a>泛化与特化</h2><ul>
<li>类模板中我可以通过T来形成各种各样的类的蓝图。但是如果你是一种特定的类型比如int，我可以提供给你一种更为有效的做法，这就叫做特化。</li>
</ul>
<p><img src="https://i.loli.net/2019/12/03/KFsXC3H18rieR4S.png" alt="特化"></p>
<ul>
<li><p>template&lt;&gt;有时候是__STL_TEMPLATE_NULL</p>
</li>
<li><p>以上是FULL 特化，还有偏特化    Partial Specialization</p>
<img src="https://i.loli.net/2019/12/03/w2KsNOf4ypomkzG.png" style="zoom:75%;" />







</li>
</ul>
<h2 id="traits"><a href="#traits" class="headerlink" title="traits"></a>traits</h2><p>  萃取，特征，一种人为制造的萃取机器：我丢给它一些东西，它可以萃取出我想要的特征</p>
<p>  iterator_category：描述了迭代器的性质：有的迭代器可以一往无前的向前冲++，有的还可以后退–，有的可以跳着走……</p>
<p>  diffrence_type：两个迭代器之间的距离用啥来表示？比如int表示你的容器的两个迭代器的距离范围最大是2^32。一般设为ptrdiff_t，是一个Unsigned long类型的</p>
<p>  value_type：迭代器所指的容器里面的元素的类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">inline</span></span><br><span class="line">Mat_&lt;_Tp&gt;::Mat_(<span class="keyword">int</span> _rows, <span class="keyword">int</span> _cols)</span><br><span class="line">    : Mat(_rows, _cols, traits::Type&lt;_Tp&gt;::value)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   traits::Type&lt;_Tp&gt;::value</p>
<p>我对这段话的理解是，cv::DataType&lt;&gt;是一个模板类，当OpenCV中库函数需要传递特定数据类型的某些概念信息时，那么就可以通过创建cv::DataType&lt;&gt; 类型的对象来实现。我们使用的不是它本身，而是它特定的实例化对象。C++中这种用法叫做Traits。</p>
<p>  说实话，第一次看这一篇章，我也没有看懂cv::DataType&lt;&gt;到底是做什么用的，不过下面讲解一下Traits后，就能明白上面说意思了。</p>
<p>  简单来说，如果我们封装了一个算法，这个算法可能会由于输入数据类型的不同导致算法内部处理逻辑的不同（比如说传入的是int类型我们做一种操作，而传入的是double类型我们将进行另外一种操作），而我们并不想由于这种原因修改算法的封装时，Traits就派上用场了，它可以帮我们很方便的实现功能，而又不破坏函数的封装。<br>  Traits在开发者中运用特别多，主要也就是为了解决用户的负担，让一些复杂逻辑处理留给开发者来做，用户只需要根据要求调用API函数即可。</p>
<p>  <a href="https://blog.csdn.net/XiangJiaoJun_/article/details/84843194![](https://i.loli.net/2019/12/06/5FO9TWbmznukGlx.png)" target="_blank" rel="noopener">https://blog.csdn.net/XiangJiaoJun_/article/details/84843194![](https://i.loli.net/2019/12/06/5FO9TWbmznukGlx.png)</a></p>
<h2 id="RB-Tree"><a href="#RB-Tree" class="headerlink" title="RB_Tree"></a>RB_Tree</h2><p>关联式容器。红黑树。散列表。</p>
<ul>
<li>红黑树的++操作类似于中序遍历，它是按照元素增大的顺序进行遍历的</li>
<li>我们不应该使用红黑树的迭代器进行修改值的操作：因为会破坏严谨的红黑树的平衡</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTree</span> &#123;</span></span><br><span class="line">	BinaryTree *Lchild;</span><br><span class="line">	BinaryTree *Rchild;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">&#125;BinaryTree;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Construct</span><span class="params">(BinaryTree **T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="number">-1</span>) &#123;</span><br><span class="line">		*T = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*T = (BinaryTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinaryTree));</span><br><span class="line">		<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"malloc failed!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			(*T)-&gt;data = ch;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入"</span> &lt;&lt; ch &lt;&lt; <span class="string">"的左子节点："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			Construct(&amp;((*T)-&gt;Lchild));</span><br><span class="line">			Construct(&amp;((*T)-&gt;Rchild));</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"BinaryTree Construct Stage..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	BinaryTree *Btree;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入二叉树第一个节点的值，-1代表叶子节点..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Construct(&amp;Btree);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BTree本来是一个指向BinaryTree的指针，</p>
<p>因为有小伙伴问了，可否在构建二叉树传入的参数为一级地址。上述的方法是一定要传二级参数的，但是这里给出一个传一级参数的方法，小伙伴也可以通过对比两种方法，对二叉树的构建和传参方式有更深的理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">Create</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val);</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> = (<span class="title">struct</span> <span class="title">TreeNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>*));</span></span><br><span class="line">	<span class="keyword">if</span> (val &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"创建失败\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		root-&gt;val = val;</span><br><span class="line">		root-&gt;left = Create();</span><br><span class="line">		root-&gt;right = Create();</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从文本读取数据C"><a href="#从文本读取数据C" class="headerlink" title="从文本读取数据C++"></a>从文本读取数据C++</h2><p>包含头文件#include <fstream></p>
<p>逐词读取</p>
<p>逐行读取</p>
<pre><code>ifstream filestream(&quot;text.txt&quot;);
if (filestream.is_open()) {

}</code></pre><p><img src="https://i.loli.net/2020/03/30/buXMqazylTYwIBL.png" alt="image-20191221120517828"></p>
<h2 id="C-编程技巧Tips"><a href="#C-编程技巧Tips" class="headerlink" title="C++编程技巧Tips"></a>C++编程技巧Tips</h2><ul>
<li><p>定义变量的时候可以不用缩进然后避免在开头集中定义，又方便查找—-侯捷</p>
</li>
<li><p>抽空研究一下快速排序，红黑树</p>
</li>
<li><p>：：find是循序查找， </p>
</li>
<li><p>关键字typedef在编译阶段有效，由于是在编译阶段，因此typedef有类型检查的功能。</p>
<p>#define则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。</p>
<p>typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。</p>
<p>#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p>
<p>#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。</p>
<p>而typedef有自己的作用域。</p>
</li>
</ul>
<ul>
<li>c++的一个语法：</li>
</ul>
<p>  将typedef和typename关键字联用。</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Alloc</span>=<span class="symbol">alloc</span>&gt;<span class="symbol">class</span> <span class="symbol">vector</span>&#123;<span class="keyword">public</span>:<span class="comment">//...typedef size_t size_type;//...&#125;;</span></span><br></pre></td></tr></table></figure>

<p>  从vector的类定义可以看出，<code>vector::size_type</code>是<code>vector</code>嵌套类型定义，其实际等价于 <code>size_t</code>类型。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type ssize;<span class="comment">//就等价于size_t ssize;</span></span><br></pre></td></tr></table></figure>

<p>  为什么要在typedef后面加上typename关键字？</p>
<p>  原因：</p>
<p>  实际上，模板类型在实例化之前，编译器并不知道<code>vector&lt;T&gt;::size_type</code>是什么东西，事实上一共有三种可能：</p>
<blockquote>
<p>静态数据成员<br>静态成员函数<br>嵌套类型</p>
</blockquote>
<p>  那么此时<code>typename</code>的作用就在此时体现出来了——定义就不再模棱两可。</p>
<p>  <code>typedef</code>创建了存在类型的别名，而<code>typename</code>告诉编译器<code>std::vector&lt;T&gt;::size_type</code>是一个类型而不是一个成员。</p>
<h2 id="C-string-成员函数-length-size-和-strlen-的区别"><a href="#C-string-成员函数-length-size-和-strlen-的区别" class="headerlink" title="C++ string 成员函数 length() size() 和 strlen() 的区别"></a>C++ string 成员函数 length() size() 和 strlen() 的区别</h2><p>sizeof()是运算符，在编译期间就计算好了，所以对于字符串来说会统计到‘\0’的个数。</p>
<p>而size()是由于string 毕竟也是一个容器，容器会为了统一都有一个size()函数</p>
<p>size()、length()是c++中string的类的方法，只有string类的对象才可以用该方法，而字符串数组不可用，而strlen、strcpy等源于C语言的字符串处理函数库，需要include&lt;string.h&gt;,同时也只有字符串数组才可以用<br>size()与length()完全等同，遇到空字符不会被截断，可以返回字符串真实长度<br>strlen(),源于C语言，遇到空字符会截断，从而无法返回字符串真实长度<br>strlen同样也可以用于C++的string。但是需要用c_str()将C++ string转换为char*类型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acewzj.github.io/2019/10/07/2019-10-07-HelloWorld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="acewzj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acewzj">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/07/2019-10-07-HelloWorld/" itemprop="url">HelloWorld的运行原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-07T10:16:18+08:00">
                2019-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>这篇文章主要介绍了HelloWorld的运行原理。</p>
<h1 id="HelloWorld的运行原理（不断更新）"><a href="#HelloWorld的运行原理（不断更新）" class="headerlink" title="HelloWorld的运行原理（不断更新）"></a>HelloWorld的运行原理（不断更新）</h1><p>一直都想搞明白printf(“HelloWorld！\n”)是怎么在屏幕上打印出来的，所以趁着中秋节尽可能的深挖一下。这篇文章会保持持续的更新。</p>
<h2 id="1-编译链接阶段"><a href="#1-编译链接阶段" class="headerlink" title="1. 编译链接阶段"></a>1. 编译链接阶段</h2><h3 id="1-1-预处理"><a href="#1-1-预处理" class="headerlink" title="1.1 预处理"></a>1.1 预处理</h3><p>首先，我们编写如下程序并命名为main.c。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv())</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"HelloWorld!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/09/13/WKjeIC2MX3Av7Zc.png" alt=""></p>
<p>输入<code>gcc -E main.c -o main.i</code> 进行预处理工作，在此处，选项”-o”是指输出目标文件为main.i</p>
<p>预编译的处理规则：</p>
<blockquote>
<p>将所有的 “#define” 删除，并展开所有的宏定义<br>处理所有的条件预编译指令，比如：” #if #ifdef #elif #else #endif “<br>处理所有的 “#include” 预编译指令<br>删除所有的注释 “//” 、 “/* */”<br>添加行号和文件名标识，以便编译时产生的行号信息以及用于编译错误或警告时能够显示行号<br>保留所有的 “#pragma” 编译器指令</p>
</blockquote>
<p>我们可以打开main.i看看，里面的头文件stdio.h已经被展开了，包括一些类型定义函数定义等等，截取片段如下:</p>
<p><img src="https://i.loli.net/2019/09/13/rY6jE8gQv25zSfi.png" alt=""></p>
<p>这里找到了printf的外部声明如下：</p>
<p><code>extern int printf (const char *__restrict __format, ...);</code></p>
<p>printf()函数的调用格式为:<code>printf(&quot;格式化字符串&quot;,输出表列)</code>。参考例子为<code>printf(&quot;%2c-%2c-%2c-%2c\n&quot;,&#39;D&#39;,&#39;e&#39;,&#39;m&#39;,&#39;o&#39;);</code></p>
<h3 id="1-2-编译-生成汇编代码-main-s"><a href="#1-2-编译-生成汇编代码-main-s" class="headerlink" title="1.2 编译(生成汇编代码 main.s)"></a>1.2 编译(生成汇编代码 main.s)</h3><p>编译过程是编译器gcc把预处理完的文件进行词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。使用命令<code>gcc -S main.i -o main.s</code>将前面预处理的main.i文件编译成汇编语言文件main.s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">        .file   &quot;main.c&quot;;</span><br><span class="line">        .text</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;HelloWorld!&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp;</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        subq    $16, %rsp</span><br><span class="line">        movl    %edi, -4(%rbp)</span><br><span class="line">        movq    %rsi, -16(%rbp)</span><br><span class="line">        leaq    .LC0(%rip), %rdi</span><br><span class="line">        call    puts@PLT</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  &quot;GCC: (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>

<p>我们发现printf函数调用被转化为call puts指令，而不是call printf指令，这好像有点出乎意料。不过不用担心，这是编译器对printf的一种优化。实践证明，对于printf的参数如果是以’\n’结束的纯字符串，printf会被优化为puts函数，而字符串的结尾’\n’符号被消除。除此之外，都会正常生成call printf指令。</p>
<p>puts()函数有两个特点:</p>
<ul>
<li>puts()在显示字符串时会自动在其末尾添加一个换行符。</li>
<li>puts()遇到空字符时就停止输出，所以必须确保有空字符。</li>
</ul>
<p>注意汇编程序由三个不同的元素组成：</p>
<blockquote>
<p><strong>指示（Directives）</strong> 以点号开始，用来指示对编译器，连接器，调试器有用的结构信息。指示本身不是汇编指令。例如，.file 只是记录原始源文件名。.data表示数据段(section)的开始地址, 而 .text 表示实际程序代码的起始。.string 表示数据段中的字符串常量。 .globl main指明标签main是一个可以在其它模块的代码中被访问的全局符号 。至于其它的指示你可以忽略。</p>
<p><strong>标签（Labels）</strong> 以冒号结尾，用来把标签名和标签出现的位置关联起来。例如，标签.LC0:表示紧接着的字符串的名称是 .LC0. 标签main:表示指令 pushq %rbp是main函数的第一个指令。按照惯例， 以点号开始的标签都是编译器生成的临时局部标签，其它标签则是用户可见的函数和全局变量名称。</p>
<p><strong>指令（Instructions）</strong> 实际的汇编代码 (pushq %rbp), 一般都会缩进，以便和指示及标签区分开来。</p>
</blockquote>
<blockquote>
<p><u>小贴士: AT&amp;T 语法和 Intel 语法</u><br><u>注意GNU工具使用传统的AT&amp;T语法。类Unix操作系统上，AT&amp;T语法被用在各种处理器上。Intel语法则一般用在DOS和Windows系统上。下面是AT&amp;T语法的指令：</u><br><u>movl %esp, %ebp</u><br><u>movl是指令名称。%则表明esp和ebp是寄存器.在AT&amp;T语法中, 第一个是源操作数,第二个是目的操作数。</u><br><u>在其他地方，例如interl手册，你会看到是没有%的intel语法, 它的操作数顺序刚好相反。下面是Intel语法:</u><br><u>MOVQ EBP, ESP</u><br><u>当在网页上阅读手册的时候，你可以根据是否有%来确定是AT&amp;T 还是 Intel 语法。</u></p>
</blockquote>
<p>每个寄存器都有其特殊用途，并不是所有指令都可以应用到每一个寄存器。随着设计的进展，新的指令和寻址模式被添加进来，使得很多寄存器变成了等同的。少数留下来的指令，特别是和字符串处理相关的，要求使用%rsi 和%rdi。另外，两个寄存器被保留下来分别作为栈指针 (%rsp) 和基址指针 (%rbp)。最后的8个寄存器是编号的并且没有特殊限制。多年来，体系结构从8位扩展到16位，32位，因此每个寄存器都有一些内部结构：</p>
<p><img src="https://i.loli.net/2019/09/13/IusO7Gy4AYmxJP1.png" alt=""></p>
<p>%rax的低8位是8位寄存器%al, 仅靠的8位是%ah。低16位是 %ax， 低32位是 %eax，整个64位是%rax。</p>
<p>寄存器%r8-%r15也有相同结构，但命名方式稍有不同：</p>
<p><img src="https://i.loli.net/2019/09/13/ijQqmTs2zOL8bk1.png" alt=""></p>
<h3 id="1-3-汇编-生成main-o文件"><a href="#1-3-汇编-生成main-o文件" class="headerlink" title="1.3 汇编(生成main.o文件)"></a>1.3 汇编(生成main.o文件)</h3><p>汇编是汇编器把汇编代码转变成中间目标文件。汇编过程可以使用如下命令：</p>
<p><code>gcc -c main.s -o main.o</code></p>
<p>main.o已经是二进制文件了，直接打开会发现乱码一片，我们可以用objdump或者gdb的反汇编指令打开obj文件，如下:</p>
<img src="https://i.loli.net/2019/09/13/FSuZDNRlPWMy49f.png" style="zoom:67%;" />

<p>？？目标文件是什么？</p>
<p>–目标文件是指编译器编译源代码后生成的二进制文件，再通过链接器和资源文件链接就成可执行文件了。OBJ只给出了程序的【相对地址】，而可执行文件是【绝对地址】。CPP对应的二进制代码格式obj，是未经重定位的！以下摘自《程序员的自我修养》</p>
<blockquote>
<p>现在PC平台流行的可执行文件格式(Executable)，主要是Windows下的PE（Portable Executable）和linux的ELF （Executable Linkable Format）,他们都是COFF（Common File Format）格式的变种。COFF是由Unix System VRelease 3首先提出并且使用的文件规范，后来微软公司基于COFF格式，制定了PE格式标准，并将其用于当时的Windows NT系统。System VRelease 4在COFF的基础上引入了ELF格式，目前流行的Linux系统也是以ELF作为基本的可执行文件格式。这也能解释为什么目前PE和ELF如此相似的主要原因，因为他们都是来源于同一种可执行文件格式COFF。目标文件就是源代码编译后为进行链接的那些中间文件（Windows下面为.obj文件；Linux下面为.o文件），它和可执行文件的内容和结构很相似，所以一般和可执行文件采用同一种格式进行存储。从广义上来讲，目标文件与可执行文件的格式其实几乎是一模一样的，所以，我们可以广义的将目标文件和可执行文件看成是同一种类型的文件。在Windows下，我们把目标文件和可执行文件都统一称为PE-COFF文件，在Linux下，我们把它们统称为ELF文件。<br>当然，事情没有这么简单!不光是可执行文件（Windows下面的.exe和Linux下面的ELF文件）按照可执行文件格式存储。动态链接库（DLL,dynamic linking library）[Windows下面的.dll文件和Linux下面的.a文件]以及静态链接库（Static linking Library）[Windows下面的.lib文件和Linux下面的.a文件]都是按照可执行文件格式存储的。只不过，在Windows平台下，他们按照PE-COFF格式存储，而在Linux平台下按照ELF格式进行储存。<br>ELF文件标准里面把系统中采用ELF格式的文件归为以下四类：</p>
<img src="https://i.loli.net/2019/09/14/qtUFRAal3iIfpOs.png" style="zoom:67%;" />

<img src="https://i.loli.net/2019/09/14/cRPbO1lq8dgYEAB.png" style="zoom:67%;" />

<p>假设上图的可执行文件格式是ELF，从图中可以看到，ELF文件的开头是一个“文件头”，他描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接以及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息。头文件包含一个段表（Section Table），段表事实是一个描述文件中各个段的数组。段表描述了文件中各个段在文件中的偏移位置及段的属性，从段表里面可以得到每个段的所有信息。文件头后面就是各个段的内容，比如代码段保存的就是程序的指令，数据段里面保存的就是程序的静态变量等。</p>
</blockquote>
<h3 id="1-4-链接（生成可执行程序）"><a href="#1-4-链接（生成可执行程序）" class="headerlink" title="1.4 链接（生成可执行程序）"></a>1.4 链接（生成可执行程序）</h3><p>链接器 ld：负责将程序的目标文件与所需的所有附加的目标文件连接起来，附加的目标文件包括静态连接库和动态连接库,链接是链接器ld把中间目标文件和相应的库一起链接成为可执行文件。</p>
<p><code>gcc main.o -o main</code></p>
<p><img src="https://i.loli.net/2019/09/14/63LkiSUlcRowJrD.png" alt=""></p>
<p>如果前面使用的是$ gcc main.c命令，默认会产生一个a.out 的可执行文件，使用命令./a.out执行该可执行文件</p>
<p>？？为什么会使用a.out作为名字？</p>
<p>– 《Expert C Programming》中提到它是<code>assembler output(汇编程序输出)</code>的缩写，默认使用a.out的名字是UNIX“没什么理由，但是我们就是这么做的”思维的一个例子。</p>
<h2 id="2-装载运行阶段"><a href="#2-装载运行阶段" class="headerlink" title="2. 装载运行阶段"></a>2. 装载运行阶段</h2><p>在之前我写程序一般到<code>./main</code>就已经结束了。看着<code>HelloWorld</code>被输出之后就不再往下挖了，但是今天我们继续往它的祖坟上刨刨，看看到底能挖多深？</p>
<h3 id="2-1-C语言内存模型及运行时内存布局"><a href="#2-1-C语言内存模型及运行时内存布局" class="headerlink" title="2.1 C语言内存模型及运行时内存布局"></a>2.1 C语言内存模型及运行时内存布局</h3><img src="https://i.loli.net/2019/09/06/DXrJUICwidhme6s.png" style="zoom:67%;" />

<h4 id="1、代码段（TEXT）"><a href="#1、代码段（TEXT）" class="headerlink" title="1、代码段（TEXT）"></a>1、代码段（TEXT）</h4><p>代码段由程序中执行的机器代码组成。在C语言中，程序语句执行编译后，形成机器代码。</p>
<h4 id="2、只读数据段-RO-Data"><a href="#2、只读数据段-RO-Data" class="headerlink" title="2、只读数据段(RO Data)"></a>2、只读数据段(RO Data)</h4><p>只读数据段由程序中所使用的数据产生，该部分数据的特点在运行中不需要改变，因此编译器会将数据放入只读的部分中。C语言的一些语法将生成只读数据数据段。以下情况将生成只读数据段。</p>
<h6 id="只读全局变量"><a href="#只读全局变量" class="headerlink" title="只读全局变量"></a>只读全局变量</h6><p>定义全局变量const  char a[100]=”abcdefg”将生成大小为100个字节的只读数据区，并使用字符串“abcdefg”初始化。如果定义为const char a[]=”abcdefg”,没有指定大小，将根据“abcdefgh”字串的长度，生成8个字节的只读数据段。</p>
<h6 id="只读局部变量"><a href="#只读局部变量" class="headerlink" title="只读局部变量"></a>只读局部变量</h6><p>例如：在函数内部定义的变量const char  b[100]=”9876543210”;其初始化的过程和全局变量。</p>
<h6 id="程序中使用的常量"><a href="#程序中使用的常量" class="headerlink" title="程序中使用的常量"></a>程序中使用的常量</h6><p>例如：在程序中使用printf(“HelloWorld\n”),其中包含了字串常量，编译器会自动把常量“HelloWorld \n”放入只读数据区。</p>
<h4 id="3、读写数据段（RW-Data）"><a href="#3、读写数据段（RW-Data）" class="headerlink" title="3、读写数据段（RW Data）"></a>3、读写数据段（RW Data）</h4><p>读写数据段表示了在目标文件中一部分可以读也可以写的数据区，在某些场合它们又被称为已初始化数据段。这部分数据段和代码，与只读数据段一样都属于程序中的静态区域，但是具有可写的特点。</p>
<h6 id="已初始化全局变量"><a href="#已初始化全局变量" class="headerlink" title="已初始化全局变量"></a>已初始化全局变量</h6><p>例如：在函数外部，定义全局的变量char  a[100]=”abcdefg”</p>
<h6 id="已初始化局部静态变量"><a href="#已初始化局部静态变量" class="headerlink" title="已初始化局部静态变量"></a>已初始化局部静态变量</h6><p>例如：在函数中定义static  char b[100]=”9876543210”。函数中由static定义并且已经初始化的数据和数组将被编译为读写数据段。<br>说明：读写数据区的特点是必须在程序中经过初始化，如果只有定义，没有初始值，则不会生成读写数据区，而会定义为未初始化数据区(BSS)。如果全局变量（函数外部定义的变量）加入static修饰符，写成static  char a[100]的形式，这表示只能在文件内部使用，而不能被其他文件使用。</p>
<h4 id="4、未初始化数据段-BSS"><a href="#4、未初始化数据段-BSS" class="headerlink" title="4、未初始化数据段(BSS)"></a>4、未初始化数据段(BSS)</h4><p>未初始化数据段常被称之为BSS(英文名为Block start by symbol的缩写)。与读写数据段类似，它也属于静态数据区。但是该段中数据没有经过初始化。因此它只会在目标文件中被标识，而不会真正称为目标文件中的一个段，该段将会在运行时产生。未初始化数据段只有在运行的初始化阶段才会产生，因此它的大小不会影响目标文件的大小。</p>
<h3 id="2-2-内核模式和用户模式"><a href="#2-2-内核模式和用户模式" class="headerlink" title="2.2 内核模式和用户模式"></a>2.2 内核模式和用户模式</h3><p>  首先我们要解释一个概念——进程（Process）。简单来说，一个可执行程序就是一个进程，前面我们使用C语言编译生成的程序，运行后就是一个进程。进程最显著的特点就是拥有独立的地址空间。</p>
<p>严格来说，程序是存储在磁盘上的一个文件，是指令和数据的集合，是一个静态的概念；进程是程序加载到内存运行后一系列的活动，是一个动态的概念。</p>
<p>前面我们在讲解地址空间时，一直说“程序的地址空间”，这其实是不严谨的，应该说“进程的地址空间”。一个进程对应一个地址空间，而一个程序可能会创建多个进程。  </p>
<p>内核空间存放的是操作系统内核代码和数据，是被所有程序共享的，在程序中修改内核空间中的数据不仅会影响操作系统本身的稳定性，还会影响其他程序，这是非常危险的行为，所以操作系统禁止用户程序直接访问内核空间。</p>
<p>要想访问内核空间，必须借助操作系统提供的 API 函数，执行内核提供的代码，让内核自己来访问，这样才能保证内核空间的数据不会被随意修改，才能保证操作系统本身和其他程序的稳定性。</p>
<p>用户程序调用系统 API 函数称为系统调用（System Call）；发生系统调用时会暂停用户程序，转而执行内核代码（内核也是程序），访问内核空间，这称为内核模式（Kernel Mode）。</p>
<p>用户空间保存的是应用程序的代码和数据，是程序私有的，其他程序一般无法访问。当执行应用程序自己的代码时，称为用户模式（User Mode）。</p>
<p>计算机会经常在内核模式和用户模式之间切换：</p>
<ul>
<li>当运行在用户模式的应用程序需要输入输出、申请内存等比较底层的操作时，就必须调用操作系统提供的 API 函数，从而进入内核模式；</li>
<li>操作完成后，继续执行应用程序的代码，就又回到了用户模式。</li>
</ul>
<p>总结：用户模式就是执行应用程度代码，访问用户空间；内核模式就是执行内核代码，访问内核空间（当然也有权限访问用户空间）。</p>
<h4 id="？？为什么要区分两种模式"><a href="#？？为什么要区分两种模式" class="headerlink" title="？？为什么要区分两种模式"></a>？？为什么要区分两种模式</h4><p>– 我们知道，内核最主要的任务是管理硬件，包括显示器、键盘、鼠标、内存、硬盘等，并且内核也提供了接口（也就是函数），供上层程序使用。当程序要进行输入输出、分配内存、响应鼠标等与硬件有关的操作时，必须要使用内核提供的接口。但是用户程序是非常不安全的，内核对用户程序也是充分不信任的，当程序调用内核接口时，内核要做各种校验，以防止出错。</p>
<p>从 Intel 80386 开始，出于安全性和稳定性的考虑，CPU 可以运行在 ring0 ~ ring3 四个不同的权限级别，也对数据提供相应的四个保护级别。不过 Linux 和 Windows 只利用了其中的两个运行级别：</p>
<ul>
<li>一个是内核模式，对应 ring0 级，操作系统的核心部分和设备驱动都运行在该模式下。</li>
<li>另一个是用户模式，对应 ring3 级，操作系统的用户接口部分（例如 Windows API）以及所有的用户程序都运行在该级别。</li>
</ul>
<h4 id="？？为什么内核和用户程序要共用地址空间"><a href="#？？为什么内核和用户程序要共用地址空间" class="headerlink" title="？？为什么内核和用户程序要共用地址空间"></a>？？为什么内核和用户程序要共用地址空间</h4><p>–既然内核也是一个应用程序，为何不让它拥有独立的4GB地址空间，而是要和用户程序共享、占用有限的内存呢？</p>
<p>让内核拥有完全独立的地址空间，就是让内核处于一个独立的进程中，这样每次进行系统调用都需要切换进程。切换进程的消耗是巨大的，不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、MMU中的页表缓存失效，这将导致内存的访问在一段时间内相当低效。</p>
<p>而让内核和用户程序共享地址空间，发生系统调用时进行的是模式切换，模式切换仅仅需要寄存器进栈出栈，不会导致缓存失效；现代CPU也都提供了快速进出内核模式的指令，与进程切换比起来，效率大大提高了。</p>
<h2 id="3-进程运行时"><a href="#3-进程运行时" class="headerlink" title="3. 进程运行时"></a>3. 进程运行时</h2><p>当我们在终端输入</p>
<blockquote>
<p>./main</p>
</blockquote>
<p>这时，终端会调用fork创建一个子进程，fork函数是一个系统调用，这时会嵌入内核，调用的是clone函数，这个clone函数接着会调用do_fork函数，这个函数做了大部分创建工作，例如创建task_struct，内核栈，thread_info等结构，因为fork函数是采用写时复制技术，因此此时子进程task_struct大部分的属性还是和父进程task_struct一样，主要就是没有为子进程开辟内存空间；当子进程内核结构创建好之后，这时进程调度系统会优先调度子进程，因为一般情况下，子进程会直接调用exec函数避免写时拷贝开销．</p>
<blockquote>
<p>这里提下，一次fork调用为什么会返回两个值；因为当fork在内核调用成功，要返回用户态时，如果此时调度子进程执行，那么会把0放入rax寄存器中，等fork返回用户态执行子进程时，从rax得到的就是0；当内核调度的是父进程时，这时会把子进程的id号放入rax寄存器中，等返回到用户态执行父进程时，此时从rax获得的就是子进程的id号；</p>
</blockquote>
<p>到这里，还是只是创建了子进程内核的一些结构，接下来，在终端fork的子进程中，会调用exec系列函数</p>
<blockquote>
<p>execl(“./hello”,”hello”,””,NULL);</p>
</blockquote>
<p>这个函数会会为子进程hello单独开辟一块内存(之前是和父进程共用内存空间)，其实最主要就是为mm_struct结构以及页表重新赋值；具体怎么做了，最主要是调用mmap函数；我们可以把上述图的左边看成是躺在磁盘中的可执行文件，右边对应的是进程在内存中布局；当内核要将可执行文件的代码段映射到进程空间时，内核会先把code segment读取进内核的cache中，然后给hello进程的code段分配一块vma虚拟内存，并把这块虚拟内存映射到在cache中code segment，并把这块vma放入mm_struct的红黑树和链表中．链表适合当需要遍历所有vma内存区域时，而红黑树适合快速获取某个特定内存区域；我们经常查看/proc/<pid>/maps某个进程的内存布局，其实就遍历这个进程的vma链表即可．</p>
<h3 id="3-1-进程是如何执行的"><a href="#3-1-进程是如何执行的" class="headerlink" title="3.1 进程是如何执行的?"></a>3.1 进程是如何执行的?</h3><p>进程的执行其实就是cpu获取指令以及数据，并进行计算，这里cpu各个寄存器的使用和虚拟内存与物理内存转换等等；而main这个进程非常简单，就是调用C库函数printf输出一句话．但是其中涉及的过程还是相当复杂的．</p>
<p>首先当执行到printf时，因为main.c中没有定义这个函数，所以进程会去C库的动态链接库查找，当找到printf之后，进程会跳转到printf函数执行；在printf函数内部，会执行系统调用</p>
<blockquote>
<p>write(1, “hello world!\n”, 13)</p>
</blockquote>
<p>其中1是STDOUT_FILENO表示标准输，对应的就是输出到显示器；到这里，我们可以聊聊系统调用；当执行这个write函数时，因为write是个系统调用，在执行这个write之前，会将参数放入寄存器中，例如1放在rdi,＂hello world!\n”字符串指针放入rsi,13放入rdx寄存器中．linux在执行系统调用时，会触发一次int80软中断，并把系统调用号放入rax寄存器中；这时cpu切换到内核软中断处理函数中，怎么找到这个软中断函数？这个说起来，话又很多了(IDTR寄存器和中断描述符表)．在中断函数中，找到rax寄存器对应的系统调用，write对应的是sys_write函数，开始执行sys_write函数．在sys_write函数中，会通过fd找到file结构，inode结构等等，最后输出到显示器．</p>
<h3 id="3-2-进程是如何退出的"><a href="#3-2-进程是如何退出的" class="headerlink" title="3.2 进程是如何退出的"></a>3.2 进程是如何退出的</h3><p>当进程执行结束之后，会调用exit函数，而这个函数调用的系统调用函数_exit()会嵌入内核，进行清除工作．例如释放进程打开的文件，释放进程mm_struct对应的内存(如果没有共享内存)等等，最后只剩下task_struct,内核栈和thread_info三个结构．子进程会给父进程发送一个SIGCHLD信号，表示进程退出；父进程在收到这个信号之后，会调用wait或waitpid函数回收子进程的资源，task_struct,内核栈以及thread_info．到这里，main进程的生命就算走完了．</p>
<p>/etc/profile : 在登录时,操作系统定制用户环境时使用的第一个文件 ,此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export PATH="/home/acewzj/Software/5.11.1/gcc_64/bin:$PATH"</span><br><span class="line"></span><br><span class="line">export PATH="/home/acewzj/Software/Tools/QtCreator/bin:$PATH"</span><br><span class="line"></span><br><span class="line">export M2_HOME=/usr/local/apache-maven-3.6.2</span><br><span class="line"></span><br><span class="line">export PATH=$&#123;M2_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>/etc /environment : 在登录时操作系统使用的第二个文件, 系统在读取你自己的profile前,设置环境文件的环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games"</span><br><span class="line">JAVA_HOME="/usr/lib/jvm/java-11-openjdk-amd64/bin/java"</span><br></pre></td></tr></table></figure>

<p>~/.profile :  在登录时用到的第三个文件 是.profile文件,每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ~/.profile: executed by the <span class="built_in">command</span> interpreter <span class="keyword">for</span> login shells.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This file is not <span class="built_in">read</span> by bash(1), <span class="keyword">if</span> ~/.bash_profile or ~/.bash_login</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> exists.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> see /usr/share/doc/bash/examples/startup-files <span class="keyword">for</span> examples.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the files are located <span class="keyword">in</span> the bash-doc package.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> the default <span class="built_in">umask</span> is <span class="built_in">set</span> <span class="keyword">in</span> /etc/profile; <span class="keyword">for</span> setting the <span class="built_in">umask</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> ssh logins, install and configure the libpam-umask package.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">umask</span> 022</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> running bash</span></span><br><span class="line">if [ -n "$BASH_VERSION" ]; then</span><br><span class="line">    # include .bashrc if it exists</span><br><span class="line">    if [ -f "$HOME/.bashrc" ]; then</span><br><span class="line">	. "$HOME/.bashrc"</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> PATH so it includes user<span class="string">'s private bin if it exists</span></span></span><br><span class="line">if [ -d "$HOME/bin" ] ; then</span><br><span class="line">    PATH="$HOME/bin:$PATH"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> PATH so it includes user<span class="string">'s private bin if it exists</span></span></span><br><span class="line">if [ -d "$HOME/.local/bin" ] ; then</span><br><span class="line">    PATH="$HOME/.local/bin:$PATH"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>/etc/bashrc : 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">acewzj@acewzj:/etc$ cat bash.bashrc </span><br><span class="line"><span class="meta">#</span><span class="bash"> System-wide .bashrc file <span class="keyword">for</span> interactive bash(1) shells.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To <span class="built_in">enable</span> the settings / commands <span class="keyword">in</span> this file <span class="keyword">for</span> login shells as well,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> this file has to be sourced <span class="keyword">in</span> /etc/profile.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> If not running interactively, don<span class="string">'t do anything</span></span></span><br><span class="line">[ -z "$PS1" ] &amp;&amp; return</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> check the window size after each <span class="built_in">command</span> and, <span class="keyword">if</span> necessary,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> update the values of LINES and COLUMNS.</span></span><br><span class="line">shopt -s checkwinsize</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> variable identifying the chroot you work <span class="keyword">in</span> (used <span class="keyword">in</span> the prompt below)</span></span><br><span class="line">if [ -z "$&#123;debian_chroot:-&#125;" ] &amp;&amp; [ -r /etc/debian_chroot ]; then</span><br><span class="line">    debian_chroot=$(cat /etc/debian_chroot)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> a fancy prompt (non-color, overwrite the one <span class="keyword">in</span> /etc/profile)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> but only <span class="keyword">if</span> not SUDOing and have SUDO_PS1 <span class="built_in">set</span>; <span class="keyword">then</span> assume smart user.</span></span><br><span class="line">if ! [ -n "$&#123;SUDO_USER&#125;" -a -n "$&#123;SUDO_PS1&#125;" ]; then</span><br><span class="line">  PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ '</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Commented out, don<span class="string">'t overwrite xterm -T "title" -n "icontitle" by default.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If this is an xterm <span class="built_in">set</span> the title to user@host:dir</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">case</span> <span class="string">"<span class="variable">$TERM</span>"</span> <span class="keyword">in</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">xterm*|rxvt*)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    PROMPT_COMMAND=<span class="string">'echo -ne "\033]0;$&#123;USER&#125;@$&#123;HOSTNAME&#125;: $&#123;PWD&#125;\007"'</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    ;;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">*)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    ;;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">esac</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">enable</span> bash completion <span class="keyword">in</span> interactive shells</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> ! <span class="built_in">shopt</span> -oq posix; <span class="keyword">then</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  <span class="keyword">if</span> [ -f /usr/share/bash-completion/bash_completion ]; <span class="keyword">then</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    . /usr/share/bash-completion/bash_completion</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  <span class="keyword">elif</span> [ -f /etc/bash_completion ]; <span class="keyword">then</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    . /etc/bash_completion</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  <span class="keyword">fi</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">fi</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo hint</span></span><br><span class="line">if [ ! -e "$HOME/.sudo_as_admin_successful" ] &amp;&amp; [ ! -e "$HOME/.hushlogin" ] ; then</span><br><span class="line">    case " $(groups) " in *\ admin\ *|*\ sudo\ *)</span><br><span class="line">    if [ -x /usr/bin/sudo ]; then</span><br><span class="line">	cat &lt;&lt;-EOF</span><br><span class="line">	To run a command as administrator (user "root"), use "sudo &lt;command&gt;".</span><br><span class="line">	See "man sudo_root" for details.</span><br><span class="line">	</span><br><span class="line">	EOF</span><br><span class="line">    fi</span><br><span class="line">    esac</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> the <span class="built_in">command</span>-not-found package is installed, use it</span></span><br><span class="line">if [ -x /usr/lib/command-not-found -o -x /usr/share/command-not-found/command-not-found ]; then</span><br><span class="line">	function command_not_found_handle &#123;</span><br><span class="line">	        # check because c-n-f could've been removed in the meantime</span><br><span class="line">                if [ -x /usr/lib/command-not-found ]; then</span><br><span class="line">		   /usr/lib/command-not-found -- "$1"</span><br><span class="line">                   return $?</span><br><span class="line">                elif [ -x /usr/share/command-not-found/command-not-found ]; then</span><br><span class="line">		   /usr/share/command-not-found/command-not-found -- "$1"</span><br><span class="line">                   return $?</span><br><span class="line">		else</span><br><span class="line">		   printf "%s: command not found\n" "$1" &gt;&amp;2</span><br><span class="line">		   return 127</span><br><span class="line">		fi</span><br><span class="line">	&#125;</span><br><span class="line">fi</span><br><span class="line">PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</span><br><span class="line">export PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure>



<p>~/.bashrc : 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">acewzj@acewzj:/etc$ cat ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> ~/.bashrc: executed by bash(1) <span class="keyword">for</span> non-login shells.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> see /usr/share/doc/bash/examples/startup-files (<span class="keyword">in</span> the package bash-doc)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> examples</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> If not running interactively, don<span class="string">'t do anything</span></span></span><br><span class="line">case $- in</span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) return;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> don<span class="string">'t put duplicate lines or lines starting with space in the history.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See bash(1) <span class="keyword">for</span> more options</span></span><br><span class="line">HISTCONTROL=ignoreboth</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> append to the <span class="built_in">history</span> file, don<span class="string">'t overwrite it</span></span></span><br><span class="line">shopt -s histappend</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> setting <span class="built_in">history</span> length see HISTSIZE and HISTFILESIZE <span class="keyword">in</span> bash(1)</span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line">HISTFILESIZE=2000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> check the window size after each <span class="built_in">command</span> and, <span class="keyword">if</span> necessary,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> update the values of LINES and COLUMNS.</span></span><br><span class="line">shopt -s checkwinsize</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> If <span class="built_in">set</span>, the pattern <span class="string">"**"</span> used <span class="keyword">in</span> a pathname expansion context will</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> match all files and zero or more directories and subdirectories.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">shopt</span> -s globstar</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> make less more friendly <span class="keyword">for</span> non-text input files, see lesspipe(1)</span></span><br><span class="line">[ -x /usr/bin/lesspipe ] &amp;&amp; eval "$(SHELL=/bin/sh lesspipe)"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> variable identifying the chroot you work <span class="keyword">in</span> (used <span class="keyword">in</span> the prompt below)</span></span><br><span class="line">if [ -z "$&#123;debian_chroot:-&#125;" ] &amp;&amp; [ -r /etc/debian_chroot ]; then</span><br><span class="line">    debian_chroot=$(cat /etc/debian_chroot)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> a fancy prompt (non-color, unless we know we <span class="string">"want"</span> color)</span></span><br><span class="line">case "$TERM" in</span><br><span class="line">    xterm-color|*-256color) color_prompt=yes;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uncomment <span class="keyword">for</span> a colored prompt, <span class="keyword">if</span> the terminal has the capability; turned</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> off by default to not distract the user: the focus <span class="keyword">in</span> a terminal window</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> should be on the output of commands, not on the prompt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">force_color_prompt=yes</span></span><br><span class="line"></span><br><span class="line">if [ -n "$force_color_prompt" ]; then</span><br><span class="line">    if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then</span><br><span class="line"><span class="meta">	#</span><span class="bash"> We have color support; assume it<span class="string">'s compliant with Ecma-48</span></span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> (ISO/IEC-6429). (Lack of such support is extremely rare, and such</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> a <span class="keyword">case</span> would tend to support setf rather than setaf.)</span></span><br><span class="line">	color_prompt=yes</span><br><span class="line">    else</span><br><span class="line">	color_prompt=</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ "$color_prompt" = yes ]; then</span><br><span class="line">    PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '</span><br><span class="line">else</span><br><span class="line">    PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ '</span><br><span class="line">fi</span><br><span class="line">unset color_prompt force_color_prompt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> If this is an xterm <span class="built_in">set</span> the title to user@host:dir</span></span><br><span class="line">case "$TERM" in</span><br><span class="line">xterm*|rxvt*)</span><br><span class="line">    PS1="\[\e]0;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h: \w\a\]$PS1"</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">enable</span> color support of ls and also add handy aliases</span></span><br><span class="line">if [ -x /usr/bin/dircolors ]; then</span><br><span class="line">    test -r ~/.dircolors &amp;&amp; eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"</span><br><span class="line">    alias ls='ls --color=auto'</span><br><span class="line">    #alias dir='dir --color=auto'</span><br><span class="line">    #alias vdir='vdir --color=auto'</span><br><span class="line"></span><br><span class="line">    alias grep='grep --color=auto'</span><br><span class="line">    alias fgrep='fgrep --color=auto'</span><br><span class="line">    alias egrep='egrep --color=auto'</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> colored GCC warnings and errors</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">export</span> GCC_COLORS=<span class="string">'error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> some more ls aliases</span></span><br><span class="line">alias ll='ls -alF'</span><br><span class="line">alias la='ls -A'</span><br><span class="line">alias l='ls -CF'</span><br><span class="line">alias mm='tldr'</span><br><span class="line"><span class="meta">#</span><span class="bash"> Add an <span class="string">"alert"</span> <span class="built_in">alias</span> <span class="keyword">for</span> long running commands.  Use like so:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   sleep 10; alert</span></span><br><span class="line">alias alert='notify-send --urgency=low -i "$([ $? = 0 ] &amp;&amp; echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//'\'')"'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Alias definitions.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You may want to put all your additions into a separate file like</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ~/.bash_aliases, instead of adding them here directly.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See /usr/share/doc/bash-doc/examples <span class="keyword">in</span> the bash-doc package.</span></span><br><span class="line"></span><br><span class="line">if [ -f ~/.bash_aliases ]; then</span><br><span class="line">    . ~/.bash_aliases</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">enable</span> programmable completion features (you don<span class="string">'t need to enable</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> this, <span class="keyword">if</span> it<span class="string">'s already enabled in /etc/bash.bashrc and /etc/profile</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sources /etc/bash.bashrc).</span></span><br><span class="line">if ! shopt -oq posix; then</span><br><span class="line">  if [ -f /usr/share/bash-completion/bash_completion ]; then</span><br><span class="line">    . /usr/share/bash-completion/bash_completion</span><br><span class="line">  elif [ -f /etc/bash_completion ]; then</span><br><span class="line">    . /etc/bash_completion</span><br><span class="line">  fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acewzj.github.io/2019/09/07/2019-09-07-Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="acewzj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acewzj">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/2019-09-07-Linux/" itemprop="url">Linux下关于软链接和硬链接，动态链接库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-07T10:16:18+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>


<p>这篇文章主要介绍了Linux内核的一些笔记等知识。</p>
<h1 id="Linux内核（李林）"><a href="#Linux内核（李林）" class="headerlink" title="Linux内核（李林）"></a>Linux内核（李林）</h1><p>1.在内核里打印就不能用<code>printf</code>函数了，那是用户态用的，现在在内核里要用<code>printk</code>函数。</p>
<p>2.在内核里查看调试信息使用<code>dmesg</code>命令。嫌太长可以配合<code>dmesg | tail</code>命令查看尾部。</p>
<p>3.<code>make出来*.ko</code>文件之后，使用<code>insmod *.ko</code>进行安装内核文件（卸载使用<code>rmmod</code> 命令），这时initialize函数（使用<code>module_init(xxxxInitialize)</code>宏来注册该函数）会被首先执行，类似于我们在单片机里写的那些初始化寄存器，配置<code>IO</code>管脚的那些功能。</p>
<h2 id="Makefile文件编写"><a href="#Makefile文件编写" class="headerlink" title="Makefile文件编写"></a>Makefile文件编写</h2><blockquote>
<p>obj-m说明有一个模块需要从目标文件PrintModule.o中构造，而该模块名为PrintModule.ko</p>
<p>说明PrintModule由多个目标文件构成；一个编译单元一个目标文件（.o文件）</p>
<p>-DTEST_DEBUG：自定义宏</p>
<p>-ggdb：加入调试信息</p>
<p>-O0：优化级别</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/29/BuXplzwcrVi6FZa.png" alt="1583549085179"></p>
<p><img src="https://i.loli.net/2020/03/29/9kUaThAX6MDjgr5.png" alt="1583549416625"></p>
<p><img src="https://i.loli.net/2020/03/29/qHGhglabk5M8SRr.png" alt="1583549604315"></p>
<p>顶层的系统内核中的<code>makefile</code>里面定义了<code>kernalrelease</code>，编译时需要调用顶层的这个文件所以需要<code>kernaldir</code></p>
<h2 id="优化与调试级别"><a href="#优化与调试级别" class="headerlink" title="优化与调试级别"></a>优化与调试级别</h2><blockquote>
<p>n-O0：没有优化，默认选项</p>
<p>n-O1：基本优化级别</p>
<p>n-O2：主要是优化时间效率，不考虑生成的目标文件大小</p>
<p>n-O3：最高优化级别</p>
<p>n-Os：优化生成的目标文件大小，并且激活-O2中的不增加代码大小的优化选项</p>
<p>n-Og：gcc 4.8中引入的优化级别。针对快速编译和超强的调试体验，并同时提供合理的运行效率。该级别比使用-O0整体效果好。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/29/SRwkiTvWQat7oXA.png" alt="1583550194820"></p>
<h2 id="内核开发特点"><a href="#内核开发特点" class="headerlink" title="内核开发特点"></a>内核开发特点</h2><p><img src="https://i.loli.net/2020/03/29/NuHSivUVKxIPB2o.png" alt="1583551474801"></p>
<p><img src="https://i.loli.net/2020/03/29/6TUeK3xdYBztwbV.png" alt="1583551441783"></p>
<p>大概率会发生的汇编代码会放在条件跳转的紧接着的地址，这样CPU一取多了就会把大概率发生的指令一块就给取了，而低概率发生的代码则放在更高的地址上也就是远离xx条件跳转的地方，因为它不太可能发生的嘛所以CPU一次也不太可能把那么远的指令给取过来。</p>
<p><img src="https://i.loli.net/2020/03/29/z2nGZOCyJ8FSHxu.png" alt="1583551273362"></p>
<h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>1.首先查看一下本系统使用的内核版本号：虚拟机输入命令 <code>uname</code></p>
<p><code>Linux ubuntu 5.0.0-23-generic #24~18.04.1-Ubuntu SMP Mon Jul 29 16:12:28 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</code></p>
<p>2.然后使用apt搜一下，看看有没有对应的最新版：</p>
<p><code>apt search linux-source</code></p>
<p>3.然后，安装即可，安装后到/usr/src目录查找。</p>
<p><code>apt install linux-source-4.4.0</code></p>
<p>4.进入<code>/usr/src/linux-source-4.4.0</code>目录后，解压到自己的home目录（注意：压缩包自建好了文件夹，不用建新的了）：</p>
<p><code>tar xjvf linux-source-4.4.0.tar.bz2 -C ~</code></p>
<p><img src="https://i.loli.net/2020/03/31/7ead8bsH4PuXM5t.png" alt="image-20200331181547030"></p>
<p><img src="https://i.loli.net/2020/03/31/v6Jc8yiDFSHu1fr.png" alt="image-20200331181636905"></p>
<p><img src="https://i.loli.net/2020/03/31/JYbkUOyqCTLlWjm.png" alt="image-20200331181622179"></p>
<h1 id="一个古老又广泛的寻址技术：段寄存器"><a href="#一个古老又广泛的寻址技术：段寄存器" class="headerlink" title="一个古老又广泛的寻址技术：段寄存器"></a>一个古老又广泛的寻址技术：段寄存器</h1><h3 id="早期用途：内存管理"><a href="#早期用途：内存管理" class="headerlink" title="早期用途：内存管理"></a><strong>早期用途：内存管理</strong></h3><p>段寄存器是一个已经或者说即将被淘汰的CPU寄存器设计。诞生于16位CPU，通过使用段寄存器，16位的地址总线CPU就可以使用32位地址访问到4GB的大内存。</p>
<p>但是到了x86时代，地址总线变成了32位，段寄存器的最大作用消失。</p>
<p>这个时候，一个合理的思路是，为何不仿照16位的段寄存器访问32位地址空间那样，使用32位的段寄存器访问大于4GB的内存空间？</p>
<p>后来因为有了一个竞争技术–page的页管理方式的出现。</p>
<p><img src="https://i.loli.net/2020/03/29/XDs2H4oxfrglPCv.png" alt="1584085826895"></p>
<p>在Linux下将4GB的内存空间划分为了三个区域（zone），其中的high-mem，也就是高端的896MB内存不是像普通内存normal zone一样，给应用程序直接长期映射来用。Highmem是专门用于访问超过4GB的内存的。</p>
<p><strong>因为在Intel系列的CPU设计中，寻址即使到了64位也不是用64位的地址直接放到地址总线上去索引，而是通过查多级索引表来确定最后的地址</strong>（由于段寄存器只有16位，而现在64位也只使用了48位，所以能效上一致）。多级索引表在内存中，每一级都有地址存在内存中，这个存储就可以任意的长度。显然，这个多级索引需要CPU支持（不然32位的地址空间永远只能寻址到32位的地址空间）。Highmem在x86下就是与硬件的pae技术配合才能工作的。但是highmem是一个操作系统层面的技术，他的目标就是可以把超过4GB的物理内存动态的映射到4GB的内存空间。所以如果CPU不是Intel，pae技术就需要其他的CPU的硬件支持。例如ARM的LPAE。</p>
<p>这种扩张x86的可用内存的目标，在Windows下除了PAE机制外，还有4GT，用进程可见的线性内存空间从2GB扩张到3GB（与Linux一样），这个并没有本质的增大物理内存空间，只是扩大了进程可用的线性地址空间。还有AWE，可以让进程直接申请大端内存映射到自己的线性地址空间中。所以AWE要使用硬件的PAE机制才能使用超过4GB的内存。</p>
<p>既然使用大内存的技术在x86下已经有了，段寄存器在x86下就纯粹的变成了32位地址空间内的段地址安排，段地址（16位）：偏移（32位），就可以直接变成一个32位的绝对地址。必要性就不是很大了（虽然实模式还有要用，但是这个模式本身也是淘汰行列）。但是这个寄存器还是被强行用上了。Linux和Windows在x86下都有继续发掘这几个段寄存器的用法（虽然意义不大），创造一套新的内存管理机制（在x64下最终被淘汰）。</p>
<p>实模式是指段寄存器：寄存器的寻址方式，其中段寄存器中存放的实基地址，是一个地址偏移。保护模式也是段寄存器：寄存器的寻址模式，其中段寄存器中存放的是段选择子。也就是一个GDT/LDT序号。amd64架构下的模式叫做IA-32e，这个模式下有两个子模式：兼容模式和长模式。长模式直接不使用段寻址（FS/GS除外），兼容模式下仍然可以段寻址。</p>
<h3 id="新的用途：系统调用"><a href="#新的用途：系统调用" class="headerlink" title="新的用途：系统调用"></a><strong>新的用途：系统调用</strong></h3><p>段描述符是GDT和LDT。两级的段描述符表构成了段内存管理技术。这个技术的概念与ELF的程序段的概念遥相呼应，虽然并没有直接的关系，但是很容易想象ELF的段在内存中的映射和访问是可以用内核的段管理技术来访问的。但是实际上，段管理技术最终也只是使用的段地址（16位）：偏移（32位）访问的32位的地址空间。CPU的TLB和对应的地址索引技术提供了足够的针对地址的安全，权限等功能。与GDT和LDT表中的功能重叠。这就使得GDT和LDT表的存在很尴尬。内核在X86时代同时支持两种不同的内存访问方式。段式的访问和页式的访问。两种几乎为竞争关系。结果毋庸置疑，页式的完胜，到了x64，段寄存器就基本退出了历史舞台了。但是也只是又从通用的内存管理中退出，内存管理由page机制主要完成。而GDT和LDT控制的段内存访问机制，仍然被Linux带到了x64，作为页机制的补充机制。</p>
<p>但是即使在x64的长模式下，段寄存器依然被Windows和Linux广泛使用。这并不是Windows和Linux设计上的问题，而是Intel/AMD的设计问题。因为系统调用的逐渐的由int 80转向了sysenter/sysexit系列，后面又逐渐进入syscall的时代。而这个系列的系统调用指令，内部直接使用了段寄存器。段寻址就这样被固化下来了，在一个人们看不到的地方发挥着作用。</p>
<p>GDT和LDT这个二级表的概念并不是操作系统发明的，而是CPU发明的。有Lgdt这种对应的汇编指令和GDTR这种直接指定GDT位置的硬件寄存器。Linux下轻度依赖，基本上只用到了GDT。因为段寄存器的长度只有16位，所以最多一共只有65535字节的大小的GDT和LDT表（GDT相当于CPU给操作系统用的，LDT相当于给进程用的，每个进程一个，两者的结构和功能是一样的）。每一个entry占8个字节，所以一个表一共是最多8192个entry。在非64位长模式下，各种段索引都仍然可以使用，GDT，LDT仍然可以作为编程的技法。但是在ia-32e的长模式下，除了FS，GS之外，其他段寄存器都不使用GDT，LDT的段索引了（但是系统调用发生的时候修改的CS和SS是为的啥？），在ia-32e的兼容模式下，段索引仍然可以用。</p>
<p>但是实际上，由于Linux对段寻址的使用很轻量，LDT直接基本不使用，GDT里面的entry的数目也很有限。都是用于特殊目的的便捷寻址的（便捷吗？）。Windows下目前的win 10已经对用户彻底隐藏LDT。在Windows下有一个WOW64模式，是兼容运行32位程序的模式。在这个模式下，32位的程序可以运行在64位的CPU上，操作系统内核运行的是长模式，但是应用运行的是兼容模式（也就是ia-32e的两种子模式）。Windows通过控制在两种模式下切换，完成32位应用程序的系统请求（系统请求都是实现在64位的长模式下）。这个切换的过程实际上是CS值的变化，WOW64应用可以自己改变CS的值来达到在32位的程序中运行64位代码的目的。这个技术叫做地狱之门。wow64看到的fs,gs分别指向32位线程的TEB和64位线程的TEB，其他的四个段寄存器都指向一个相同的偏移。该偏移的作用未知。但是因为在兼容模式下，段寻址是有效的，所以可以很容易想到这个段选择子应该是4GB内存的根VAD，也就是4GB线性地址空间的基地址位置。</p>
<p>几个段寄存的名字就表明了CPU当时设计他们的初始目的。CS是代码段，DS是数据段，SS是堆栈段，ES是附加段。这个与ELF的段设计很相似，可惜ELF也没有用这套硬件机制来映射，毕竟ELF不止有这么四个段。</p>
<p>CPU硬件上设计了GDT和LDT，但是段寄存器就只有这四个（或算fs/gs的6个），所以在使用段寄存器的时候就得在寄存器里面指定访问的到底是GDT还是LDT了。所以16位的段寄存器里面并不都是段偏移。必经一个table最多有8192个entry，只需要13个位就可以完全索引。也正是因为如此，段寄存器就只使用了15-3这13个位来作为entry的索引。2位用于指定是GDT还是LDT，1，0两位就对应我们熟悉的4个权限级别ring0-ring3。这个是保护模式的定义。</p>
<p>所以就引出了段寄存器的另外一个功能：权限控制。页的分级访问也有一套完整的针对每个页的权限控制机制，与段entry里面的权限类似。但是16位的段寄存器里面竟然也有权限，并且只有两个位。这两个位就被Intel充分的挖掘了。虽然Intel没有明说，你会发现这两个位和ring0-ring3在实际的执行的时候总是对应的。当CS段寄存器的这两位指定了ring0，但是却是在ring3的模式下的代码，是不能执行的。SS寄存器也是一样。在sysenter之前，指向用户程序的栈，在进入内核后，由sysenter指向了该线程对应的内核栈。两个权限位就与CS是一样的与ring3和ring0保持一致。</p>
<p>Sysenter是一个从ring3切换到ring0的指令，它的工作原理依赖了几个专门设计的寄存器。IA32_SYSENTER_CS (0x174) 里面存放了系统调用所用到的CS，这个CS的最后两位的值就是00，也就是ring0的权限了。由于CS只有16位，而这个0x174寄存器却有32位。所以还有一些其他的信息存储。IA32_SYSENTER_ESP (0x175)内核用到的ESP，IA32_SYSENTER_EIP (0x176)就是内核的系统调用入口，当然是相对于CS的。</p>
<p>所以我们惊讶的发现，即使在64位下，所有的系统调用也是经过段寄存器的。段寄存器在系统中依然被重度的使用。但是，这么做究竟有没有必要？因为是硬件直接这么固化了，软件上就算认为没有必要也没有办法。他被用于系统调用是既定事实。但是在软件层面，段寄存器也确实从内存管理中逐渐的淡出。例如x86下，段寄存器在Windows上还可以用于DEP或者PEB，在x64长模式下，无论是Windows和Linux，都在软件层面弱化甚至消除段寄存器的依赖。硬件上也直接认为段选择子无效。</p>
<p>有一句话，很多时候只是听一听：所有的用户空间代码都是运行在ring3，所有的内核代码都是运行在ring 0。仔细想这句话就会发现很多不可思议的地方。这意味着，不论是root用户还是普通用户，都是无差别的受到这个限制。既然所有的内核代码都是在ring0中执行，那么就必然存在一个从用户空间到内核空间的ring切换的位置。这个位置在Linux内核代码里并没有找到。显然是一个硬件机制。这就是sysenter和CS段寄存器在起到的巨大作用。</p>
<h3 id="一个特殊的用法：TLS"><a href="#一个特殊的用法：TLS" class="headerlink" title="一个特殊的用法：TLS"></a><strong>一个特殊的用法：TLS</strong></h3><p>在Windows下，情况更复杂。除了硬件sysenter使用的CS段寄存器。Windows自己更改了从用户到内核所使用的寄存器。线程运行在 RING0 下， FS 段值是 0x30 （ WindowsXP 下值，在 Windows2000 下值为 0x38 ）；运行在 RING3 下时， FS 段寄存器值是 0x3b 。 FS 寄存器值的改变是在程序从 Ring3 进入 Ring0 后和从 Ring0 退回到 Ring3 前完成的，也就是说：都是在 Ring0 下给 FS 赋不同值的。Windows使用FS来指向TEB（X86情况下，X64情况下GS指向TEB。可以通过检查GS是否为0来判断当前是否是纯32位系统，wow64下，FS和GS分别指向线程的32位和64位的TEB）。在ring3下，FS一直指向当前线程的TEB段。随着线程的切换就一直在切换。所以在用户空间的代码，可以放心的用FS来直接索引到TEB段的内存内容。在ring0下，Windows下的FS指向处理器控制区域（KPCR）对应的GDT段。这个区域中保存这处理器相关的一些重要数据值，如 GDT 、 IDT 表的值等等。</p>
<p>也就是说，Windows除了sysenter硬件使用的CS外，还额外改变使用了FS段寄存器。这个FS的使用可以用来实现TLS。在x86和x64下，windows的行为差不多。但是在Linux下区别就比较大。Linux的无论是x86还是x64，对TLS的支持都是在glibc中完成的。也就是说，虽然大家都要改CS，但是对于其他段寄存器的修改，Linux在glibc中，而Windows在内核里。并且Windows使用的是FS，glibc使用的是GS。</p>
<p>但是无论是GS还是FS，都是一个TLS的访问入口，指明TLS的在GDT中的位置（所有的段寄存器都是用来在GDT/LDT中充当索引的）。但是Linux下仍然需要提前设置这个位置，Windows下因为进入和设置都是在内核里，所以不需要。Linux下需要提前使用set_thread_area来将该一个线程的TLS地址设置到GDT中。因为线程上下文切换是发生在内核中，内核在上下文切换的时候就同时修改GDT中的这个线程对应的entry和GS寄存器。这样glibc中使用GS寄存器就可以直接索引到特定的GDT的entry，就可以找到对应的TLS地址了。内核保证了位于用户空间的glibc看到的GS寄存器都是指向存储TLS信息的GDT的entry（这里的指向值得是段选择子提供的GDT的index序号）。</p>
<p>从上述可以看到在Linux下的两点：1、TLS的数据的真实存储位置是glibc提供的，通过set_thread_area来告知内核。2、内核中存储线程TLS的位置是GDT表中的某一个entry，这个entry的index（也就是GS段寄存器在索引时需要使用的选择子），可以由用户提供，也可以由内核来选择一个可用的。Glibc下是由内核选择。</p>
<p>也就是说，TLS实际上还是存储在线程自己申请的内存空间中。内核只是帮忙在GDT中找到一个entry记录一下，在线程切换的时候帮用户空间设置一下这个段寄存器。从而，我们能发现，TLS的实现并不是必须要使用内核支持。可以简单的通过编译器和链接器的支持来做到。（定义线程变量的语句直接编译成一个类似.GOT的数据，lazy解析的时候再与真实的地址绑定解析）。所以TLS对于段寄存器来说，是弱需求，只是目前都在这么用。毕竟TLS是随着线程的增加而增加的，不使用内核支持实现的难度相对大一些。内核在GDT中找到的entry的index会通过set_thread_area的参数修改的方式告诉给用户。不同线程不一定一样，但是不同线程也可以共用一个entry。一个数量级是很多Linux内核里，这个可以选择的TLS entry只有三个。但是线程却有那么多个。</p>
<p>事实上，在Linux下，如果只是基于glibc的应用程序，所有的线程都是使用的GDT中三个entry的第一个。set_thread_area需要用户传一个user_desc结构体。</p>
<p>struct user_desc {</p>
<p>unsigned int entry_number;</p>
<p>unsigned long base_addr;</p>
<p>unsigned int limit;</p>
<p>unsigned int seg_32bit:1;</p>
<p>unsigned int contents:2;</p>
<p>unsigned int read_exec_only:1;</p>
<p>unsigned int limit_in_pages:1;</p>
<p>unsigned int seg_not_present:1;</p>
<p>unsigned int useable:1;</p>
<p>#ifdef <strong>x86_64</strong></p>
<p>unsigned int lm:1;</p>
<p>#endif</p>
<p>};</p>
<p>在glibc下，用户传进来的entry_number是-1，意思是让内核选择index，然后通过修改这个值告诉用户结果。</p>
<p>Linux下几乎没有使用LDT，GDT中预留了三个给TLS用。Glibc让用户选择，最后选择的几乎一定是三个中的第一个。因为内核是遍历查找这三个，看有没有被使用。也就是说GS寄存器的值几乎是固定的。</p>
<p>这里有必要解释一下三个TLS的选择问题。因为GDT表是每个CPU核一个表，所以只需要考虑单个CPU是否会发生线程选择冲突。单个CPU在同一个时刻，物理上，只能有一个线程在运行。也就是说，这个线程永远都是独占这一个GDT的entry。内核线程上下文切换的时候会同时切换GDT中TLS的内容为线程的内容，并且设置GS寄存器。所以一般情况，我们在用户空间看到的GS的值都是一样的（0x33，也就是6号entry，取段寄存器的15-3位为index）。比如Wine会使用第二个TLS，就是用来模拟Windows下exe的执行的。Windows下也有类似的TLS机制，只不过是通过FS段寄存器实现，而不是GS。Windows在64下同时使用GS和FS来支持TLS，但是连读写fs,gs寄存器的权限都不提供了（FSGSBASE指令是一个ring3的指令扩展，可以用来读取FSGS的内容，需要CPU支持）。Linux在64位还提供了arch_prctl可以用来读写段寄存器。</p>
<p>Linux可以给每个进程（线程）都创建一个LDT，看起来这个LDT是一个可以充分利用的段描述符表。并且提供了modify_ldt可以操作这个表。但是这个在Linux下只是一个兼容机制，Linux不建议用这个LDT表来实现TLS，或者用于替他的目的。因为会降低线程切换的效率。只用于兼容16位的程序或者32位的段寻址程序。LDT基本被Linux废弃。实际上，LDT表，不显示的调用modify_ldt，Linux就不会生成。</p>
<h3 id="段寻址的性能"><a href="#段寻址的性能" class="headerlink" title="段寻址的性能"></a><strong>段寻址的性能</strong></h3><p>段寻址需要先查段表（GDT或者LDT），从段表中找到实际的目标地址内存块的初始位置，然后再跟便宜计算。由于段表是放在内存的，看起来每次都需要额外访问一次内存。实际上，CPU在设计的时候，实现了影子寄存器。影子寄存器相当于段表条目的缓存，使得段寄存器的段信息可以直接从寄存器中读取，从而达到与平台寻址（flat）相似的寻址性能。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>段寄存器越来越对用户空间代码封闭，所以程序代码应该尽可能的少依赖使用段寄存器的trick。CS和SS被硬件sysenter/sysexit频繁使用（这个和paper中说的长模式不使用段寻址互相冲突，我不能解释）。FS/GS在64位的Windows下被操作系统完全控制。而64位会从硬件层面直接忽略段寄存器的寻址方式。也就是说，在64位下，段寄存器作为一种寻址方式是被禁止使用的，只能由sysenter/sysexit等硬件使用。段寄存器从一个功能巨大的内存管理方式，逐渐退步到内存管理的辅助，到TLS的最后阵地，最后逐渐变成了硬件专用的内部寄存器。发展的考虑，在任何情况下，应用程序继续显示的使用段寄存器都是不被鼓励的。</p>
<p>Trick技巧上，如果寄存器实在不够用了，可以考虑在linux下使用fs来寻址。</p>
<p>#include &lt;asm/prctl.h&gt;</p>
<p>static int arch_prctl(int func, void *ptr) {</p>
<p>return syscall(__NR_arch_prctl, func, ptr);</p>
<p>}</p>
<p>arch_prctl(ARCH_SET_FS, (void*)fsbase);</p>
<p>mov rax,fs:[rcx+rdx*8]</p>
<h3 id="FS寄存器指向当前活动线程的TEB结构（线程结构）"><a href="#FS寄存器指向当前活动线程的TEB结构（线程结构）" class="headerlink" title="FS寄存器指向当前活动线程的TEB结构（线程结构）"></a>FS寄存器指向当前活动线程的TEB结构（线程结构）</h3><p>偏移 说明<br>000 指向SEH链指针<br>004 线程堆栈顶部<br>008 线程堆栈底部<br>00C SubSystemTib<br>010 FiberData<br>014 ArbitraryUserPointer<br>018 FS段寄存器在内存中的镜像地址<br>020 进程PID<br>024 线程ID<br>02C 指向线程局部存储指针<br>030 PEB结构地址（进程结构）<br>034 上个错误号</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="链接原理"><a href="#链接原理" class="headerlink" title="链接原理"></a>链接原理</h1><p><a href="https://zhuanlan.zhihu.com/p/52964760" target="_blank" rel="noopener">转载自–刘叔–深入Linux内核</a></p>
<p>在编译的过程中，如果所有的代码都写到一个单独的文件里，由于编译器以文件为单位进行编译，所以可以一次性的拿到所有的函数，那么就可以就地处理所有的符号，显然这是编译器最喜闻乐见的事情。但是由于有外部库和工程组织的需要，不可能所有的代码都在同一个文件里，编译器是用来满足开发人员的需要的，不是反过来。所以编译器要想办法解决不同文件之间的链接问题。</p>
<p>编译器在编译一个文件的时候，会生成一个段的划分。这个划分通常名字大同小异（当然可以通过写link脚本改变段的命名和排布），但是.text, .data这种常用的代码段和数据段基本没有人会有其他想法。每个文件编译的时候生成了同样的.text段，链接器用来处理多个编译单元的（也就是.o文件），将这些文件链接在一起的时候，链接器的主要工作就是将同样的段进行合并。这个操作看起来简单，但是不断.o文件互相调用的情况该怎么解决呢？例如A文件调用了B文件的test函数，在编译A的时候看不到B中test函数的定义，那么这个A里面的B的test函数的地址该如何填充？链接器在进行链接的时候又该如何修正？</p>
<p>首先可以确定的是A里面在链接发生之前是肯定不能知道B中test的地址的，但是A里面的汇编结果的call指令的目的地址总需要填充个值。这个值就是0，就是在编译A的时候，发现A调用了别人的test函数，编译器会直接在call的A函数的位置填call 0地址，然后同时，在A的目标文件的一个.rel.text和.rel.data。这两个表叫做重定向表，用于在链接的时候组装不同的目标文件，一个是函数重定向，一个是数据重定向。里面存储的信息就是在A的某某偏移位置调用了test函数。当链接发生的时候，链接器查看A的重定向标发现A需要test的地址，然后在B的函数定义中查找test的定义和地址（是A和B的.text合并之后的地址），然后用这个地址去修改A对应的偏移里面的call指令。这样就完成了链接时的重定位。</p>
<p>这个重定位发生在所有的静态链接的时候，包括静态链接库的时候和链接自己的代码文件的时候。</p>
<p>但是我们知道还有一个很常见的应用是动态链接。动态链接的时候，符号的位置要在运行的过程中才会解析。编译的时候分为PIC的编译方式和非PIC的传统编译方式（现在大部分库都是使用PIC的方式）。两个的区别在于能不能在内存中重用库的代码。</p>
<p>非PIC的传统编译方式需要在加载库的时候就重新设置所有的符号。例如liba.so里面调用了libb.so里面的一个函数test，那么按照静态链接的思路liba.so需要暴露一个段里面存放需要重定位的符号（也就是 call test的偏移），在加载libb.so的时候就要立刻解析出liba.so里面的call指令对应的test函数的地址。</p>
<p>这种情况相当于liba.so的.text段的内容在加载的时候被修改了。也就是说liba.so的.text的位置在不同的程序里面是不一样的（因为libb.so在不同的进程不一定在同样的位置）。所以liba.so在内存中不能复用，也就是每个进程都要在内存中加载一份liba.so的.text，liba.so使用了多少次就需要加载多少份。</p>
<p>这样有问题吗？除了内存里有多份liba.so外，并没有什么问题。有一个特点是加载的时候需要解析全部的符号，即使没有用到的，这样加载的速度相对慢一些。</p>
<p>动态链接用到了.rel.dyn和.rel.plt（PLT：过程链接表）。前者是数据重定向，后者是函数重定向。两个段的功能与静态链接的重定向表是一样的。这一切都显得那么轻松。</p>
<p>但是毕竟程序员是追求完美的，针对这两个问题，追求完美的程序员想出了PIC模式。所谓的PIC模式就是位置无关，就是想办法让liba.so的.text在所有使用liba.so的进程之间复用。这样只依赖.rel.dyn和.rel.plt可能就做不到了。因为使用这两个表是需要修改.text段的内容的。所以又添加了.got和.got.plt两个表，同样的，前者对应数据，后者对应函数。这两个段就是PIC的实现方法了。</p>
<p>所谓的PIC就是在编译liba.so的call test函数的时候，不是在test函数的地址位置填充0，而是填充liba.so的.got.plt段的test地址。在编译的时候.got.plt中的test的地址是空的，显然是不能寻址的，但是call test指令却是直接固定的调用.got.plt的表的test函数的（虽然这个函数还不知道在哪定义）。.got.plt相当于一个桩子，call test就是调用了这里的桩子函数。由于.got.plt不是位于.text里面，所以在解析的时候只需要修改.got.plt里面的test的定义地址就可以找到真实的定义，无论libb.so加载到内存的什么位置，都是只需要找到它，然后填充liba.so的.got.plt的test函数条目即可。如此.text就可以实现复用了。第一个问题解决。</p>
<p>第二个问题就是延迟绑定的技术。这个技术是为了防止加载的时候解析所有的符号，而是让用的时候才解析。所需要的技术在应用了PIC之后几乎是现成的。就是.got.plt中的内容不是加载的时候填充，而是用到的时候填充。这一切由运行时的链接器完成（interpreter）。</p>
<h2 id="C编译与运行时栈"><a href="#C编译与运行时栈" class="headerlink" title="C编译与运行时栈"></a>C编译与运行时栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functt</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	num++;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ttt;</span><br><span class="line">	ttt = functt(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/09/07/JN12OYCeoGm4UXg.png" alt=""></p>
<p>？？一旦进入call，先将EBP压栈，因为接下来将把EBP移动到ESP位置，为什么要这么做？</p>
<p>call指令实际动作是push eip；mov eip，4111D6h连续两条指令.</p>
<p>ret指令实际动作是pop eip</p>
<p>我们总结一下：每次调用别的函数时，先将EIP指针入栈–然后将EBP入栈     </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> CAL:</span><br><span class="line">	<span class="built_in">stack</span>[top]=ip; </span><br><span class="line">	<span class="built_in">stack</span>[top+<span class="number">1</span>]=base;</span><br><span class="line">	base=top; </span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/09/07/nk9YblSxXgqN4j2.png" alt="图片参考"></p>
<p> <a href="https://www.cnblogs.com/mydomain/archive/2010/10/24/1860005.html" target="_blank" rel="noopener">This is an reference-style link</a> </p>
<p>？？为什么要将ESP往下移动192（0C0 Hex）个字节？</p>
<p>–他们说是为该函数留出临时存储区！192Bytes存储int数据（4Bytes）也只不过是48个int。当我们试图去分配一个50个元素的局部变量时看看会发生什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functt</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> aaa[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	num++;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/09/07/3sbBi7eHh8Q4YlM.png" alt=""></p>
<p>ESP往低地址移动了190H=400Bytes，看来就是多留出一块局部变量的存储区域出来。</p>
<p>从lea指令到rep这条指令作用就是把为局部变量分配的内存空间填充CC数据。Stos将eax中数据放入es:[edi]中，同时edi增加4个字节。Rep使指令重复执行ecx次数。</p>
<h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/              根目录</span><br><span class="line">├── bin     存放用户二进制文件</span><br><span class="line">├── boot    存放内核引导配置文件</span><br><span class="line">├── dev     存放设备文件</span><br><span class="line">├── etc     存放系统配置文件</span><br><span class="line">├── <span class="built_in">home</span>    用户主目录</span><br><span class="line">├── lib     动态共享库</span><br><span class="line">├── lost+found  文件系统恢复时的恢复文件</span><br><span class="line">├── media   可卸载存储介质挂载点</span><br><span class="line">├── mnt     文件系统临时挂载点</span><br><span class="line">├── opt     附加的应用程序包</span><br><span class="line">├── proc    系统内存的映射目录，提供内核与进程信息</span><br><span class="line">├── root    root 用户主目录</span><br><span class="line">├── sbin    存放系统二进制文件</span><br><span class="line">├── srv     存放服务相关数据</span><br><span class="line">├── sys     sys 虚拟文件系统挂载点</span><br><span class="line">├── tmp     存放临时文件</span><br><span class="line">├── usr     存放用户应用程序</span><br><span class="line">└── var     存放邮件、系统日志等变化文件</span><br></pre></td></tr></table></figure>

<h3 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h3><p>No rule to make target ‘/usr/lib/x86_64-linux-gnu/libGL.so’</p>
<p><img src="https://i.loli.net/2019/09/08/G2svTNJrOc3fhei.png" alt=""></p>
<p>在编译Ogre的时候make install出现了这个问题，这里发现我的libGL.so指向了libGL.so.1.0.0，这是怎么一回事呢？</p>
<ol>
<li><p>搜索libGL.so文件路径： 比如，本机中路径为：/usr/lib/libGL.so</p>
</li>
<li><p>建立symlink: sudo ln -s  /usr/lib/libGL.so.1  /usr/lib/x86_64-linux-gnu/libGL.so （之所以链接到libGL.so.1而不是libGL.so可能是为了便于区分）</p>
</li>
<li><p>如果出现错误： ln: failed to create symbolic link ‘/usr/lib/x86_64-linux-gnu/libGL.so’ : File exists</p>
<p>  则删除已有链接： sudo rm  /usr/lib/x86_64-linux-gnu/libGL.so</p>
</li>
<li><p>重新执行步骤2建立symlink</p>
</li>
</ol>
<h3 id="为什么要使用动态链接库？"><a href="#为什么要使用动态链接库？" class="headerlink" title="为什么要使用动态链接库？"></a>为什么要使用动态链接库？</h3><p>–《鸟哥的私房菜》中提及：动态函数库在编译的时候，在程序里面只有一个“指向”（Pointer）的位置而已，也就是说，动态函数库的内容并没有被整合到可执行文件中，而是当可执行文件要使用到函数库的时候程序才会读取函数库来使用。由于可执行文件中仅仅具有指向动态函数库所在的指标而已，并不包含函数库的内容，所以它的文件比较小一点。以下摘自APUE：</p>
 <img src="https://i.loli.net/2019/09/13/Q1hEX6dIOHfmMSx.png" style="zoom: 50%;" />



<h3 id="如何将动态函数库加载到高速缓存中呢？"><a href="#如何将动态函数库加载到高速缓存中呢？" class="headerlink" title="如何将动态函数库加载到高速缓存中呢？"></a>如何将动态函数库加载到高速缓存中呢？</h3><p>– 1.首先，我们必须在<code>/etc/ld.so.conf</code> 文件夹里面写下想要读入高速缓存当中的动态函数库所在的目录，注意是目录而不是文件。</p>
<p><img src="https://i.loli.net/2019/09/10/zkp5WbaRUmhlycw.png" alt=""></p>
<p>2.接下来利用ldconfig这个可执行文件将<code>/etc/ld.so.conf.d</code>的数据读入缓存中；</p>
<p>3.同时也将数据记录一份在<code>/etc/ld.so.cache</code> 这个文件当中。</p>
<p>Tips:可以使用<code>ldconfig -p</code>指令查看函数库内容（ld.so.cache）</p>
<h3 id="硬连接与软连接"><a href="#硬连接与软连接" class="headerlink" title="硬连接与软连接"></a>硬连接与软连接</h3><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<p>为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名。</p>
<p>由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：</p>
<ul>
<li>文件有相同的 inode 及 data block；</li>
<li>只能对已存在的文件进行创建；</li>
<li>不能交叉文件系统进行硬链接的创建；</li>
<li>不能对目录进行创建，只可对文件创建；</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li>
</ul>
<p>软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块（见下图）。因此软链接的创建与使用没有类似硬链接的诸多限制：</p>
<ul>
<li>软链接有自己的文件属性及权限等；</li>
<li>可对不存在的文件或目录创建软链接；</li>
<li>软链接可交叉文件系统；</li>
<li>软链接可对文件或目录创建；</li>
<li>创建软链接时，链接计数 i_nlink 不会增加；</li>
<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li>
</ul>
<img src="https://i.loli.net/2019/09/10/jlnP3kGIQwpg6dm.png" style="zoom:150%;" />





<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll:产生的事件数；及消息；使用注意</p>
<p>epoll 全称 eventpoll，是 linux 内核实现IO多路复用（IO multiplexing）的一个实现</p>
<p>epoll 监听的fd(File Descriptor)集合是常驻内核的,它有3个系统调用(<em>epoll_create</em>, <em>epoll_wait</em>, epoll_ctl)通过 <em>epoll_wait</em> 可以多次监听同一个 fd 集合，只返回可读写那部分</p>
<p>select 只有一个系统调用，每次要监听都要将其从用户态传到内核，有事件时返回整个集合。</p>
<p>从性能上看，如果 fd 集合很大，用户态和内核态之间数据复制的花销是很大的，所以 select 一般限制 fd 集合最大1024。</p>
<p>从使用上看，epoll 返回的是可用的 fd 子集，select 返回的是全部，哪些可用需要用户遍历判断。</p>
<p>尽管如此，epoll 的性能并不必然比 select 高，对于 fd 数量较少并且 fd IO 都非常繁忙的情况 select 在性能上有优势。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之前parent和child运行在同一个session里,parent是会话（session）的领头进程,</span></span><br><span class="line">   <span class="comment">//parent进程作为会话的领头进程，如果exit结束执行的话，那么子进程会成为孤儿进程，并被init收养。</span></span><br><span class="line">   <span class="comment">//执行setsid()之后,child将重新获得一个新的会话(session)id。</span></span><br><span class="line">   <span class="comment">//这时parent退出之后,将不会影响到child了。</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是session-会话"><a href="#什么是session-会话" class="headerlink" title="什么是session?会话"></a>什么是session?会话</h2><p>Session：在计算机中，尤其是在网络应用中，称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web页时，如果该用户还没有会话，则Web服务器将自动创建一个 Session对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在Session对象中。有关使用Session 对象的详细信息，请参阅“ASP应用程序”部分的“管理会话”。注意会话状态仅在支持cookie的浏览器中保留。</p>
<h2 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h2><p>　孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作.</p>
<p>　僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
<p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，<strong>如果进程不调用wait / waitpid的话，</strong> <strong>那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p>
<p>　<strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上</strong>，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。<strong>因此孤儿进程并不会有什么危害。</strong></p>
<p><strong>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。</strong>这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<h2 id="僵尸进程危害场景："><a href="#僵尸进程危害场景：" class="headerlink" title="僵尸进程危害场景："></a>僵尸进程危害场景：</h2><p>　　例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。</p>
<p>需要注意的是，用户层守护进程的父进程是 init进程（进程ID为1），从上面的输出<code>PPID</code>一列也可以看出，内核守护进程的父进程并非是 init进程。对于用户层守护进程， 因为它真正的父进程在 fork 出子进程后就先于子进程 exit 退出了，所以它是一个由 init 继承的孤儿进程。</p>
<p>进程组 ：</p>
<ul>
<li>每个进程除了有一个进程ID之外，还属于一个进程组</li>
<li>进程组是一个或多个进程的集合，同一进程组中的各进程接收来自同一终端的各种信号</li>
<li>每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID</li>
</ul>
<p>会话：会话（session）是一个或多个进程组的集合，进程调用 setsid 函数（原型：<code>pid_t setsid(void)</code> ）建立一个会话。</p>
<p>  进程调用 setsid 函数建立一个新会话，如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下3件事：</p>
<ul>
<li>该进程变成新会话的会话首进程（session leader，会话首进程是创建该会话的进程）。此时，该进程是新会话的唯一进程。</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID</li>
<li>该进程没有控制终端。如果调用setsid之前该进程有一个控制终端，那么这种联系也被切断</li>
</ul>
<p>如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID是重新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。</p>
<h2 id="创建守护进程的过程："><a href="#创建守护进程的过程：" class="headerlink" title="创建守护进程的过程："></a><strong>创建守护进程的过程：</strong></h2><p>\1. 调用fork创建子进程。父进程终止，让子进程在后台继续执行。<br>\2. 子进程调用setsid产生新会话期并失去控制终端调用setsid()使子进程进程成为新会话组长和新的进程组长，同时失去控制终端。<br>\3. 忽略SIGHUP信号。会话组长进程终止会向其他进程发该信号，造成其他进程终止。<br>\4. 调用fork再创建子进程。子进程终止，子子进程继续执行，由于子子进程不再是会话组长，从而禁止进程重新打开控制终端。<br>\5. 改变当前工作目录为根目录。一般将工作目录改变到根目录，这样进程的启动目录也可以被卸掉。<br>\6. 关闭打开的文件描述符，打开一个空设备，并复制到标准输出和标准错误上。 避免调用的一些库函数依然向屏幕输出信息。<br>\7. 重设文件创建掩码清除从父进程那里继承来的文件创建掩码，设为0。<br>\8. 用openlog函数建立与syslogd的连接。</p>
<p>/dev/null是一个特殊的设备文件，这个文件接收到的任何数据都会被丢弃。因此，null这个设备通常也被成为位桶（bit bucket）或黑洞。</p>
<h2 id="什么是-Event-Loop？"><a href="#什么是-Event-Loop？" class="headerlink" title="什么是 Event Loop？"></a>什么是 Event Loop？</h2><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr?"></a><strong>shared_ptr</strong>?</h2><p>智能指针的原理是:接受一个申请好的内存地址,构造一个保存在栈上的智能指针对象,当程序退出栈的作用域范围后,由于栈上的变量自动被销毁,智能指针内部保存的内存也就被释放掉了(除非将智能指针保存起来)</p>
<p>C11提供了三种智能指针:std::shared_ptr,  std::unique_ptr,   std::weak_ptr  使用时需要包含头文件<memory></p>
<p>shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。shared_ptr内部的引用计数是安全的，但是对象的读取需要加锁。</p>
<p>文件的写入也是如此，拿到offet，调用实际的写入方法，最后更新offset。到此为止一个文件的读和写的大体过程我们是清楚了，很显然上述的过程并不是原子的，无论是文件的读还是写，都至少有两个步骤，一个是拿offset，另外一个则是实际的读和写。并且在整个过程中并没有看到加锁的动作，那么第一个问题就得到了解决。对于第二个问题我们可以简要的分析下，假如有两个线程，第一个线程拿到offset是1，然后开始写入，在写入的过程中，第二个线程也去拿offset，因为对于一个文件来说多个线程是共享同一个struct file结构，因此拿到的offset仍然是1，这个时候线程1写结束，更新offset，然后线程2开始写。最后的结果显而易见，线程2覆盖了线程1的数据，通过分析可知，多线程写文件不是原子的，会产生数据覆盖。但是否会产生数据错乱，也就是数据交叉写入了?其实这种情况是不会发生的，至于为什么请看下面这段代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">generic_file_aio_write</span><span class="params">(struct kiocb *iocb, <span class="keyword">const</span> struct iovec *iov,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_segs, <span class="keyword">loff_t</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">iocb</span>-&gt;<span class="title">ki_filp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">file</span>-&gt;<span class="title">f_mapping</span>-&gt;<span class="title">host</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_plug</span> <span class="title">plug</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">    BUG_ON(iocb-&gt;ki_pos != pos);</span><br><span class="line">    <span class="comment">// 文件的写入其实是加锁的</span></span><br><span class="line">    mutex_lock(&amp;inode-&gt;i_mutex);</span><br><span class="line">    blk_start_plug(&amp;plug);</span><br><span class="line">    ret = __generic_file_aio_write(iocb, iov, nr_segs, &amp;iocb-&gt;ki_pos);</span><br><span class="line">    mutex_unlock(&amp;inode-&gt;i_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span> || ret == -EIOCBQUEUED) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> err;</span><br><span class="line"></span><br><span class="line">        err = generic_write_sync(file, pos, ret);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span> &amp;&amp; ret &gt; <span class="number">0</span>)</span><br><span class="line">            ret = err;</span><br><span class="line">    &#125;</span><br><span class="line">    blk_finish_plug(&amp;plug);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(generic_file_aio_write);</span><br></pre></td></tr></table></figure>

<p>所以并不会产生数据错乱，只会存在数据覆盖的问题，既然如此我们在实际的进行文件读写的时候是否需要进行加锁呢? 加锁的确是可以解决问题的，但是在这里未免有点牛刀杀鸡的感觉，好在OS给我们提供了原子写入的方法，第一种就是在打开文件的时候添加O_APPEND标志，通过O_APPEND标志将获取文件的offset和文件写入放在一起用锁进行了保护，使得这两步是原子的，具体代码可以看上面代码中的__generic_file_aio_write函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> __generic_file_aio_write(struct kiocb *iocb, <span class="keyword">const</span> struct iovec *iov,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_segs, <span class="keyword">loff_t</span> *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">iocb</span>-&gt;<span class="title">ki_filp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> * <span class="title">mapping</span> = <span class="title">file</span>-&gt;<span class="title">f_mapping</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> ocount;      <span class="comment">/* original count */</span></span><br><span class="line">    <span class="keyword">size_t</span> count;       <span class="comment">/* after file limit checks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>    *<span class="title">inode</span> = <span class="title">mapping</span>-&gt;<span class="title">host</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span>      pos;</span><br><span class="line">    <span class="keyword">ssize_t</span>     written;</span><br><span class="line">    <span class="keyword">ssize_t</span>     err;</span><br><span class="line"></span><br><span class="line">    ocount = <span class="number">0</span>;</span><br><span class="line">    err = generic_segment_checks(iov, &amp;nr_segs, &amp;ocount, VERIFY_READ);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    count = ocount;</span><br><span class="line">    pos = *ppos;</span><br><span class="line"></span><br><span class="line">    vfs_check_frozen(inode-&gt;i_sb, SB_FREEZE_WRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We can write back this queue in page reclaim */</span></span><br><span class="line">    current-&gt;backing_dev_info = mapping-&gt;backing_dev_info;</span><br><span class="line">    written = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 重点就在这个函数</span></span><br><span class="line">    err = generic_write_checks(file, &amp;pos, &amp;count, S_ISBLK(inode-&gt;i_mode));</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    ......<span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">generic_write_checks</span><span class="params">(struct file *file, <span class="keyword">loff_t</span> *pos, <span class="keyword">size_t</span> *count, <span class="keyword">int</span> isblk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">file</span>-&gt;<span class="title">f_mapping</span>-&gt;<span class="title">host</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> limit = rlimit(RLIMIT_FSIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(*pos &lt; <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isblk) &#123;</span><br><span class="line">        <span class="comment">/* <span class="doctag">FIXME:</span> this is for backwards compatibility with 2.4 */</span></span><br><span class="line">        <span class="comment">// 如果带有O_APPEND标志，会直接拿到文件的大小，设置为新的offset</span></span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_flags &amp; O_APPEND)</span><br><span class="line">                        *pos = i_size_read(inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (limit != RLIM_INFINITY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*pos &gt;= limit) &#123;</span><br><span class="line">                send_sig(SIGXFSZ, current, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> -EFBIG;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (*count &gt; limit - (typeof(limit))*pos) &#123;</span><br><span class="line">                *count = limit - (typeof(limit))*pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......<span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后一个问题是多个进程写同一个文件是否会造成文件写错乱，直观来说是多进程写文件不是原子的，这是很显而易见的，因为每个进程都拥有一个struct file对象，是独立的，并且都拥有独立的文件offset，所以很显然这会导致上文中说到的数据覆盖的情况，但是否会导致数据错乱呢?，答案是不会，虽然struct file对象是独立的，但是struct inode是共享的(相同的文件无论打开多少次都只有一个struct inode对象)，文件的最后写入其实是先要写入到页缓存中，而页缓存和struct inode是一一对应的关系，在实际文件写入之前会加锁，而这个锁就是属于struct inode对象(见上文中的mutex_lock(&amp;inode-&gt;i_mutex))的，所有无论有多少个进程或者线程，只要是对同一个文件写数据，拿到的都是同一把锁，是线程安全的，所以也不会出现数据写错乱的情况。</p>
<h3 id="write：不会出现数据交叉的情况，而且父子进程交替执行写入。"><a href="#write：不会出现数据交叉的情况，而且父子进程交替执行写入。" class="headerlink" title="write：不会出现数据交叉的情况，而且父子进程交替执行写入。"></a><code>write</code>：不会出现数据交叉的情况，而且父子进程交替执行写入。</h3><p>从上面小节的测试过程可以发现，两个非亲缘关系的进程同时写一个文件时，会出现数据混乱的情况，但是两个进程写入的数据没有覆盖。</p>
<p>这是因为这两个进程表项中指向的对应的两个文件表项对应的当前文件偏移量是不一致的，但是由于打开文件时是使用append追加的方式，使得进程指向的文件表项中的当前文件偏移量都等于当前文件中所有数据的总长度。这就是为什么写入的数据会出现错乱，但是不会出现覆盖（偏移量不一致）的原因。</p>
<p>注意：内核write函数在写入时是<code>原子</code>操作，所以两个进程会有一个竞争关系，最终只会由某个进程写入数据。</p>
<p>为什么fwrite会出问题? ，因为有buf，所以就会有问题?，这块还没有讲解清楚哦，还是需要分析下的，另外write为什么不会错乱? 分析不够到位啊，我之前也写过一篇文章分析过这个问题，<a href="http://blog.csdn.net/zhangyifei216/article/details/76653746，fwrite的问题说白了其实就是用户态buf，会缓存多次写入，然后再一次性调用底层的write，所以给你的错觉就是多次写入之间交叉了(个人理解)" target="_blank" rel="noopener">http://blog.csdn.net/zhangyifei216/article/details/76653746，fwrite的问题说白了其实就是用户态buf，会缓存多次写入，然后再一次性调用底层的write，所以给你的错觉就是多次写入之间交叉了(个人理解)</a></p>
<p>class ChatServer final  说明class ChatServer 不能被别人继承了</p>
<p>~ChatServer() = default; //c++11 类默认函数的控制：”=default” 和 “=delete”函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C++ 的类有四类特殊成员函数，它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。</span><br><span class="line">这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。</span><br><span class="line">如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。<span class="comment">// C++11 标准引入了一个新特性："=default"函数。程序员只需在函数声明后加上“=default;”，就可将该函数声明为 "=default"函数，编译器将为显式声明的 "=default"函数自动生成函数体。</span></span><br><span class="line"><span class="comment">//该函数比用户自己定义的默认构造函数获得更高的代码效率</span></span><br><span class="line"><span class="comment">// "=default"函数特性仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="keyword">default</span>;      <span class="comment">// err , 函数 f() 非类 X 的特殊成员函数</span></span><br><span class="line">    X1(<span class="keyword">int</span>, <span class="keyword">int</span>) = <span class="keyword">default</span>;  <span class="comment">// err , 构造函数 X1(int, int) 非 X 的特殊成员函数</span></span><br><span class="line">    X1(<span class="keyword">int</span> = <span class="number">1</span>) = <span class="keyword">default</span>;   <span class="comment">// err , 默认构造函数 X1(int=1) 含有默认参数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 为了能够让程序员显式的禁用某个函数，C++11 标准引入了一个新特性："=delete"函数。程序员只需在函数声明后上“=delete;”，就可将该函数禁用。</span></span><br></pre></td></tr></table></figure>

<p><em>POD</em> stands for <em>Plain Old Data</em> - that is, a class (whether defined with the keyword <code>struct</code> or the keyword <code>class</code>) without constructors, destructors and virtual members functions. <a href="http://en.wikipedia.org/wiki/Plain_Old_Data_Structures" target="_blank" rel="noopener">Wikipedia’s article on POD</a> goes into a bit more detail and defines it as:</p>
<blockquote>
<p>A Plain Old Data Structure in C++ is an aggregate class that contains only PODS as members, has no user-defined destructor, no user-defined copy assignment operator, and no nonstatic members of pointer-to-member type.</p>
</blockquote>
<p>A POD is a type (including classes) where the C++ compiler guarantees that there will be no “magic” going on in the structure: for example hidden pointers to vtables, offsets that get applied to the address when it is cast to other types (at least if the target’s POD too), constructors, or destructors. Roughly speaking, a type is a POD when the only things in it are built-in types and combinations of them. The result is something that “acts like” a C type.</p>
<p>explicit</p>
<p>使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会停止运行。nohup命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。该命令的一般形式为：<br>nohup command &amp;<br>1<br>如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件</p>
<p>//注册协议</p>
<p>//<a href="http://47.97.25.88:12345/register.do?p={&quot;username&quot;" target="_blank" rel="noopener">http://47.97.25.88:12345/register.do?p={&quot;username&quot;</a>: “13917043329”, “nickname”: “balloon”, “password”: “123”}</p>
<p>//{“code”: 0, “msg” : “ok”}</p>
<h2 id="大作业-基于B-树的数据库索引引擎"><a href="#大作业-基于B-树的数据库索引引擎" class="headerlink" title="大作业:基于B+树的数据库索引引擎"></a>大作业:基于B+树的数据库索引引擎</h2><p>目标：完成支持整数为key的数据库索引功能，提供包括insert, del, update的多线程事务操作。<br>形式要求：基于C/C++，提供上述接口，并封装为SO库。<br>实现约束：所有索引文件需统一存储在一个大文件中，索引的数据可以为任意数据结构; 需支持多线程环境，采用多生产者多消费者模型；完成持续读写压力测试，运行时间不低于12小时，插入对象不低于1千万个，观察CPU，内存，磁盘开销，并将压测分析输出到报告中。<br>提交内容：可编译的源码，可在Linux环境中运行的程序；设计文档（包括模块框架设计，重要流程图（主要是insert,del,update接口），核心数据结构，运行时截图（操作相关结果）。<br>完成时间：11.20 日前提交，提交实验报告及源代码。<br>提交邮箱： <a href="mailto:lpue2014@163.com">lpue2014@163.com</a></p>
<p>select * from db where id=838;int temp = sscanf(mp-&gt;cmd,”select * from db where id=%d;\n”, keyIndex); 1</p>
<p>总结：之前写都是什么(<em>Pointer).member,这么写太麻烦了,所以直接用箭头来省略部分书写内容<br>*</em>箭头（-&gt;）：左边必须为指针；**<br><strong>点号（.）：左边必须为实体</strong></p>
<p>acewzj is not in the sudoers file</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int to key_t</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intToKeyT</span><span class="params">(bpt::<span class="keyword">key_t</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> key[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0。因此，当只将第一个元素初始化为0时，编译器会自动将其他元素设为0 (就像前一句说的那样)。或者3.用memset函数在程序开始时初始化数组。比如：int arr[1024];memset(arr, 0, 1024); //清零</span></span><br><span class="line">	<span class="built_in">sprintf</span>(key, <span class="string">"%d"</span>, *b);</span><br><span class="line">    <span class="comment">///* Write formatted output to S.  */</span></span><br><span class="line">	<span class="comment">//extern int sprintf (char *__restrict __s,   //</span></span><br><span class="line">	<span class="comment">//	    const char *__restrict __format, ...) __THROWNL;</span></span><br><span class="line">	*a = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__restrict关键字告诉编译器额外信息(两个指针不指向同一数据),从而生成更优化的<a href="https://en.cppreference.com/w/c/language/restrict" target="_blank" rel="noopener">汇编代码</a>.</p>
<p>__THROW is meant to declare the function as capable of<br>throwing exceptions (a C++ feature). In C, the macro does nothing.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> return_code = searchRecord(duck_db_ptr,keyIndex,return_val);</span><br><span class="line"><span class="comment">//duck_db_ptr </span></span><br><span class="line"><span class="comment">// search by index</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchRecord</span><span class="params">(bplus_tree *treePtr,<span class="keyword">int</span> *index, <span class="keyword">value_t</span> *return_val)</span></span>&#123;</span><br><span class="line">    bpt::<span class="keyword">key_t</span> key;</span><br><span class="line">    intToKeyT(&amp;key,index);</span><br><span class="line">    <span class="comment">//key is key_t ype of char k[16];there is to convert index [int] -&gt; key_t</span></span><br><span class="line">	<span class="keyword">return</span> (*treePtr).search(key, return_val); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bplus_tree::search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">key_t</span>&amp; key, <span class="keyword">value_t</span> *value)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">leaf_node_t</span> leaf;</span><br><span class="line">    <span class="comment">//叶子节点包括--</span></span><br><span class="line">			<span class="comment">/* leaf node block */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">leaf_node_t</span> &#123;</span></span><br><span class="line">                <span class="keyword">typedef</span> <span class="keyword">record_t</span> *<span class="keyword">child_t</span>;</span><br><span class="line">                <span class="keyword">off_t</span> parent; <span class="comment">/* parent node offset */</span></span><br><span class="line">                <span class="keyword">off_t</span> next;<span class="comment">//双向指针</span></span><br><span class="line">                <span class="keyword">off_t</span> prev;<span class="comment">//双向指针</span></span><br><span class="line">                <span class="keyword">size_t</span> n;<span class="comment">//</span></span><br><span class="line">                <span class="keyword">record_t</span> children[BP_ORDER];</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">map</span>(&amp;leaf, search_leaf(key));</span><br><span class="line">    	    <span class="function"><span class="keyword">off_t</span> <span class="title">search_leaf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">key_t</span> &amp;key)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> search_leaf(search_index(key), key);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//根据key找出index?--&gt;key只是key,index</span></span><br><span class="line">                    <span class="function"><span class="keyword">off_t</span> <span class="title">bplus_tree::search_index</span><span class="params">(<span class="keyword">const</span> <span class="keyword">key_t</span> &amp;key)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    <span class="keyword">off_t</span> org = meta.root_offset;</span><br><span class="line">                    <span class="keyword">int</span> <span class="built_in">height</span> = meta.<span class="built_in">height</span>;</span><br><span class="line">                        <span class="comment">//root不是第一个元素,肯定是居中的元素,所以需要记录一下root 的偏移记录</span></span><br><span class="line">                        <span class="comment">//meta</span></span><br><span class="line">                        <span class="comment">/* meta information of B+ tree */</span></span><br><span class="line">                        <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                            <span class="keyword">size_t</span> order; <span class="comment">/* `order` of B+ tree */</span>阶?有<span class="number">50</span>个子节点</span><br><span class="line">                            <span class="keyword">size_t</span> value_size; <span class="comment">/* size of value */</span>  <span class="number">516</span>=<span class="number">256</span>+<span class="number">256</span>+<span class="number">4</span></span><br><span class="line">                            <span class="keyword">size_t</span> key_size;   <span class="comment">/* size of key */</span>    <span class="number">16</span></span><br><span class="line">                            <span class="keyword">size_t</span> internal_node_num; <span class="comment">/* how many internal nodes */</span><span class="number">8</span>个内部节点</span><br><span class="line">                            <span class="keyword">size_t</span> leaf_node_num;     <span class="comment">/* how many leafs */</span>  <span class="number">192</span>个叶子节点</span><br><span class="line">                            <span class="keyword">size_t</span> <span class="built_in">height</span>;            <span class="comment">/* height of tree (exclude leafs) */</span><span class="number">2</span></span><br><span class="line">                            <span class="keyword">off_t</span> slot;        <span class="comment">/* where to store new block */</span></span><br><span class="line">                            <span class="keyword">off_t</span> root_offset; <span class="comment">/* where is the root of internal nodes */</span></span><br><span class="line">                            <span class="keyword">off_t</span> leaf_offset; <span class="comment">/* where is the first leaf */</span></span><br><span class="line">                        &#125; <span class="keyword">meta_t</span>;</span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line">                    <span class="keyword">while</span> (<span class="built_in">height</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">internal_node_t</span> node;</span><br><span class="line">                        <span class="built_in">map</span>(&amp;node, org);</span><br><span class="line">                            <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">                                <span class="title">int</span> <span class="title">map</span>(<span class="title">T</span> *<span class="title">block</span>, <span class="title">off_t</span> <span class="title">offset</span>) <span class="title">const</span></span></span><br><span class="line"><span class="class">                            &#123;</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="built_in">map</span>(block, offset, <span class="keyword">sizeof</span>(T));</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/* read block from disk */</span></span><br><span class="line">                                <span class="function"><span class="keyword">int</span> <span class="title">map</span><span class="params">(<span class="keyword">void</span> *block, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">                                </span>&#123;</span><br><span class="line">                                    open_file();</span><br><span class="line">                                    fseek(fp, offset, SEEK_SET);</span><br><span class="line">                                    <span class="keyword">size_t</span> rd = fread(block, <span class="built_in">size</span>, <span class="number">1</span>, fp);</span><br><span class="line">                                    close_file();</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">return</span> rd - <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">index_t</span> *i = upper_bound(<span class="built_in">begin</span>(node), <span class="built_in">end</span>(node) - <span class="number">1</span>, key);</span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line">                        org = i-&gt;child;</span><br><span class="line">                        --<span class="built_in">height</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> org;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<h4 id="fread"><a href="#fread" class="headerlink" title="fread:"></a>fread:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span></span><br><span class="line">ptr -- 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。</span><br><span class="line"><span class="built_in">size</span> -- 这是要读取的每个元素的大小，以字节为单位。</span><br><span class="line">nmemb -- 这是元素的个数，每个元素的大小为 <span class="built_in">size</span> 字节。</span><br><span class="line">stream -- 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。</span><br><span class="line">返回值</span><br></pre></td></tr></table></figure>

<p>search_index只是要找到key所对应的偏移地址–怎么找到呢?</p>
<p>首先找到根的偏移,然后取出根的偏移在文件中的数据,有偏移[起始地址]+数据类型大小[long 8]bit parent next prev n children  ,相当于反序列化?从磁盘上复活数据对象哈哈,</p>
<p>接着根据这个数据,因为数据里面有一个数组[50阶]的,从这里面找到比key要大的那个.这是因为在节点里面数组从左到右依次增大.</p>
<p>接着一层一层的往下找它的孩子?它的孩子里面存着是</p>
<p>update db 111 23 <a href="mailto:123@163.com">123@163.com</a> where id=1;</p>
<p>select * from db where id in(0,9);</p>
<p>insert db 5002 acej 25 <a href="mailto:acewzj@qq.com">acewzj@qq.com</a>;</p>
<p>delete from db where id=2; </p>
<p>在 B+树中删除关键字时，有以下几种情况：</p>
<p>2、 当删除某结点中最大或者最小的关键字，就会涉及到更改其双亲结点一直到根结点中所有索引值的更改。</p>
<p>例如，在图 1的 B+树中删除关键字 97，删除后的 B+树如图 6 所示：<img src="http://data.biancheng.net/uploads/allimg/171024/2-1G024141030209.png" alt=""></p>
<p>当删除该关键字，导致当前结点中关键字个数小于<code>⌈M/2⌉</code><br>，若其兄弟结点中含有多余的关键字，可以从兄弟结点中借关键字完成删除操作。例如，在图 1 的 B+树中删除关键字 51，由于其兄弟结点中含有 3 个关键字，所以可以选择借一个关键字，同时修改双亲结点中的索引值，删除之后的 B+树如图 7 所示：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/171024/2-1G024141129106.png" alt=""></p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>0 begin wait a condition…<br>1 begin wait a condition…<br>2 begin wait a condition…</p>
<p>0 begin produce product…<br>produce 86<br>0 end produce product…</p>
<ul>
<li><strong>以默认方式启动的线程，在线程结束后不会自动释放占有的系统资源，要在主控线程中调用pthread_join()后才会释放</strong></li>
<li><strong>以分离状态启动的线程，在线程结束后会自动释放所占有的系统资源,这个时候就不需要调用pthread_join方法了</strong></li>
</ul>
<h2 id="Segmentation-fault"><a href="#Segmentation-fault" class="headerlink" title="Segmentation fault"></a><strong>Segmentation fault</strong></h2><p>所谓的段错误就是指访问的内存超过了系统所给这个程序的内存空间，通常这个值是由gdtr来保存的，他是一个48位的寄存器，其中的32位是保存由它指向的gdt表，后13位保存相应于gdt的下标，最后3位包括了程序是否在内存中以及程序的在cpu中的运行级别,指向的gdt是由以64位为一个单位的表，在这张表中就保存着程序运行的代码段以及数据段的起始地址以及相应的断限和页面交换还有程序运行级别和内存粒度等信息，一旦一个程序发生了越界访问，CPU就会产生相应的异常保护，于是segmentation fault就出现了。即“当程序试图访问不被允许访问的内存区域（比如，尝试写一块属于操作系统的内存），或以错误的类型访问内存区域（比如，尝试写一块只读内存）。这个描述是准确的。为了加深理解，我们再更加详细的概括一下SIGSEGV。段错误应该就是访问了不可访问的内存，这个内存要么是不存在的，要么是受系统保护的。</p>
<p>指针越界和SIGSEGV是最常出现的情况，经常看到有帖子把两者混淆，而这两者的关系也确实微妙。在此，我们把指针运算（加减）引起的越界、野指针、空指针都归为指针越界。SIGSEGV在很多时候是由于指针越界引起的，但并不是所有的指针越界都会引发SIGSEGV。一个越界的指针，如果不引用它，是不会引起SIGSEGV的。而即使引用了一个越界的指针，也不一定引起SIGSEGV。这听上去让人发疯，而实际情况确实如此。SIGSEGV涉及到操作系统、C库、编译器、链接器各方面的内容，我们以一些具体的例子来说明。</p>
<p>（1）错误的访问类型引起</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *c = <span class="string">"hello world"</span>;</span><br><span class="line">    c[<span class="number">1</span>] = <span class="string">'H'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序编译没有问题，但是运行时弹出SIGSEGV。此例中，”hello world”作为一个常量字符串，在编译后会被放在.rodata节（GCC），最后链接生成目标程序时.rodata节会被合并到text segment与代码段放在一起，故其所处内存区域是只读的。这就是错误的访问类型引起的SIGSEGV。</p>
<p>上述程序编译没有问题，但是运行时弹出SIGSEGV。此例中，”hello world”作为一个常量字符串，在编译后会被放在.rodata节（GCC），最后链接生成目标程序时.rodata节会被合并到text segment与代码段放在一起，故其所处内存区域是只读的。这就是错误的访问类型引起的SIGSEGV。</p>
<p>（2）访问了不属于进程地址空间的内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="number">0xC0000fff</span>; </span><br><span class="line">    *p = <span class="number">10</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种可能，往受到系统保护的内存地址写数据，最常见的就是给一个指针以0地址；</p>
<p>还有一种可能，往受到系统保护的内存地址写数据，最常见的就是给一个指针以0地址；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  i=<span class="number">0</span>; </span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>, i);  <span class="comment">/* should have used &amp;i */</span> </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>（3）访问了不存在的内存<br>最常见的情况不外乎解引用空指针了，如：</p>
<p>（3）访问了不存在的内存<br>最常见的情况不外乎解引用空指针了，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = null;</span><br><span class="line">*p = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在实际情况中，此例中的空指针可能指向用户态地址空间，但其所指向的页面实际不存在。</p>
<p>（4）内存越界，数组越界，变量类型不一致等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">char</span> test[<span class="number">1</span>]; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, test[<span class="number">10</span>]); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是明显的数组越界了，或者这个地址根本不存在。</p>
<p>这就是明显的数组越界了，或者这个地址根本不存在。</p>
<p>（5）试图把一个整数按照字符串的方式输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是什么问题呢？由于还不熟悉调试动态链接库，所以我只是找到了printf的源代码的这里。</p>
<p>这是什么问题呢？由于还不熟悉调试动态链接库，所以我只是找到了printf的源代码的这里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">声明部分：</span><br><span class="line">   <span class="keyword">int</span> pos =<span class="number">0</span> ,cnt_printed_chars =<span class="number">0</span> ,i ;</span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">char</span> *chptr ;</span><br><span class="line">　　va_list ap ;</span><br><span class="line">%s格式控制部分：</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">　　    chptr =va_arg (ap ,<span class="keyword">unsigned</span> <span class="keyword">char</span> *);</span><br><span class="line">　　    i =<span class="number">0</span> ;</span><br><span class="line">　　    <span class="keyword">while</span> (chptr [i ])</span><br><span class="line">　　    &#123;...</span><br><span class="line">　　        cnt_printed_chars ++;</span><br><span class="line">　　        <span class="built_in">putchar</span> (chptr [i ++]);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看看，发现了这样一个问题，在打印字符串的时候，实际上是打印某个地址开始的所有字符，但是当你想把整数当字符串打印的时候，这个整数被当成了一个地址，然后printf从这个地址开始去打印字符，直到某个位置上的值为\0。所以，如果这个整数代表的地址不存在或者不可访问，自然也是访问了不该访问的内存——segmentation fault。<br> 类似的，还有诸如：sprintf等的格式控制问题，比如，试图把char型或者是int的按照%s输出或存放起来，如：</p>
<p>仔细看看，发现了这样一个问题，在打印字符串的时候，实际上是打印某个地址开始的所有字符，但是当你想把整数当字符串打印的时候，这个整数被当成了一个地址，然后printf从这个地址开始去打印字符，直到某个位置上的值为\0。所以，如果这个整数代表的地址不存在或者不可访问，自然也是访问了不该访问的内存——segmentation fault。<br> 类似的，还有诸如：sprintf等的格式控制问题，比如，试图把char型或者是int的按照%s输出或存放起来，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> c=<span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, c);        <span class="comment">//试图把char型按照字符串格式输出，这里的字符会解释成整数，再解释成地址，所以原因同上面那个例子</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, i);            <span class="comment">//试图把int型按照字符串输出</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%s"</span>, c);    <span class="comment">//试图把char型按照字符串格式转换</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%s"</span>, i);   <span class="comment">//试图把int型按照字符串转换</span></span><br></pre></td></tr></table></figure>

<p>（6）栈溢出了，有时SIGSEGV，有时却啥都没发生<br>大部分C语言教材都会告诉你，当从一个函数返回后，该函数栈上的内容会被自动“释放”。“释放”给大多数初学者的印象是free()，似乎这块内存不存在了，于是当他访问这块应该不存在的内存时，发现一切都好，便陷入了深深的疑惑。</p>
<p>防止Segmentation fault的出现需要注意：</p>
<p>定义了指针以后记得初始化，在使用的时候记得判断是否为NULL；<br>在使用数组的时候是否被初始化，数组下标是否越界，数组元素是否存在等；<br>在变量处理的时候变量的格式控制是否合理等；</p>
<h2 id="十字符病毒"><a href="#十字符病毒" class="headerlink" title="十字符病毒"></a>十字符病毒</h2><h2 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h2><p><img src="https://i.loli.net/2020/03/29/eBJXV7INS8iyxgU.png" alt="image-20191225114928880"></p>
<p><img src="https://i.loli.net/2020/03/30/NC1otVh5ZeDjTUa.png" alt="image-20191225120846398"></p>
<p>此外，还发现第一个进程占用很大cpu资源，就是名为apgffcztwi的进程，这个进程名刚好10个字符，这是什么进程，名字相当古怪，肯定有问题，从文件名看出，这不像一个正常的系统进程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acewzj.github.io/2019/08/18/2019-08-20-SourceDebug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="acewzj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acewzj">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/2019-08-20-SourceDebug/" itemprop="url"> 在VS2017中实现OpenCV源码级调试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-18T10:16:18+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>这篇文章主要记述了在VS2017中实现OpenCV源码级调试。</p>
<h2 id="在VS2017中实现OpenCV源码级调试"><a href="#在VS2017中实现OpenCV源码级调试" class="headerlink" title="在VS2017中实现OpenCV源码级调试"></a>在VS2017中实现OpenCV源码级调试</h2><p>0.需要把<code>opencv</code>的源码路径加上，在<code>配置属性-&gt;vc++目录-&gt;源目录</code>，<code>C:\Program Files\opencv\sources\modules</code></p>
<p>1.<code>cmake</code>编译<code>opencv</code>源码，如果是<code>OpenCV3.0</code>以上版本可以勾选<code>Build OpenCV_World</code>选项，这样可以使得编译的最终结果是一个总的<code>dll</code>等文件，省的一个一个<code>dll</code>文件添加了。然后打开<code>opencv.sln</code>，<code>Debug</code>，<code>release</code>下都<code>build</code>一遍。这时会出现<code>bin</code>文件，<code>lib</code>文件，以及<code>install</code>文件：<code>bin文件</code>你会发现有了<code>dll</code>，还有<code>pdb</code>文件，一一对应，<code>lib</code>文件同样也多了<code>exp</code>文件；<br>而install文件你会发现和一键安装opencv时生成的文件一样， 有lib include bin；</p>
<p>2.打开<code>工具-&gt;选项-&gt;调试-&gt;符号</code>，在<code>Microsoft</code>符号服务器下右上角有个添加，我输入<code>opencv_world340d.pdb</code>，然后运行，看输出窗口还是提示说 无法查找或打开 <code>PDB</code>文件，，又发现右上角是文件夹的新建,接着把debug的pdb路径输入，在运行程序加断点，完美，输出窗口 </p>
<p>3.在opencv自带函数处加断点，F11，哇，cvLoadImage(), 调到opencv的src文件内的<code>d:\opencv340\opencv\sources\modules\highgui\src\loadsave.cpp</code>，可以看到<code>oepncv</code>自带函数的实现了，点云库<code>PCL</code>想看源码，也一样</p>
<ul>
<li>debug下，F11单步执行才可以进入opencv源码的cpp.</li>
</ul>
<blockquote>
<p>之前怎么也不成功是因为生成的Opencv_world340d.dll不对，正经生成出来的是150M</p>
</blockquote>
<p><img src="image-20191219213007592.png" alt="image-20191219213007592"></p>
<h2 id="OpencvCmake"><a href="#OpencvCmake" class="headerlink" title="OpencvCmake"></a>OpencvCmake</h2><ul>
<li>如果根据上面设置之后，编译还会有同样的错误，可以直接注释发生错误的地方。 经过一番搜索之后，发现是因为vtk8.10之后的版本中将vtkMapper的ImmediateModeRenderingOff()方法移除了，所以为了让pcl1.9.1代码编译通过，只需要将错误提示中对应的那一行代码注释掉即可，或者更换为更低版本的vtk也行。我是通过注释掉上述出错的两行代码，因为ImmediateModeRenderingOff()方法不是必须的操作，最后通过了编译。</li>
<li>libConfig++，注意生成的要是64位的Lib&amp;DLL</li>
<li>boost连接</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acewzj.github.io/2019/07/20/2019-07-20-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="acewzj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acewzj">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/2019-07-20-C/" itemprop="url">一个程序在计算机中到底是如何运行的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-20T10:16:18+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Structure/" itemprop="url" rel="index">
                    <span itemprop="name">Data_Structure</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>这篇文章记述了关于程序编译的知识点。</p>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><p>好了，我们回到我们的主题：堆和栈究竟有什么区别？</p>
<p>主要的区别由以下几点：</p>
<p>1、管理方式不同；</p>
<p>2、空间大小不同；</p>
<p>3、能否产生碎片不同；</p>
<p>4、生长方向不同；</p>
<p>5、分配方式不同；</p>
<p>6、分配效率不同；</p>
<p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br>空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：</p>
<p>打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。</p>
<p>注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。</p>
<p>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p>
<p>生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p>
<p>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
<p>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p>
<p>从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址， EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。<br>虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</p>
<p>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的：）</p>
<p>对了，还有一件事，如果有人把堆栈合起来说，那它的意思是栈，可不是堆，呵呵，清楚了？</p>
<p>堆栈溢出就是不顾堆栈中数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了老的堆栈数据。</p>
<h2 id="C语言内存模型及运行时内存布局"><a href="#C语言内存模型及运行时内存布局" class="headerlink" title="C语言内存模型及运行时内存布局"></a>C语言内存模型及运行时内存布局</h2><p><img src="https://i.loli.net/2019/09/06/DXrJUICwidhme6s.png" alt=""></p>
<p>1、代码段（Code）</p>
<p>代码段由程序中执行的机器代码组成。在C语言中，程序语句执行编译后，形成机器代码。</p>
<p>2、只读数据段(RO Data)</p>
<p>只读数据段由程序中所使用的数据产生，该部分数据的特点在运行中不需要改变，因此编译器会将数据放入只读的部分中。C语言的一些语法将生成只读数据数据段。以下情况将生成只读数据段。</p>
<p><u>只读全局变量</u></p>
<p>定义全局变量const  char a[100]=”abcdefg”将生成大小为100个字节的只读数据区，并使用字符串“abcdefg”初始化。如果定义为const char a[]=”abcdefg”,没有指定大小，将根据“abcdefgh”字串的长度，生成8个字节的只读数据段。</p>
<p> <u>只读局部变量</u></p>
<p>例如：在函数内部定义的变量const char  b[100]=”9876543210”;其初始化的过程和全局变量。</p>
<p> <u>程序中使用的常量</u></p>
<p>例如：在程序中使用printf(“information\n”),其中包含了字串常量，编译器会自动把常量“information \n”放入只读数据区。</p>
<p>3.读写数据段（RW Data）<br>读写数据段表示了在目标文件中一部分可以读也可以写的数据区，在某些场合它们又被称为已初始化数据段。这部分数据段和代码，与只读数据段一样都属于程序中的静态区域，但是具有科协的特点。</p>
<p><u>已初始化全局变量</u></p>
<p>例如：在函数外部，定义全局的变量char  a[100]=”abcdefg”</p>
<p><u>已初始化局部静态变量</u></p>
<p>例如：在函数中定义static  char b[100]=”9876543210”。函数中由static定义并且已经初始化的数据和数组将被编译为读写数据段。<br>说明：</p>
<p>读写数据区的特点是必须在程序中经过初始化，如果只有定义，没有初始值，则不会生成读写数据区，而会定义为未初始化数据区(BSS)。如果全局变量（函数外部定义的变量）加入static修饰符，写成static  char a[100]的形式，这表示只能在文件内部使用，而不能被其他文件使用。</p>
<p>4.未初始化数据段(BSS)</p>
<p>未初始化数据段常被称之为BSS(英文名为Block start by symbol的缩写)。与读写数据段类似，它也属于静态数据区。但是该段中数据没有经过初始化。因此它只会在目标文件中被标识，而不会真正称为目标文件中的一个段，该段将会在运行时产生。未初始化数据段只有在运行的初始化阶段才会产生，因此它的大小不会影响目标文件的大小。</p>
<p><u>在C语言的程序中，对变量的使用还有以下注意</u>：</p>
<p>1.在函数体中定义的变量通常是在栈上，不需要在程序中进行管理，由编译器处理。</p>
<p>2.用malloc，calloc,realoc等分配分配内存的函数所分配的内存空间在堆上，程序必须保证在使用后使用后freee释放，否则会发生内存泄漏。</p>
<p>3.所有函数体外定义的是全局变量，加了static修饰符后的变量不管在函数内部或者外部存放在全局区（静态区）。</p>
<p>4.使用const定义的变量将放于程序的只读数据区。</p>
<p>说明：</p>
<p>在C语言中，可以定义static变量：在函数体内定义的static变量只能在该函数体内有效；在所有函数体外定义的static变量，也只能在该文件中有效，不能在其他源文件中使用；对于没有使用static修饰的全局变量，可以在其他的源文件中使用。这些区别是编译的概念，即如果不按要求使用变量，编译器会报错。使用static 和没使用static修饰的全局变量最终都将放置在程序的全局去（静态去）。<br><em>这里我有一个问题：如果形参是Constant常量，那么是将它分配到常量区还是堆栈呢？分配到常量区不太可能，因为常量区是编译时就已经确定好的，不能再动态的添加常量了，如果分配到堆栈又怎么能保证它是一个常量呢？</em></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="Linux下C语言程序的内存布局"><a href="#Linux下C语言程序的内存布局" class="headerlink" title="Linux下C语言程序的内存布局"></a>Linux下C语言程序的内存布局</h1><p>程序内存在地址空间中的分布情况称为内存模型（Memory Model）。内存模型由操作系统构建，在Linux和Windows下有所差异，并且会受到编译模式的影响，本节我们讲解Linux下32位环境和64位环境的内存模型。</p>
<h2 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h2><p>对于32位环境，理论上程序可以拥有 4GB 的虚拟地址空间，我们在C语言中使用到的变量、函数、字符串等都会对应内存中的一块区域。</p>
<p>但是，在这 4GB 的地址空间中，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间（Kernel Space）。</p>
<p>Windows 在默认情况下会将高地址的 2GB 空间分配给内核（也可以配置为1GB），而 Linux 默认情况下会将高地址的 1GB 空间分配给内核。也就是说，应用程序只能使用剩下的 2GB 或 3GB 的地址空间，称为用户空间（User Space）。</p>
<h2 id="Linux下32位环境的用户空间内存分布情况"><a href="#Linux下32位环境的用户空间内存分布情况" class="headerlink" title="Linux下32位环境的用户空间内存分布情况"></a>Linux下32位环境的用户空间内存分布情况</h2><p>我们暂时不关心内核空间的内存分布情况，下图是Linux下32位环境的一种经典内存模型：</p>
<p><img src="image-20200330162632564.png" alt="image-20200330162632564"></p>
<p>对各个内存分区的说明：</p>
<table>
<thead>
<tr>
<th>内存分区</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>程序代码区 (code)</td>
<td>存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用。</td>
</tr>
<tr>
<td>常量区 (constant)</td>
<td>存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。</td>
</tr>
<tr>
<td>全局数据区 (global data)</td>
<td>存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。</td>
</tr>
<tr>
<td>堆区 (heap)</td>
<td>一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。malloc()、calloc()、free() 等函数操作的就是这块内存，这也是本章要讲解的重点。  注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。</td>
</tr>
<tr>
<td>动态链接库</td>
<td>用于在程序运行期间加载和卸载动态链接库。</td>
</tr>
<tr>
<td>栈区 (stack)</td>
<td>存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。</td>
</tr>
</tbody></table>
<p>在这些内存分区中（暂时不讨论动态链接库），程序代码区用来保存指令，常量区、全局数据区、堆、栈都用来保存数据。对内存的研究，重点是对数据分区的研究。</p>
<p>程序代码区、常量区、全局数据区在程序加载到内存后就分配好了，并且在程序运行期间一直存在，不能销毁也不能增加（大小已被固定），只能等到程序运行结束后由操作系统收回，所以全局变量、字符串常量等在程序的任何地方都能访问，因为它们的内存一直都在。</p>
<blockquote>
<p>常量区和全局数据区有时也被合称为静态数据区，意思是这段内存专门用来保存数据，在程序运行期间一直存在。</p>
</blockquote>
<p>函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。</p>
<p>常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制。程序员唯一能控制的内存区域就是堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用。</p>
<h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2><p>为了加深对内存布局的理解，请大家看下面一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> *str1 = <span class="string">"c.net"</span>;  <span class="comment">//字符串在常量区，str1在全局数据区</span></span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//全局数据区</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"C语言"</span>;  <span class="comment">//字符串在常量区，str在栈区</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;  <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">"01234"</span>;  <span class="comment">//字符串在常量区，str2在栈区</span></span><br><span class="line">    <span class="keyword">char</span>  arr[<span class="number">20</span>] = <span class="string">"56789"</span>;  <span class="comment">//字符串和arr都在栈区</span></span><br><span class="line">    <span class="keyword">char</span> *pstr = func();  <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">int</span> b;  <span class="comment">//栈区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1: %#X\npstr: %#X\nstr2: %#X\n"</span>, str1, pstr, str2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"--------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;str1: %#X\n   &amp;n: %#X\n"</span>, &amp;str1, &amp;n);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"--------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  &amp;a: %#X\n arr: %#X\n  &amp;b: %#X\n"</span>, &amp;a, arr, &amp;b);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"--------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n: %d\na :%d\nb: %d\n"</span>, n, a, b);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"--------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, pstr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str1: <span class="number">0X400710</span></span><br><span class="line">pstr: <span class="number">0X400720</span></span><br><span class="line">str2: <span class="number">0X400731</span></span><br><span class="line">--------------</span><br><span class="line">&amp;str1: <span class="number">0X601040</span></span><br><span class="line">   &amp;n: <span class="number">0X60104C</span></span><br><span class="line">--------------</span><br><span class="line"> &amp;a: <span class="number">0X19D0728C</span></span><br><span class="line">arr: <span class="number">0X19D07270</span></span><br><span class="line"> &amp;b: <span class="number">0X19D0726C</span></span><br><span class="line">--------------</span><br><span class="line">n: <span class="number">0</span></span><br><span class="line">a: <span class="number">-858993460</span></span><br><span class="line">b: <span class="number">-858993460</span></span><br><span class="line">--------------</span><br><span class="line">C语言</span><br></pre></td></tr></table></figure>

<p>  对代码的说明：</p>
<p>1) 全局变量的内存在编译时就已经分配好了，它的默认初始值是 0（它所占用的每一个字节都是0值），局部变量的内存在函数调用时分配，它默认初始值是不确定的，由编译器决定，一般是垃圾值，这在详细分析一个函数进栈出栈的例子中会详细讲解。</p>
<p>2) 函数 func() 中的局部字符串常量<code>&quot;C语言&quot;</code>也被存储到常量区，不会随着 func() 的运行结束而销毁，所以最后依然能够输出。</p>
<p>3) 字符数组 arr[20] 在栈区分配内存，字符串<code>&quot;56789&quot;</code>就保存在这块内存中，而不是在常量区，大家要注意区分。  </p>
<h1 id="Windows下C语言程序的内存布局"><a href="#Windows下C语言程序的内存布局" class="headerlink" title="Windows下C语言程序的内存布局"></a>Windows下C语言程序的内存布局</h1><p>在32位环境下，Windows 默认会将高地址的 2GB 空间分配给内核（也可以配置为1GB），而将剩下的 2GB 空间分配给用户程序。</p>
<p>不像 Linux，Windows 是闭源的，有版权保护，资料较少，不好深入研究每一个细节，至今仍有一些内部原理不被大家知晓。关于 Windows 地址空间的内存分布，官网上只给出了简单的说明：</p>
<ul>
<li>对于32位程序，内核占用较高的 2GB，剩下的 2GB 分配给用户程序；</li>
<li>对于64位程序，内核占用最高的 248TB，用户程序占用最低的 8TB。</li>
</ul>
<p>下图是一个典型的 Windows 32位程序的内存分布：</p>
<p><img src="image-20200330162558813.png" alt="image-20200330162558813"></p>
<p>  可以看到，Windows 的地址空间被分配给了各种 exe、dll 文件、堆、栈。其中 exe 文件一般位于 0x00400000 起始的地址；一部分 DLL 位于 0x10000000 起始的地址，如运行库 dll；还有一部分 DLL 位于接近 0x80000000 的位置，如系统 dll，Ntdll.dll、Kernel32.dll。</p>
<p>栈的位置则在 0x00030000 和 exe 文件后面都有分布，可能有读者奇怪为什么 Windows 需要这么多栈呢？我们知道，每个线程的栈都是独立的，所以一个进程中有多少个线程，就有多少个对应的栈，对于 Windows 来说，每个线程默认的栈大小是 1MB。</p>
<p>在分配完上面这些地址以后，Windows 的地址空间已经是支离破碎了。当程序向系统申请堆空间时，只好从这些剩下的还有没被占用的地址上分配。  </p>
<h1 id="内核模式和用户模式"><a href="#内核模式和用户模式" class="headerlink" title="内核模式和用户模式"></a>内核模式和用户模式</h1><p>  首先我们要解释一个概念——进程（Process）。简单来说，一个可执行程序就是一个进程，前面我们使用C语言编译生成的程序，运行后就是一个进程。进程最显著的特点就是拥有独立的地址空间。</p>
<p>严格来说，程序是存储在磁盘上的一个文件，是指令和数据的集合，是一个静态的概念；进程是程序加载到内存运行后一系列的活动，是一个动态的概念。</p>
<p>前面我们在讲解地址空间时，一直说“程序的地址空间”，这其实是不严谨的，应该说“进程的地址空间”。一个进程对应一个地址空间，而一个程序可能会创建多个进程。  </p>
<p>内核空间存放的是操作系统内核代码和数据，是被所有程序共享的，在程序中修改内核空间中的数据不仅会影响操作系统本身的稳定性，还会影响其他程序，这是非常危险的行为，所以操作系统禁止用户程序直接访问内核空间。</p>
<p>要想访问内核空间，必须借助操作系统提供的 API 函数，执行内核提供的代码，让内核自己来访问，这样才能保证内核空间的数据不会被随意修改，才能保证操作系统本身和其他程序的稳定性。</p>
<p>用户程序调用系统 API 函数称为系统调用（System Call）；发生系统调用时会暂停用户程序，转而执行内核代码（内核也是程序），访问内核空间，这称为内核模式（Kernel Mode）。</p>
<p>用户空间保存的是应用程序的代码和数据，是程序私有的，其他程序一般无法访问。当执行应用程序自己的代码时，称为用户模式（User Mode）。</p>
<p>计算机会经常在内核模式和用户模式之间切换：</p>
<ul>
<li>当运行在用户模式的应用程序需要输入输出、申请内存等比较底层的操作时，就必须调用操作系统提供的 API 函数，从而进入内核模式；</li>
<li>操作完成后，继续执行应用程序的代码，就又回到了用户模式。</li>
</ul>
<p>总结：用户模式就是执行应用程度代码，访问用户空间；内核模式就是执行内核代码，访问内核空间（当然也有权限访问用户空间）。</p>
<h2 id="为什么要区分两种模式"><a href="#为什么要区分两种模式" class="headerlink" title="为什么要区分两种模式"></a>为什么要区分两种模式</h2><p>我们知道，内核最主要的任务是管理硬件，包括显示器、键盘、鼠标、内存、硬盘等，并且内核也提供了接口（也就是函数），供上层程序使用。当程序要进行输入输出、分配内存、响应鼠标等与硬件有关的操作时，必须要使用内核提供的接口。但是用户程序是非常不安全的，内核对用户程序也是充分不信任的，当程序调用内核接口时，内核要做各种校验，以防止出错。</p>
<p>从 Intel 80386 开始，出于安全性和稳定性的考虑，CPU 可以运行在 ring0 ~ ring3 四个不同的权限级别，也对数据提供相应的四个保护级别。不过 Linux 和 Windows 只利用了其中的两个运行级别：</p>
<ul>
<li>一个是内核模式，对应 ring0 级，操作系统的核心部分和设备驱动都运行在该模式下。</li>
<li>另一个是用户模式，对应 ring3 级，操作系统的用户接口部分（例如 Windows API）以及所有的用户程序都运行在该级别。</li>
</ul>
<h2 id="为什么内核和用户程序要共用地址空间"><a href="#为什么内核和用户程序要共用地址空间" class="headerlink" title="为什么内核和用户程序要共用地址空间"></a>为什么内核和用户程序要共用地址空间</h2><p>既然内核也是一个应用程序，为何不让它拥有独立的4GB地址空间，而是要和用户程序共享、占用有限的内存呢？</p>
<p>让内核拥有完全独立的地址空间，就是让内核处于一个独立的进程中，这样每次进行系统调用都需要切换进程。切换进程的消耗是巨大的，不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、MMU中的页表缓存失效，这将导致内存的访问在一段时间内相当低效。</p>
<p>而让内核和用户程序共享地址空间，发生系统调用时进行的是模式切换，模式切换仅仅需要寄存器进栈出栈，不会导致缓存失效；现代CPU也都提供了快速进出内核模式的指令，与进程切换比起来，效率大大提高了。</p>
<h1 id="栈的概念以及栈溢出"><a href="#栈的概念以及栈溢出" class="headerlink" title="栈的概念以及栈溢出"></a>栈的概念以及栈溢出</h1><p>在C语言程序的内存布局（内存模型）中我们讲到，程序的虚拟地址空间分为多个区域，栈（Stack）是其中地址较高的一个区域。栈（Stack）可以存放函数参数、局部变量、局部数组等作用范围在函数内部的数据，它的用途就是完成函数的调用。</p>
<p>栈内存由系统自动分配和释放：发生函数调用时就为函数运行时用到的数据分配内存，函数调用结束后就将之前分配的内存全部销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部。</p>
<h2 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h2><p>在计算机中，栈可以理解为一个特殊的容器，用户可以将数据依次放入栈中，然后再将数据按照相反的顺序从栈中取出。也就是说，先放入的数据最后才能取出，而最后放入的数据必须先取出。这称为先进后出（First In Last Out）原则。</p>
<p>放入数据常称为入栈或压栈（Push），取出数据常称为出栈或弹出（Pop）。如下图所示：</p>
<p><img src="image-20200330162457434.png" alt="image-20200330162457434"><br>图：数据的出栈和入栈</p>
<p>可以发现，栈底始终不动，出栈入栈只是在移动栈顶，当栈中没有数据时，栈顶和栈底重合。</p>
<p>从本质上来讲，栈是一段连续的内存，需要同时记录栈底和栈顶，才能对当前的栈进行定位。在现代计算机中，通常使用<code>ebp</code>寄存器指向栈底，而使用<code>esp</code>寄存器指向栈顶。随着数据的进栈出栈，esp 的值会不断变化，进栈时 esp 的值减小，出栈时 esp 的值增大。</p>
<blockquote>
<p>ebp 和 esp 都是CPU中的寄存器：ebp 是 Extend Base Pointer 的缩写，通常用来指向栈底；esp 是 Extend Stack Pointer 的缩写，通常用来指向栈顶。</p>
</blockquote>
<p>如下图所示是一个栈的实例：</p>
<p><img src="image-20200330162526230.png" alt="image-20200330162526230"></p>
<h2 id="栈的大小以及栈溢出"><a href="#栈的大小以及栈溢出" class="headerlink" title="栈的大小以及栈溢出"></a>栈的大小以及栈溢出</h2><p>对每个程序来说，栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误。</p>
<blockquote>
<p>一个程序可以包含多个线程，每个线程都有自己的栈，严格来说，栈的最大值是针对线程来说的，而不是针对程序。</p>
</blockquote>
<p>栈内存的大小和编译器有关，编译器会为栈内存指定一个最大值，在 VC/VS 下，默认是 1M，在 C-Free 下，默认是 2M，在 Linux GCC 下，默认是 8M。</p>
<p>当然，我们也可以通过参数来修改栈内存的大小。以 VS2010 为例，在工程名处右击，会弹出一个菜单，选择“属性”，会出现一个对话框，如下图所示：</p>
<p><img src="image-20200330162741103.png" alt="image-20200330162741103"></p>
<p>该图中，我们将栈内存设置为 4M。提示：栈也经常被称为堆栈，而堆依然称为堆，所以堆栈这个概念并不包含堆，大家要注意区分。</p>
<p>当程序使用的栈内存大于默认值（或者修改后的值）时，就会发生栈溢出（Stack Overflow）错误。使用 VS2010 并切换到 Debug 模式，运行如下的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>局部字符数组 str 存储在栈上，占用 2M 的内存，超出了默认值 1M，所以会发生栈溢出错误，如下图所示：</p>
<p><img src="image-20200330162804520.png" alt="image-20200330162804520"></p>
<h1 id="c语言入门-一个函数在栈上到底是怎样的"><a href="#c语言入门-一个函数在栈上到底是怎样的" class="headerlink" title="c语言入门-一个函数在栈上到底是怎样的"></a>c语言入门-一个函数在栈上到底是怎样的</h1><p>函数的调用和栈是分不开的，没有栈就没有函数调用，本节就来讲解函数在栈上是如何被调用的。</p>
<h2 id="栈帧-活动记录"><a href="#栈帧-活动记录" class="headerlink" title="栈帧/活动记录"></a>栈帧/活动记录</h2><p>当发生函数调用时，会将函数运行需要的信息全部压入栈中，这常常被称为栈帧（Stack Frame）或活动记录（Activate Record）。活动记录一般包括以下几个方面的内容：</p>
<p>1) 函数的返回地址，也就是函数执行完成后从哪里开始继续执行后面的代码。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">c = a + b;</span><br></pre></td></tr></table></figure>

<p>站在C语言的角度看，func() 函数执行完成后，会继续执行<code>c=a+b;</code>语句，那么返回地址就是该语句在内存中的位置。</p>
<blockquote>
<p>注意：C语言代码最终会被编译为机器指令，确切地说，返回地址应该是下一条指令的地址，这里之所以说是下一条C语言语句的地址，仅仅是为了更加直观地说明问题。</p>
</blockquote>
<p>2) 参数和局部变量。有些编译器，或者编译器在开启优化选项的情况下，会通过寄存器来传递参数，而不是将参数压入栈中，我们暂时不考虑这种情况。</p>
<p>3) 编译器自动生成的临时数据。例如，当函数返回值的长度较大（比如占用40个字节）时，会先将返回值压入栈中，然后再交给函数调用者。</p>
<blockquote>
<p>当返回值的长度较小（char、int、long 等）时，不会被压入栈中，而是先将返回值放入寄存器，再传递给函数调用者。</p>
</blockquote>
<p>4) 一些需要保存的寄存器，例如 ebp、ebx、esi、edi 等。之所以要保存寄存器的值，是为了在函数退出时能够恢复到函数调用之前的场景，继续执行上层函数。</p>
<p>下图是一个函数调用的实例：</p>
<p><img src="image-20200330162839836.png" alt="image-20200330162839836"></p>
<p>上图是在Windows下使用VS2010 Debug模式编译时一个函数所使用的栈内存，可以发现，理论上 ebp 寄存器应该指向栈底，但在实际应用中，它却指向了old ebp。</p>
<blockquote>
<p>在寄存器名字前面添加“old”，表示函数调用之前该寄存器的值。</p>
</blockquote>
<p>当发生函数调用时：</p>
<ul>
<li>实参、返回地址、ebp 寄存器首先入栈；</li>
<li>然后再分配一块内存供局部变量、返回值等使用，这块内存一般比较大，足以容纳所有数据，并且会有冗余；</li>
<li>最后将其他寄存器的值压入栈中。</li>
</ul>
<p>需要注意的是，不同编译器在不同编译模式下所产生的函数栈并不完全相同，例如在VS2010下选择Release模式，编译器会进行大量优化，函数栈的样貌荡然无存，不具有教学意义，所以本教程以VS2010 Debug模式为例进行分析。</p>
<h2 id="关于数据的定位"><a href="#关于数据的定位" class="headerlink" title="关于数据的定位"></a>关于数据的定位</h2><p>由于 esp 的值会随着数据的入栈而不断变化，要想根据 esp 找到参数、局部变量等数据是比较困难的，所以在实现上是根据 ebp 来定位栈内数据的。ebp 的值是固定的，数据相对 ebp 的偏移也是固定的，ebp 的值加上偏移量就是数据的地址。</p>
<p>例如一个函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">28.5</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="number">15</span>, <span class="number">92</span>);</span><br></pre></td></tr></table></figure>

<p>那么函数的活动记录如下图所示：</p>
<p><img src="image-20200330162918960.png" alt="image-20200330162918960"></p>
<p>这里我们假设两个局部变量挨着，并且第一个变量和 old ebp 也挨着（实际上它们之间有4个字节的空白），如此，第一个参数的地址是 ebp+12，第二个参数的地址是 ebp+8，第一个局部变量的地址是 ebp-4，第二个局部变量的地址是 ebp-8。</p>
<h1 id="c语言入门-函数调用惯例（Calling-Convention）"><a href="#c语言入门-函数调用惯例（Calling-Convention）" class="headerlink" title="c语言入门-函数调用惯例（Calling Convention）"></a>c语言入门-函数调用惯例（Calling Convention）</h1><p>我们知道，一个C程序由若干个函数组成，C程序的执行实际上就是函数之间的相互调用。请看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"funcA被调用\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span>&#123;</span><br><span class="line">    funcA(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"funcB被调用\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    funcB(<span class="number">19.9</span>, <span class="number">28.5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main被调用\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main() 调用了 funcB()，funcB() 又调用了 funcA()。对于main() 调用 funcB()，我们称 main() 是调用方，funcB() 是被调用方；同理，对于 funcB() 调用 funcA()，funcB() 是调用方，funcA() 是被调用方。</p>
<p>函数的参数（实参）由调用方压入栈中供被调用方使用，它们之间要有一致的约定。例如，参数是从左到右入栈还是从右到左入栈，如果双方理解不一致，被调用方使用参数时就会出错。</p>
<p>以 funcB() 为例，假设 main() 函数先将 19.9 入栈，后将 28.5 入栈，但是 funcB() 在使用这些实参时却认为 28.5 先入栈，19.9 后入栈，那么就一定会产生混乱，误以为19.9 是传递给 b、28.5 是传递给 a 的。</p>
<p>所以，函数调用方和被调用方必须遵守同样的约定，理解要一致，这称为调用惯例（Calling Convention）。</p>
<p>一个调用惯例一般规定以下两方面的内容：</p>
<p>1) 函数参数的传递方式，是通过栈传递还是通过寄存器传递（这里我们只讲解通过栈传递的情况）。</p>
<p>2) 函数参数的传递顺序，是从左到右入栈还是从右到左入栈。</p>
<p>3) 参数弹出方式。函数调用结束后需要将压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由调用方来完成，也可以由被调用方来完成。</p>
<p>4) 函数名修饰方式。函数名在编译时会被修改，调用惯例可以决定如何修改函数名。</p>
<p>在C语言中，存在多种调用惯例，可以在函数声明或函数定义时指定，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> __cdecl <span class="title">max</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a = <span class="built_in">max</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">max</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = m&gt;n ? m : n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用惯例在函数声明和函数定义时都可以指定，语法格式为：</p>
<p>返回值类型  调用惯例  函数名(函数参数)</p>
<p>在函数声明处是为调用方指定调用惯例，而在函数定义处是为被调用方（也就是函数本身）指定调用惯例。</p>
<p><code>__cdecl</code>是C语言默认的调用惯例，在平时编程中，我们其实很少去指定调用惯例，这个时候就使用默认的 __cdecl。</p>
<blockquote>
<p>注意：<strong>cdecl 并不是标准关键字，上面的写法在 VC/VS 下有效，但是在 GCC 下，要使用 __attribute</strong>((cdecl))。</p>
</blockquote>
<p>除了 cdecl，还有其他调用惯例，请看下表：</p>
<table>
<thead>
<tr>
<th>调用惯例</th>
<th>参数传递方式</th>
<th>参数出栈方式</th>
<th>名字修饰</th>
</tr>
</thead>
<tbody><tr>
<td>cdecl</td>
<td>按照从右到左的顺序入栈</td>
<td>调用方</td>
<td>下划线+函数名， 如函数 max() 的修饰名为 _max</td>
</tr>
<tr>
<td>stdcall</td>
<td>按照从右到左的顺序入栈</td>
<td>函数本身 （被调用方）</td>
<td>下划线+函数名+@+参数的字节数， 如函数 int max(int m, int n) 的修饰名为 <em>max</em>@8</td>
</tr>
<tr>
<td>fastcall</td>
<td>将部分参数放入寄存器， 剩下的参数按照从右到左的顺序入栈</td>
<td>函数本身 （被调用方）</td>
<td>@+函数名+@+参数的字节数</td>
</tr>
<tr>
<td>pascal</td>
<td>按照从左到右的顺序入栈</td>
<td>函数本身 （被调用方）</td>
<td>较为复杂，这里不再展开讨论</td>
</tr>
</tbody></table>
<h2 id="stdafx"><a href="#stdafx" class="headerlink" title="stdafx"></a>stdafx</h2><p>stdafx的英文全称为：Standard Application Framework Extensions（标准应用程序框架的扩展）。</p>
<p>所谓头文件<a href="https://baike.baidu.com/item/预编译" target="_blank" rel="noopener">预编译</a>，就是把一个工程(Project)中使用的一些MFC标准头文件(如Windows.H、Afxwin.H)预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间。</p>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>内联inline是给编译器的优化提示，如果一个函数被编译成inline的话，那么就会把函数里面的代码直接插入到调用这个函数的地方，而不是用调用函数的形式。如果函数体代码很短的话，这样会比较有效率，因为调用函数的过程也是需要消耗资源的。但是你inline只是给编译器的提示，编译器会根据实际情况自己决定到底要不要进行内联，如果函数过大、有函数指针指向这个函数或者有递归的情况下编译器都不会进行内联。</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>/*</p>
<p>一维数组指针的使用</p>
<p>uint8 picture[];</p>
<p>picture即为picture[]的首地址  picture+1为picture[1]的地址</p>
<p><em>picture+1等价于picture[1]    以此类推//指针运算优先级最高，即这个地方有错误</em>picture+1等价于picture[0]+1</p>
<p><img src="https://i.loli.net/2020/03/30/b2vMCUZNYPJSka6.png" alt="1576647715204"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">char</span> a[<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> b[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"十六进制地址%p"</span>, a);</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"十六进制地址%p"</span>, b);</span><br><span class="line"></span><br><span class="line">​     <span class="built_in">printf</span>(<span class="string">"十六进制地址%p"</span>, &amp;a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">​     <span class="built_in">printf</span>(<span class="string">" 十六进制地址%p"</span>, &amp;b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//printf("Hello World!\n");</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="https://i.loli.net/2020/03/30/stIHdUEQcAO1aCP.png" alt="1576647767776"></p>
<p>关于二维数组指针的使用</p>
<p>uint8 picture[][16];</p>
<p>picture即为picture[][]的首地址  picture[0][0]的地址     picture+1为picture[0][1]的地址 以此类推</p>
<p>*picture为picture[0]的首地址      picture[0][0]的地址     *picture+1为picture[1][0]的地址 以此类推</p>
<p>现在结合一下：</p>
<p>*picture看成 *(picture+0)+0       *(picture+y)+x  就是picture[y][x]的地址   </p>
<p>如果我们此时再加一个’<em>‘   会产生以下效果</em>(*(picture+y)+x)等价于picture[y][x]</p>
<p> int a[][3]={4,4,4,4,4,4,4,4};</p>
<p>​    int b[3]={0};</p>
<p>​         printf(“十六进制地址%p\n”, a);</p>
<p>​         printf(“十六进制地址%p\n”, a+1);</p>
<p><img src="https://i.loli.net/2020/03/30/ogwZvPOcJ8i35Fd.png" alt="1576647805308"></p>
<h2 id="C-C-混合编程"><a href="#C-C-混合编程" class="headerlink" title="C/C++混合编程"></a>C/C++混合编程</h2><p>本篇文章是对C/C++混合编程进行了详细的分析介绍，需要的朋友参考下。</p>
<p>​        在工作中，C、C++密不可分，做我们嵌入式方面的，当然更多的是C，但，有时候却少不了C++，而且是C、C++混搭（混合编程）在一起的，比如，RTP视频传输，live555多媒体播放等都是C++下的，他需要调用JRTPLIB库，再比如，我那邮件发送，我也用C++写的，定义了一个Email对象，包含了成员：收发邮件地址，用户名，密码等，以及方法：邮件头、Base64编码和邮件发送这些操作，很好用，所以，很多时候，C++还是蛮不错的。。。。但，<em>.c与</em>.cpp文件混搭在一起，不是那么的简单，知识总是：用时方恨少啊！！！现在，我们就来慢慢的了解吧。</p>
<p><strong>一、extern“C”的作用（最重点）</strong></p>
<p>​    <strong>1. extern “C”的真实目的是实现类C和C++的混合编程</strong>。<strong>extern “C”是由Ｃ＋＋提供的一个连接交换指定符号，用于告诉Ｃ＋＋这段代码是Ｃ函数</strong>。<strong>extern “C”后面的函数不使用的C++的名字修饰,而是用C。</strong>这是因为C++编译后库中函数名会变得很长，与C生成的不一致，造成Ｃ＋＋不能直接调用C函数。</p>
<p>​    <strong>2.</strong>C++语言支持函数重载，C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为：<strong>void foo(int x, int y);</strong>该函数被<strong>C编译器编译</strong>后在库中的名字为<strong>_foo</strong>，而<strong>C++编译器</strong>则会产生像<strong>_foo_int_int之类</strong>的名字。<strong>C++提供了C连接交换指定符号extern“C”来解决名字匹配问题。</strong></p>
<p>​    <strong>3.</strong>被extern “C”限定的函数或变量是<strong>extern类型</strong>的；extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。被extern “C”修饰的变量和函数是按照C语言方式编译和连接的。   </p>
<p>​     <strong>4.与extern对应的关键字是static</strong>，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。</p>
<p><strong>二、extern“C”与__cplusplus</strong></p>
<p><strong>#ifdef __cplusplus        extern “C” {        #endif        #ifdef __cplusplus        }        #endif</strong></p>
<p>​    <strong>Cplusplus（C plus plus）</strong>即”C++”，<strong>用于C++文档的头文件中</strong>，上面代码的意思是：如果是C++文件（<em>.cpp）后缀，则使用extern “C”，在C++项目中应用的非常广泛。即使用gcc编译器编译，函数名为C类型如*</em>_foo<strong>。个人认为，搞懂了这两个关键字，尤其是理解extern “C”（再次强调，不为过，呵呵），接下来的</strong>混合编程**也就差不多了，哈哈哈。。。。</p>
<h1 id="declspec"><a href="#declspec" class="headerlink" title="__declspec"></a>__declspec</h1><p>CV_EXPORTS_W 实际上就是 __declspec（dllexport），查阅Google可以发现，其作用如下：</p>
<p>使用<strong>declspec（dllexport）关键字从DLL导出数据、函数、类或类成员函数时，它会将导出指令添加到对象文件中，因此在指定的对象文件里不需要使用.def文件。若要导出类中的所有公共数据成员和成员函数，关键字必须出现在类名的左边。由于对名称修饰没有标准规范，因此导出函数的名称在不同的编译器版本中可能有所变化。如果使用 （CV_EXPORTS）</strong>declspec（dllexport），仅当解决任何命名约定更改时才必须重新编译 DLL 和依赖 .exe 文件。（防止编译出错）</p>
<p>补充：动态链接库中定义有两种函数：导出函数（export function）和内部函数（internal function）。</p>
<p>导出函数可以被其它模块调用，内部函数在定义它们的DLL程序内部使用。</p>
<p>MFC提供的修饰符号_declspec（dllexport） 就是表示导出函数或变量。</p>
<p>模块定义文件（.DEF）是一个或多个用于描述DLL属性的模块语句组成的文本文件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acewzj.github.io/2019/06/08/2019-06-08-OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="acewzj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acewzj">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/08/2019-06-08-OS/" itemprop="url">计算机操作系统-Boot</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-08T10:06:18+08:00">
                2019-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS-Boot/" itemprop="url" rel="index">
                    <span itemprop="name">OS_Boot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>

<p>本文主要讲述关于计算机开机启动的一些思考</p>
<h2 id="关于Boot"><a href="#关于Boot" class="headerlink" title="关于Boot"></a>关于Boot</h2><p>Boot的中文意思是引导；开机；靴子</p>
<ul>
<li>计算机启动怎么非得用Boot这个单词呢？用START不更直观吗？<br>其实这里Boot是Bootstrap(鞋带)的缩写，有一句谚语叫<code>pull oneself up by one&#39;s bootstraps</code> <code>拽着鞋带将某人提起来</code>这怎么可能呢？<blockquote>
<p>最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做”拉鞋带”，久而久之就简称为boot了。<br>按照我的理解：Boot的作用有点类似汽车的马达(起动机)，通过它的电动机将庞大的内燃机启动起来。</p>
</blockquote>
</li>
</ul>
<h2 id="关于BIOS"><a href="#关于BIOS" class="headerlink" title="关于BIOS"></a>关于BIOS</h2><p>BIOS是基本输入输出系统(Basic Input/Output System)的英文单词缩写。</p>
<ul>
<li>计算机为什么需要BIOS呢？这么小这么老的一个芯片为什么还不淘汰掉它呢？<blockquote>
<p>在PC引导的过程中，BIOS担负着检测、初始化硬件的功能，以及引导操作系统的责任。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>它其实是一段固件（firmware～一类特殊的底层软件）程序，主要是用于PC个人电脑启动过程中的硬件参数初始化以及给OS操作系统和应用程序运行时提供特殊的中断服务。在PC发展历史中早期是存储在主板的EPROM芯片中，所以是无法被轻易修改的。但是上世纪90年代在PC上电启动自检过程又希望有些顺序可以调整或者有些错误希望被忽略，因此增加了BIOS的配置或设置功能，一开始这种配置是通过DIP拨码开关（这个就不展开了）实现，接着是采用随机软盘带的配置程序对钮扣电池供电的RAM芯片进行参数配置，而ROM芯片中的BIOS代码会从DIP开关或RAM中读取不同参数而采用不同的启动自检流程。这里的RAM正是其他答主所说的“CMOS”，当年我也听过“卸下电池再装上，可以清除CMOS设置的启动密码”这样的说法。<br>来源：<a href="https://www.zhihu.com/question/28362111/answer/93870636" target="_blank" rel="noopener">知乎老关</a></p>
</blockquote>
<h3 id="硬件自检POST"><a href="#硬件自检POST" class="headerlink" title="硬件自检POST"></a>硬件自检POST</h3><p>联想到自己做飞思卡尔的时候，上场比赛是不允许你烧录程序的，但是有一些像速度设置等就需要临场发挥，所以电路板上会带着DIP的拨码开关，通过上电读取开关0与1的信息来进行保命挡，GG挡，冲刺挡的选择，但是这种DIP拨码开关的选择万一选错了就真的GG了，相信那些硬件厂商可不希望用户瞎按一通，所以才采用随机软盘带的配置程序对钮扣电池供电的RAM芯片进行参数配置。<br>ROM里面的程序如果让我去写的话我可能会按照写STM32单片机的思维去进行操作：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">main</span>()&#123;</span><br><span class="line">  <span class="selector-tag">NVIC_Configuration</span>(); <span class="comment">//中断配置初始化</span></span><br><span class="line">  <span class="selector-tag">KeyBoard_Init</span>();      <span class="comment">//键盘初始化</span></span><br><span class="line">  <span class="selector-tag">Lcd_Init</span>();           <span class="comment">//显示器初始化</span></span><br><span class="line">  <span class="selector-tag">try</span>:</span><br><span class="line">      <span class="selector-tag">CPU_Init</span>(Param1,Param2)<span class="comment">//CPU初始化，这块的参数就需要向CMOS RAM进行读取了，也就是说这块是可以用户自定义设置的，比如超频与否等等与CPU相关的设置 </span></span><br><span class="line">  <span class="selector-tag">catch</span> <span class="selector-tag">Exception</span> <span class="selector-tag">e</span>:</span><br><span class="line">    <span class="selector-tag">Beep_ON</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="selector-tag">print</span> <span class="selector-tag">e</span></span><br><span class="line">  <span class="comment">//如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然真正的POST不会像我这样简单的了：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>引导系统重置REST引导CPU。</span><br><span class="line"><span class="number">2.</span>CPU指向BIOS自我测试的地址FFFFOH并打开CPU运行第一个指令。</span><br><span class="line"><span class="number">3.</span>CPU内部寄存器的测试。</span><br><span class="line"><span class="number">4.</span>CMOS <span class="number">146818</span> SRAM检查。</span><br><span class="line"><span class="number">5.</span>ROM BIOS检查码测试。</span><br><span class="line"><span class="number">6.8254</span>计时/计数器测试。</span><br><span class="line"><span class="number">7.8237</span> DMA控制器测试。</span><br><span class="line"><span class="number">8.74612</span>页寄存器测试。</span><br><span class="line"><span class="number">9.</span>REFRESH刷新电路测试。</span><br><span class="line"><span class="number">10.8042</span>键盘控制器测试。</span><br><span class="line"><span class="number">11.</span>DRAM <span class="number">64</span>KB基本存储器测试。</span><br><span class="line"><span class="number">12.</span>CPU保护模式的测试。</span><br><span class="line"><span class="number">13.8259</span>中断控制器的测试。</span><br><span class="line"><span class="number">14.</span>CMOS <span class="number">146818</span>电力及检查码检查。</span><br><span class="line"><span class="number">15.</span>DRAM <span class="number">1</span>MB以上存储器检查。</span><br><span class="line"><span class="number">16.</span>显卡测试。</span><br><span class="line"><span class="number">17.</span>NMI强制中断测试。</span><br><span class="line"><span class="number">18.8254</span>计时/计数器声音电路测试。</span><br><span class="line"><span class="number">19.8254</span>计时/计数器计时测试。</span><br><span class="line"><span class="number">20.</span>CPU保护模式SHUT DOWN测试。</span><br><span class="line"><span class="number">21.</span>CPU回至实模式（REAL MODE）。</span><br><span class="line"><span class="number">22.</span>键盘鼠标测试。</span><br><span class="line"><span class="number">23.8042</span>键盘控制器测试。</span><br><span class="line"><span class="number">24.8259</span>中断控制器IRQ0至IRQ18建立。</span><br><span class="line"><span class="number">25.</span>磁盘驱动器及界面测试。</span><br><span class="line"><span class="number">26.</span>设置并行打印机及串列RS232的界面。</span><br><span class="line"><span class="number">27.</span>检查CMOS IC时间、日期。</span><br><span class="line"><span class="number">28.</span>检查完成</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.在<span class="meta">CPU</span>加电之后，会把<span class="meta">CPU</span>所有寄存器的值设为默认值，除了<span class="built_in">CS</span>寄存器的值改为<span class="number">0xFFFF</span>，其他寄存器的值都为<span class="number">0</span>，这样，根据<span class="built_in">CS</span> 和 <span class="built_in">IP</span>的值（段地址*<span class="number">16</span>+偏移地址）就可以找到指令的物理地址<span class="number">0xFFFF</span>:<span class="number">0x0000</span>，也就是<span class="number">0xFFFF0</span>。</span><br><span class="line"><span class="number">2</span>. 这时<span class="meta">CPU</span>就开始执行在这个位置开始执行，这里存放的一条无条件跳转指令<span class="keyword">JMP</span>，跳转到BIOS的真正启动代码处。</span><br><span class="line"><span class="number">3.</span>BIOS首先先进行POST（Power－On Self <span class="keyword">Test</span>，加电后自检）</span><br><span class="line"><span class="number">4</span>. BIOS 程序在执 行一些必要的开机自检和初始化后，会将自己复制到从 <span class="number">0xA0000</span> 开始的物理内存中并继续执行</span><br><span class="line"><span class="number">5</span>. 然后，BIOS 开始搜寻可引导的存储设备(即根据用户指定的引导顺序从软盘、硬盘或是可移动设备)。如果找到，则将存储设备中的引导扇区读入物理内存 <span class="number">0x7C00</span> 处，并跳转到 <span class="number">0x7C00</span> 继续执行，从而将 <span class="meta">CPU</span> 交给引导扇区中的 Boot 程序。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0x7C00这个地址来自Intel的第一代个人电脑芯片8088，以后的CPU为了保持兼容，一直使用这个地址。<br>当时，搭配的操作系统是86-DOS。这个操作系统需要的内存最少是32KB。我们知道，内存地址从0x0000开始编号，32KB的内存就是0x0000～0x7FFF。<br>8088芯片本身需要占用0x0000～0x03FF，用来保存各种中断处理程序的储存位置。（主引导记录本身就是中断信号INT 19h的处理程序。）所以，内存只剩下0x0400～0x7FFF可以使用。<br>为了把尽量多的连续内存留给操作系统，主引导记录就被放到了内存地址的尾部。(操作系统启动后，主引导记录就没有用处了，此后它所在的内存地址可以被操作系统重新利用)由于一个扇区是512字节，主引导记录本身也会产生数据，需要另外留出512字节保存。所以，它的预留位置就变成了：<br><code>0x7FFF - 512 - 512 + 1 = 0x7C00</code></p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--------------------- 0x0</span><br><span class="line">| Interrupts vectors</span><br><span class="line">+--------------------- 0x400</span><br><span class="line">| BIOS data area</span><br><span class="line">+--------------------- 0x5??</span><br><span class="line">| OS load area</span><br><span class="line">+--------------------- 0x7C00</span><br><span class="line">| Boot sector</span><br><span class="line">+--------------------- 0x7E00</span><br><span class="line">| Boot data/stack</span><br><span class="line">+--------------------- 0x7FFF</span><br><span class="line">| (<span class="keyword">not</span> used)</span><br><span class="line">+--------------------- (<span class="built_in">..</span>.)</span><br></pre></td></tr></table></figure>

<h3 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h3><p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。<br>我们重装系统最常用的是用U盘制作一个启动盘，然后开机进入BIOS界面选择该从U盘、磁盘、固态硬盘、CD中以什么<strong>启动顺序</strong>来进行下一步的操作。注意这块对启动顺序的存储是保存在CMOS中的。</p>
<h3 id="主引导记录MBR"><a href="#主引导记录MBR" class="headerlink" title="主引导记录MBR"></a>主引导记录MBR</h3><p>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。</p>
<p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</p>
<p>这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）。<br><img src="https://s2.ax1x.com/2019/06/08/VDgm79.png" alt="512字节MBR分布"></p>
<ul>
<li>446Bytes:主引导记录最开头是第一阶段引导代码。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（如GNU GRUB）。它不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现多系统引导。</li>
<li>64Bytes:硬盘分区表占据主引导扇区的64个字节（偏移01BEH–偏移01FDH），可以对四个分区的信息进行描述，其中每个分区的信息占据16个字节。包括如下几个部分：<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>） 第<span class="number">1</span>个字节：分区状态：<span class="number">0x00</span>--&gt;非活动分区；<span class="number">0x80</span>--&gt;激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</span><br><span class="line">（<span class="number">2</span>） 第<span class="number">2</span>个字节：分区起始的磁头号（Head），用到全部<span class="number">8</span>位（也就是说有<span class="number">256</span>个磁头？）</span><br><span class="line">（<span class="number">3</span>） 第<span class="number">3</span>~<span class="number">4</span>个字节：该分区起始扇区号（Sector），占据第<span class="number">3</span>字节的<span class="number">0</span>~<span class="number">5</span>位（也就是说单个磁道有<span class="number">64</span>个扇区，每个扇区的弧度为<span class="number">360</span>/<span class="number">64</span>=<span class="number">5.625</span>°  由此想到，一个磁道上的一个扇区的存储量是固定的（比如<span class="number">512</span>字节），所以半径小的磁道上的介质密度要高一些，半径大的磁道上介质密度要小一些）</span><br><span class="line">该分区起始磁柱号（Cylinder）占据第<span class="number">3</span>字节的<span class="number">6</span>~<span class="number">7</span>位和第四字节的全部<span class="number">8</span>位（也就是说有<span class="number">1024</span>个磁道）</span><br><span class="line">（<span class="number">4</span>）第<span class="number">5</span>字节：文件系统标志位</span><br><span class="line">（<span class="number">5</span>）第<span class="number">6</span>字节：分区结束的磁头号（Head），用到全部<span class="number">8</span>位</span><br><span class="line">（<span class="number">6</span>）第<span class="number">7</span>~<span class="number">8</span>字节：该分区结束扇区号（Sector），占据第<span class="number">3</span>字节的<span class="number">0</span>~<span class="number">5</span>位</span><br><span class="line">该分区结束磁柱号（Cylinder）占据第<span class="number">3</span>字节的<span class="number">6</span>~<span class="number">7</span>位和第四字节的全部<span class="number">8</span>位</span><br><span class="line">（<span class="number">7</span>）第<span class="number">9</span>~<span class="number">12</span>字节：分区起始相对扇区号</span><br><span class="line">（<span class="number">8</span>）第<span class="number">12</span>~<span class="number">15</span>字节：分区总的扇区号</span><br><span class="line">最后的四个字节（<span class="string">"主分区的扇区总数"</span>），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过<span class="number">2</span>的<span class="number">32</span>次方。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="硬盘启动"><a href="#硬盘启动" class="headerlink" title="硬盘启动"></a>硬盘启动</h3><p>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成两种情况。</p>
<h4 id="1-卷引导"><a href="#1-卷引导" class="headerlink" title="1.卷引导"></a>1.卷引导</h4><p>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做”卷引导记录”（Volume boot record，缩写为VBR）。</p>
<p>“卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p>
<h4 id="2-启动管理器"><a href="#2-启动管理器" class="headerlink" title="2.启动管理器"></a>2.启动管理器</h4><p>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。</p>
<p>Linux环境中，目前最流行的启动管理器是Grub。</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p>
<p>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p>
<p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。</p>
<p>至此，全部启动过程完成。</p>
<h2 id="关于GPT"><a href="#关于GPT" class="headerlink" title="关于GPT"></a>关于GPT</h2><p>全局唯一标识分区表（GUID Partition Table，缩写：GPT）</p>
<blockquote>
<p>为了兼容不支持GPT磁盘的操作系统，GPT分区格式保留了磁盘第一个扇区MBR的使用，并且也填写MBR的第一个分区表项，这个扇区又被称为保护MBR，而实际上EFI根本不使用这个分区表。在第一个分区表项中，分区开始扇区为1，分区大小扇区数为FFFFFFFF，分区类型为0xEE，它的目的是使计算机认为这个磁盘是合法的，并且已经被划分了分区，从而使系统不再试图重新初始化或格式化磁盘。<br>真正的GPT区域从硬盘的第二个扇区即1号扇区开始，主要包括GPT头、分区表、GPT分区、分区表备份、GPT头备份这几个部分。<br><a href="https://blog.51cto.com/jslmes/1323925" target="_blank" rel="noopener">原文链接</a></p>
</blockquote>
<blockquote>
<p>对于计算机来说，掉电储存类似于我们经常说的记忆，一个人如果睡了一觉醒来什么也记不得的话想想该多么恐怖。计算机的记忆就是0和1的掉电保持，这是在我看来也很矛盾的一件事：本来计算机就靠有没有电或者高低电压来区分0和1，你这一掉电，啥也没有了，我怎么去储存0和1呢？<br>一种解决方法是可以利用磁性来储存0与1，掉电之后电虽然没有了，但是磁性还是存在的，典型的就是磁盘磁带。<br>另外一种解决方法是防止电子在掉电之后逃掉，典型的是Flash，其实这个具体的实现我也没有看懂，光是想想不让电子跑掉我就感觉很难了。摘自wikipedia<code>进入的电子会被困在里面。在一般的条件下电荷经过多年都不会逸散。</code></p>
</blockquote>
<h2 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h2><p>要详细了解UEFI，还得从BIOS讲起。我们都知道，每一台普通的电脑都会有一个BIOS，用于加载电脑最基本的程式码，担负着初始化硬件，检测硬件功能以及引导操作系统的任务。UEFI就是与BIOS相对的概念，这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而达到开机程序化繁为简节省时间的目的。传统BIOS技术正在逐步被UEFI取而代之，在最近新出厂的电脑中，很多已经使用UEFI，使用UEFI模式安装操作系统是趋势所在。 UEFI抛去了传统BIOS需要长时间自检的问题，让硬件初始化以及引导系统变得简洁快速。换种方式说，UEFI已经把电脑的BIOS变得不像是BIOS，而是一个小型固化在主板上的操作系统一样，加上UEFI本身的开发语言已经从汇编转变成C语言，高级语言的加入让厂商深度开发UEFI变为可能。</p>
<p>MBR的局限性<br> MBR的意思是“主引导记录”，最早在1983年在IBM PC DOS 2.0中提出。</p>
<p>之所以叫“主引导记录”，是因为它是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。所谓启动加载器，是一小段代码，用于加载驱动器上其他分区上更大的加载器。如果你安装了Windows，Windows启动加载器的初始信息就放在这个区域里——如果MBR的信息被覆盖导致Windows不能启动，你就需要使用Windows的MBR修复功能来使其恢复正常。如果你安装了Linux，则位于MBR里的通常会是GRUB加载器。</p>
<p>bootloader</p>
<p>在嵌入式操作系统中，BootLoader是在<a href="https://baike.baidu.com/item/操作系统" target="_blank" rel="noopener">操作系统</a>内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用<a href="https://baike.baidu.com/item/操作系统内核" target="_blank" rel="noopener">操作系统内核</a>准备好正确的环境。在<a href="https://baike.baidu.com/item/嵌入式系统" target="_blank" rel="noopener">嵌入式系统</a>中，通常并没有像BIOS那样的<a href="https://baike.baidu.com/item/固件" target="_blank" rel="noopener">固件</a>程序（注，有的嵌入式CPU也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由BootLoader来完成。在一个基于ARM7TDMI core的<a href="https://baike.baidu.com/item/嵌入式系统" target="_blank" rel="noopener">嵌入式系统</a>中，系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的BootLoader程序。</p>
<p>使板子从裸机变成带<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="noopener">操作系统</a>，最少需要三个文件：bootloader、kernel、rootfs；（启动引导程序、内核、文件系统）；<br>由bootloader引导cpu从哪里开始执行kernel程序，在启动起来内核后，系统中还要有对应的根文件系统。<br>对于bootloader来说，它可以分为两部分来说，一个是硬件初始化，一个是加载操作系统。<br>下边是nor flash的启动过程：<br>nor flash一般放在总线的0x00地址。<br>首先bootloader这段代码存放在nor flash的0x00这个地址中，所以在cpu启动时，cpu直接执行这段代码，由于nor flash支持片上执行，<br>所以cpu可以直接在nor flash上执行完三个步骤，但是由于nor flash的读取速度相对来说比较慢，所以，有时候会把bootl、kernel和rootfs拷贝到sdram中<br>，在sdram中执行启动过程。<br>Nand flash的启动过程：—（下边说道的BL1和BL2指定的是bootloader代码的两部分，分别硬件初始化程序和加载操作系统程序）<br>cpu在启动过程中最初会执行irom中的一段代码，这段代码会指引cpu到nand flash中，把nand flash中的BL1拷贝到iram中，</p>
<p>执行这段代码，在执行完这部分代码的末尾会告诉cpu把原来在nand flash中的bootloader、kernel、rootfs程序都拷贝到sdram中，然后从BL2代码的开始处执行程序，最终执行完所有的启动程序。</p>
<h2 id="Linux开机启动过程分析"><a href="#Linux开机启动过程分析" class="headerlink" title="Linux开机启动过程分析"></a>Linux开机启动过程分析</h2><p>开机过程指的是从打开计算机电源直到LINUX显示用户登录画面的全过程。分析LINUX开机过程也是深入了解LINUX核心工作原理的一个很好的途径。</p>
<p><strong>启动第一步－－加载BIOS</strong></p>
<p>当 你打开计算机电源，计算机会首先加载BIOS信息，BIOS信息是如此的重要，以至于计算机必须在最开始就找到它。这是因为BIOS中包含了CPU的相关 信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特性等等。在此之后，计算机心里就有谱了，知道应该去读取哪个硬件设备了。在BIOS将系 统的控制权交给硬盘第一个扇区之后，就开始由Linux来控制系统了。</p>
<p><strong>启动第二步－－读取MBR</strong></p>
<p>硬 盘上第0磁道第一个扇区被称为MBR，也就是Master Boot Record，即主引导记录，它的大小是512字节，可里面却存放了预启动信息、分区表信息。可分为两部分：第一部分为引导（PRE-BOOT）区，占了 446个字节；第二部分为分区表（PARTITION PABLE），共有66个字节，记录硬盘的分区信息。预引导区的作用之一是找到标记为活动（ACTIVE）的分区，并将活动分区的引导区读入内存。</p>
<p>系统找到BIOS所指定的硬盘的MBR后，就会将其复制到0×7c00地址所在的物理内存中。其实被复制到物理内存的内容就是Boot Loader，而具体到你的电脑，那就是lilo或者grub了。</p>
<p><strong>启动第三步－－Boot Loader</strong></p>
<p>Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状 态，以便为最终调用操作系统内核做好一切准备。通常，BootL oade:是严重地依赖于硬件而实现的，不同体系结构的系统存在着不同的Boot Loader。</p>
<p>Linux的引导扇区内容是采用汇编语言编写的程序，其源代码在arch/i386/boot中(不同体系的CPU有其各自的boot目录)，有4个程序文件:</p>
<p>◎bootsect.S，引导扇区的主程序，汇编后的代码不超过512字节，即一个扇区的 大 小<br> ◎setup.S， 引导辅助程序<br> ◎edd.S,辅助程序的一部分，用于支持BIOS增强磁盘设备服务<br> ◎video.S,辅助程序的另一部分，用于引导时的屏幕显示</p>
<p>Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader，这里以Grub为例来讲解吧。</p>
<p>系统读取内存中的grub配置信息（一般为menu.lst或grub.lst），并依照此配置信息来启动不同的操作系统。</p>
<p><strong>启动第四步－－加载内核</strong></p>
<p>根据grub设定的内核映像所在路径，系统读取内存映像，并进行解压缩操作。此时，屏幕一般会输出“Uncompressing Linux”的提示。当解压缩内核完成后，屏幕输出“OK, booting the kernel”。</p>
<p>系统将解压后的内核放置在内存之中，并调用start_kernel()函数来启动一系列的初始化函数并初始化各种设备，完成Linux核心环境的建立。至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。</p>
<p>start_kenrel() 定义在init/main.c中，它就类似于一般可执行程序中的main()函数，系统在此之前所做的仅仅是一些能让内核程序最低限度执行的初始化操作， 真正的内核初始化过程是从这里才开始。函数start_kerenl()将会调用一系列的初始化函数，用来完成内核本身的各方面设置，目的是最终建立起基 本完整的Linux核心环境。</p>
<p>start_kernel()中主要执行了以下操作:<br> (1) 在屏幕上打印出当前的内核版本信息。<br> (2) 执行setup_arch()，对系统结构进行设置。</p>
<p>(3) 执行sched_init()，对系统的调度机制进行初始化。先是对每个可用CPU上的runqueque进行初始化;然后初始化0号进程(其task struct和系统空M堆栈在startup_32()中己经被分配)为系统idle进程，即系统空闲时占据CPU的进程。<br> (4)执行parse_early_param()和parsees_args()解析系统启动参数。<br> (5)执行trap_in itQ，先设置了系统中断向量表。0－19号的陷阱门用于CPU异常处理;然后初始化系统调用向量;最后调用cpu_init()完善对CPU的初始化，用于支持进程调度机制，包括设定标志位寄存器、任务寄存器、初始化程序调试相关寄存器等等。<br> (6)执行rcu_init()，初始化系统中的Read-Copy Update互斥机制。<br> (7)执行init_IRQ()函数，初始化用于外设的中断，完成对IDT的最终初始化过程。<br> (8)执行init_timers(), softirq_init()和time_init()函数，分别初始系统的定时器机制，软中断机制以及系统日期和时间。<br> (9)执行mem_init()函数，初始化物理内存页面的page数据结构描述符，完成对物理内存管理机制的创建。<br> (10)执行kmem_cache_init(),完成对通用slab缓冲区管理机制的初始化工作。</p>
<p>(11)执行fork_init()，计算出当前系统的物理内存容量能够允许创建的进程(线程)数量。</p>
<p>(12)执行proc_caches_init() , bufer_init(), unnamed_dev_init() ,vfs_caches_init(), signals_init()等函数对各种管理机制建立起专用的slab缓冲区队列。<br> (13 )执行proc_root_init()Wl数，对虚拟文件系统/proc进行初始化。</p>
<p>在 start_kenrel()的结尾，内核通过kenrel_thread()创建出第一个系统内核线程(即1号进程)，该线程执行的是内核中的 init()函数，负责的是下一阶段的启动任务。最后调用cpues_idle()函数:进入了系统主循环体口默认将一直执行 default_idle()函数中的指令，即CPU的halt指令，直到就绪队列中存在其他进程需要被调度时才会转向执行其他函数。此时，系统中唯一存 在就绪状态的进程就是由kerne_hread()创建的init进程(内核线程)，所以内核并不进入default_idle()函数，而是转向 init()函数继续启动过程。</p>
<p><strong>启动第五步－－用户层init依据inittab文件来设定运行等级</strong></p>
<p>内核被加载后，第一个运行的程序便是/sbin/init，该文件会读取/etc/inittab文件，并依据此文件来进行初始化工作。</p>
<p>其实/etc/inittab文件最主要的作用就是设定Linux的运行等级，其设定形式是“：id:5:initdefault:”，这就表明Linux需要运行在等级5上。Linux的运行等级设定如下：</p>
<p>0：关机</p>
<p>1：单用户模式</p>
<p>2：无网络支持的多用户模式</p>
<p>3：有网络支持的多用户模式</p>
<p>4：保留，未使用</p>
<p>5：有网络支持有X-Window支持的多用户模式</p>
<p>6：重新引导系统，即重启</p>
<p><strong>启动第六步－－init进程执行rc.sysinit</strong></p>
<p>在 设定了运行等级后，Linux系统执行的第一个用户层文件就是/etc/rc.d/rc.sysinit脚本程序，它做的工作非常多，包括设定PATH、 设定网络配置（/etc/sysconfig/network）、启动swap分区、设定/proc等等。如果你有兴趣，可以到/etc/rc.d中查看 一下rc.sysinit文件。</p>
<p>线程init的最终完成状态是能够使得一般的用户程序可以正常地被执行，从而真正完成可供应用程序运行的系统环境。它主要进行的操作有:<br> (1) 执行函数do_basic_setup()，它会对外部设备进行全面地初始化。</p>
<p>(2) 构建系统的虚拟文件系统目录树，挂接系统中作为根目录的设备(其具体的文 件系统已经在上一步骤中注册)。</p>
<p>(3) 打开设备/dev/console，并通过函数sys_dup()打开的连接复制两次，使得文件号0,1 ,2 全部指向控制台。这三个文件连接就是通常所说的“标准输入”stdin,“标准输出”stdout和“标准出错信息”stderr这三个标准I/O通道。</p>
<p>(4) 准备好以上一切之后，系统开始进入用户层的初始化阶段。内核通过系统调用execve()加载执T子相应的用户层初始化程序，依次尝试加载程 序”/sbin/initl”,” /etc/init”,” /bin/init’，和“/bin/sh。只要其中有一个程序加载获得成功，那么系统就将开始用户层的初始化，而不会再回到init()函数段中。至 此，init()函数结束，Linux内核的引导 部分也到此结束。</p>
<p><strong>启动第七步－－启动内核模块</strong></p>
<p>具体是依据/etc/modules.conf文件或/etc/modules.d目录下的文件来装载内核模块。</p>
<p><strong>启动第八步－－执行不同运行级别的脚本程序</strong></p>
<p>根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。</p>
<p><strong>启动第九步－－执行/etc/rc.d/rc.local</strong></p>
<p>你如果打开了此文件，里面有一句话，读过之后，你就会对此命令的作用一目了然：</p>
<p># This script will be executed <em>after</em> all the other init scripts.<br> # You can put your own initialization stuff in here if you don’t<br> # want to do the full Sys V style init stuff.</p>
<p>rc.local就是在一切初始化工作后，Linux留给用户进行个性化的地方。你可以把你想设置和启动的东西放到这里。</p>
<p><strong>启动第十步－－执行/bin/login程序，进入登录状态</strong></p>
<p>此时，系统已经进入到了等待用户输入username和password的时候了，你已经可以用自己的帐号登入系统了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://acewzj.github.io/2019/05/29/2019-05-29-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="acewzj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acewzj">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/29/2019-05-29-java/" itemprop="url">java基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-29T10:06:18+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Base/" itemprop="url" rel="index">
                    <span itemprop="name">Java_Base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>本文记述了关于Java的一些基础知识点。</p>
<h2 id="Base-Tips"><a href="#Base-Tips" class="headerlink" title="Base Tips"></a>Base Tips</h2><blockquote>
<p>一个源文件只能有一个public类</p>
<p>char类型是一个单一的16位Unicode字符，可以储存任意字符，和之前想的不太一样，因为byte可以是二进制补码表示的整数</p>
</blockquote>
<h2 id="为什么数据要用二进制补码表示？"><a href="#为什么数据要用二进制补码表示？" class="headerlink" title="为什么数据要用二进制补码表示？"></a>为什么数据要用二进制补码表示？</h2><p>正数的二进制补码还是正数本身，但是负数的二进制补码是各位取反然后最低位再加一。采用补码表示主要是为了简化加法运算，让一个正数加上一个负数时得出的结果就是正确的形式。摘自阮一峰：将正数转化为负数，就让0减去这个数就行了，<code>0-8=-8</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"> -<span class="number">0000</span> <span class="number">1000</span></span><br><span class="line"> ----------</span><br><span class="line"> **好像不够减，向前一位借一**</span><br><span class="line"> <span class="number">10000</span> <span class="number">0000</span></span><br><span class="line">- <span class="number">0000</span> <span class="number">1000</span></span><br><span class="line">-----------</span><br><span class="line">  <span class="number">1111</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>拓展：大端与小端，一个Int占4个字节，如果0x12345678中的”78”在高地址处，那就是大端，反之就是小端。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String 存储的是字符串常量(const 不可修改) 每次对String类型进行改变的时候等于生成了一个新的String对象，然后将指针指向新的String对象。如果经常改变字符串内容，最好不要用 String ，因为每次生成对象都会对系统性能产生影响，而且当内存中无引用的对象多了以后， JVM 的 垃圾回收器GC 就会开始工作，程序运行速度就会变慢。<br>如果是定义一个StringBuffer 类型的对象，每次对字符串内容进行操作都会对 StringBuffer对象本身进行操作，而不是生成新的对象。所以一般情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全。StringBuilder类提供一个与 StringBuffer 兼容的 API，该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>
<h2 id="到底什么是classpath？"><a href="#到底什么是classpath？" class="headerlink" title="到底什么是classpath？"></a>到底什么是<code>classpath</code>？</h2><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p>
<p>因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件。</p>
<p>所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来，可能长这样：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\w</span>ork<span class="symbol">\p</span>roject1<span class="symbol">\b</span>in;C:<span class="symbol">\s</span>hared;"D:<span class="symbol">\M</span>y Documents<span class="symbol">\p</span>roject1<span class="symbol">\b</span>in"</span><br></pre></td></tr></table></figure>

<p>在Linux系统上，用<code>:</code>分隔，可能长这样：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span><span class="string">shared:</span><span class="regexp">/usr/</span>local<span class="regexp">/bin:/</span>home<span class="regexp">/liaoxuefeng/</span>bin</span><br></pre></td></tr></table></figure>

<p>现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p>
<ul>
<li>&lt;当前目录&gt;\abc\xyz\Hello.class</li>
<li>C:\work\project1\bin\abc\xyz\Hello.class</li>
<li>C:\shared\abc\xyz\Hello.class</li>
</ul>
<p>注意到<code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p>
<p><code>classpath</code>的设定方法有两种：</p>
<p>在系统环境变量中设置<code>classpath</code>环境变量，不推荐；</p>
<p>在启动JVM时设置<code>classpath</code>变量，推荐。</p>
<p>我们强烈<em>不推荐</em>在系统环境变量中设置<code>classpath</code>，那样会污染整个系统环境。在启动JVM时设置<code>classpath</code>才是推荐的做法。实际上就是给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .;C:<span class="symbol">\w</span>ork<span class="symbol">\p</span>roject1<span class="symbol">\b</span>in;C:<span class="symbol">\s</span>hared abc.xyz.Hello</span><br></pre></td></tr></table></figure>

<p>或者使用<code>-cp</code>的简写：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .;C:<span class="symbol">\w</span>ork<span class="symbol">\p</span>roject1<span class="symbol">\b</span>in;C:<span class="symbol">\s</span>hared abc.xyz.Hello</span><br></pre></td></tr></table></figure>

<p>没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即当前目录：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span> <span class="selector-tag">abc</span><span class="selector-class">.xyz</span><span class="selector-class">.Hello</span></span><br></pre></td></tr></table></figure>

<p>上述命令告诉JVM只在当前目录搜索<code>Hello.class</code>。</p>
<p>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包。</p>
<p>通常，我们在自己编写的<code>class</code>中，会引用Java核心库的<code>class</code>，例如，<code>String</code>、<code>ArrayList</code>等。这些<code>class</code>应该上哪去找？</p>
<p>有很多“如何设置classpath”的文章会告诉你把JVM自带的<code>rt.jar</code>放入<code>classpath</code>，但事实上，根本不需要告诉JVM如何去Java核心库查找<code>class</code>，JVM怎么可能笨到连自己的核心库在哪都不知道？</p>
<p> 不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！</p>
<p>更好的做法是，不要设置<code>classpath</code>！默认的当前目录<code>.</code>对于绝大多数情况都够用了。</p>
<h3 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h3><p>如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p>
<p>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p>
<p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>中：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ./hello<span class="selector-class">.jar</span> abc<span class="selector-class">.xyz</span>.Hello</span><br></pre></td></tr></table></figure>

<p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p>
<p>那么问题来了：如何创建jar包？</p>
<p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</p>
<p>假设编译输出的目录结构是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure>

<p>这里需要特别注意的是，jar包里的第一层目录，不能是<code>bin</code>，而应该是<code>hong</code>、<code>ming</code>、<code>mr</code>。如果在Windows的资源管理器中看，应该长这样：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1261393208671488/l" alt="hello.zip.ok"></p>
<p>如果长这样：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1261391527906784/l" alt="hello.zip.invalid"></p>
<p>说明打包打得有问题，JVM仍然无法从jar包中查找正确的<code>class</code>，原因是<code>hong.Person</code>必须按<code>hong/Person.class</code>存放，而不是<code>bin/hong/Person.class</code>。</p>
<p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">java </span>-<span class="keyword">jar </span>hello.<span class="keyword">jar</span></span><br></pre></td></tr></table></figure>

<p>jar包还可以包含其它jar包，这个时候，就需要在<code>MANIFEST.MF</code>文件里配置<code>classpath</code>了。</p>
<p>在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200" target="_blank" rel="noopener">Maven</a>，可以非常方便地创建jar包。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序；</p>
<p>不推荐设置系统环境变量<code>classpath</code>，始终建议通过<code>-cp</code>命令传入；</p>
<p>jar包相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用；</p>
<p><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包。</p>
<h2 id="关于JAVA中Static的用法"><a href="#关于JAVA中Static的用法" class="headerlink" title="关于JAVA中Static的用法"></a>关于JAVA中Static的用法</h2><p>1，对于成员变量</p>
<p>用了Static以后，主函数就可以不用先生成一个对象然后再对象.变量名字 这样调用这个成员变量（面向对象语言要求调用成员变量必须用 对象.成员变量名字 这种形式来调用）；你对象怎么来的？还不是person p1=new person();这种靠类来初始化一个对象，实际上是一个引用，指向一个内存堆。</p>
<p>2.对于成员函数</p>
<p>用了Static以后，任何东西实际上已经被分配了一个固定到死的空间，不像动态变量那样具有生命周期，静态的东西一直都在那里，在C语言中：用Static可以保存上一次程序退出后的值，下一次程序再进入，动态变量重新归0，静态变量继续存活，执行累加或者等等……</p>
<p>3，以上，对于静态成员变量与静态函数，都可以不用初始化一个对象，靠对象来执行相应工程，直接来 类.对象名字（成员变量，函数）就可以了。</p>
<h2 id="关于JAVA中This的用法"><a href="#关于JAVA中This的用法" class="headerlink" title="关于JAVA中This的用法"></a>关于JAVA中This的用法</h2><p>1.对于成员变量</p>
<p>用<code>This</code>可以代替类.成员变量，直接可以变为This.成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">用This可以这样  函数（string name,<span class="keyword">int</span> age）&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.age=age;<span class="comment">//.后面代表成员变量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.对于成员函数（主要对构造函数）</span><br><span class="line"></span><br><span class="line">person()&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"无参数的构造函数"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person(String name,<span class="keyword">int</span> age)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>();<span class="comment">//调用1函数</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"有两个参数的构造函数"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person(String name,<span class="keyword">int</span> age，string adress)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(zhangsan,<span class="number">20</span>);<span class="comment">//根据参数个数及形式调用相应的构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"有三个参数的构造函数"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序运行结果：</span><br><span class="line"></span><br><span class="line">无参数的构造函数</span><br><span class="line"></span><br><span class="line">有两个函数的构造函数</span><br><span class="line"></span><br><span class="line">有三个函数的构造函数</span><br></pre></td></tr></table></figure>

<p>必须把This放在第一行，但是super不必这样！</p>
<h2 id="Java：Override"><a href="#Java：Override" class="headerlink" title="Java：Override"></a>Java：Override</h2><p>复写：</p>
<p>子类继承父类后，父类的某个函数与子类的某个函数，参数列表完全相同，类型也一样。就说子类复写了父类的这个方法。</p>
<p>可以在子类方法中用super.方法，调用父类的同名函数。</p>
<h2 id="JAVA：上下转型"><a href="#JAVA：上下转型" class="headerlink" title="JAVA：上下转型"></a>JAVA：上下转型</h2><p>1.上转型</p>
<p><img src="https://i.loli.net/2020/03/30/SObB2LfqMvgTREk.png" alt="1576646436445"></p>
<p>语法：1，一个引用能够调用哪些成员（变量和函数），取决与这个引用的类型{虽然指向同一个内存堆，但是p里面如果没有定义某个变量，那它不能使用}</p>
<p>2.一个引用调用的是哪一个方法，取决于这个引用所指向的对象{使用introduce方法时，虽然两个类中都有，但是它调用子类的那个方法}</p>
<p>2.下转型</p>
<p><img src="https://i.loli.net/2020/03/30/S6Rji5aETfnCqWV.png" alt="1576646454271"></p>
<p>错误的向下转型：学生是人，但是有的人不是学生</p>
<p><img src="https://i.loli.net/2020/03/30/OAhd9M6vPsYazl4.png" alt="1576646482475"></p>
<h2 id="JAVA：子类实例化"><a href="#JAVA：子类实例化" class="headerlink" title="JAVA：子类实例化"></a>JAVA：子类实例化</h2><p>1，子类继承父类时，不能继承父类的构造方法，但是父类有一些成员变量，我想在子类中对它进行赋值；但是它在父类中已经被构造函数赋值了。作为一个程序员，最不能忍受的就是父类和子类有相同的代码块：像吐了唾沫！怎么办？</p>
<p>子类会使 用super（）；调用父类不带参数的构造函数；</p>
<p>或者Super（x1,x2）；调用相应的构造函数//类似This</p>
<p>这样就省得你对父类成员变量赋值时。冗余拖沓！</p>
<p>2.就算你不屑写super，编译器也会自动给你生成的，那么此时牛就会调用父类不带参数的构造方法</p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>1.Abstract天生就是给人当爹的！</p>
<p><img src="https://i.loli.net/2020/03/30/jN3nGxgd6myfKWA.png" alt="1576646640881"></p>
<p>2.继承抽象类的子函数必须复写父类中的抽象方法！</p>
<p>3.抽象类不能生成相应的对象！</p>
<p>4.既然抽象函数不能生成对象，它还是会有构造函数的，因为还会有Super</p>
<p>5.生成子类的对象必须要有父类的生成！</p>
<h2 id="静态区"><a href="#静态区" class="headerlink" title="静态区"></a>静态区</h2><p>静态区：保存自动全局变量和 static变量（包括 static全局和局部变量） 。静态区的内容</p>
<p>在总个程序的生命周期内都存在，由编译器在编译的时候分配。</p>
<p>栈：保存局部变量。栈上的内容只在函数的范围内存在，当函数运行结束，这些内容</p>
<p>也会自动被销毁。其特点是效率高，但空间大小有限。</p>
<p>堆：由 malloc系列函数或 new操作符分配的内存。其生命周期由 free或 delete决定。</p>
<p>在没有释放之前一直存在，直到程序结束。其特点是使用灵活，空间比较大，但容易出错。</p>
<p>按照 getchar名字的意思，应该将变量 c 定义为 char类型。但是很不幸，getchar函数的</p>
<p>返回值却是 int类型，其原型为：</p>
<p>int getchar(void)；</p>
<h2 id="JAVA：访问权限"><a href="#JAVA：访问权限" class="headerlink" title="JAVA：访问权限"></a>JAVA：访问权限</h2><p>两个类如果在不同的包里面，被访问的类（变量和方法）必须是public，你不屑写 ，就默认为friend，也还是访问不了</p>
<p>default:必须在同一个包里面，不同的包使用不了</p>
<h2 id="Java-内部类和匿名内部类"><a href="#Java-内部类和匿名内部类" class="headerlink" title="Java:内部类和匿名内部类"></a>Java:内部类和匿名内部类</h2><p>内部类就是定义在类里面的类；它可以使用外部类的变量；但是在生成内部类的对象时，必须先生成其外部类：eg</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">A.a b=<span class="keyword">new</span> a.B();</span><br><span class="line"></span><br><span class="line">A.<span class="keyword">this</span>.i+<span class="keyword">this</span>.j;</span><br></pre></td></tr></table></figure>

<p>匿名内部类就是没有名字的类，一般别的类都是什么……classA implements interface……</p>
<p>匿名内部类直接就是<code>new A（）</code></p>
<p>匿名内部类也就是没有名字的内部类</p>
<p>正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写</p>
<p>但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</p>
<h4 id="实例1-不使用匿名内部类来实现抽象方法"><a href="#实例1-不使用匿名内部类来实现抽象方法" class="headerlink" title="实例1:不使用匿名内部类来实现抽象方法"></a>实例1:不使用匿名内部类来实现抽象方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Child();</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong><code>eat something</code></p>
<p>可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用</p>
<p>但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？</p>
<p>这个时候就引入了匿名内部类</p>
<h4 id="实例2：匿名内部类的基本实现"><a href="#实例2：匿名内部类的基本实现" class="headerlink" title="实例2：匿名内部类的基本实现"></a>实例2：匿名内部类的基本实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong><code>eat something</code></p>
<p>可以看到，我们直接将抽象类Person中的方法在大括号中实现了</p>
<p>这样便可以省略一个类的书写</p>
<p>并且，匿名内部类还能用于接口上 </p>
<h4 id="实例3：在接口上使用匿名内部类"><a href="#实例3：在接口上使用匿名内部类" class="headerlink" title="实例3：在接口上使用匿名内部类"></a>实例3：在接口上使用匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>运行结果：</strong><code>eat something</code></p>
<p> 由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p>
<p>最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口</p>
<h4 id="实例4：Thread类的匿名内部类实现"><a href="#实例4：Thread类的匿名内部类实现" class="headerlink" title="实例4：Thread类的匿名内部类实现"></a>实例4：Thread类的匿名内部类实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong><code>1 2 3 4 5</code></p>
<h4 id="实例5：Runnable接口的匿名内部类实现"><a href="#实例5：Runnable接口的匿名内部类实现" class="headerlink" title="实例5：Runnable接口的匿名内部类实现"></a>实例5：Runnable接口的匿名内部类实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong><code>1 2 3 4 5</code></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>实现线程的两个方法：实现<code>runnable</code>接口 ；<code>runnable</code>只是一个接口：它里面只有一个<code>run(）</code>方法，没有<code>start</code>方法，而没有<code>start</code>方法，其实是还在原来的那个进程中的。</p>
<p>第二：继承<code>Thread</code>类  而<code>Thread</code>类有一个构造方法：参数是Runnale对象，也就是说可以通过<code>Thread</code>类来启动Runnable的多线程</p>
<p>Java标准的启动线程的方法：</p>
<p>1.生成一个<code>Runnable</code>对象 </p>
<p><code>Runnable r = **new** Runnable()</code> </p>
<p>2.把上述对象当成参数传进Thread中去</p>
<p><code>Thread t = **new** Thread(r);</code> </p>
<p>3.启动Start方法</p>
<p><code>t.start();</code></p>
<p>调用Start（）方法之后，线程进入就绪状态，当时间片轮转动到该线程时，获得CPU的使用权</p>
<p> handler.post(r);并没有调用Start方法，而是调用Run方法。</p>
<p>什么时候开线程？</p>
<p>耗时时间长，并不一定有结果，比如下载，搜索蓝牙</p>
<h2 id="Handle机制详解"><a href="#Handle机制详解" class="headerlink" title="Handle机制详解"></a>Handle机制详解</h2><p>假如一个隧道就是一个消息队列，那么里面的每一部汽车就是一个一个消息，这里我们先忽略掉超车等种种因素，只那么先进隧道的车将会先出</p>
<p>Looper:(相当于隧道) 一个线程可以产生一个Looper 对象，由它来管理此线程里的Message Queue( 车队,消息隧道) 。</p>
<p>Handler: 你可以构造Handler 对象来与Looper 沟通，以便push 新消息到Message Queue 里；或者接收Looper( 从Message Queue 取出) 所送来的消息。</p>
<p>Message Queue( 消息队列): 用来存放线程放入的消息。</p>
<p>线程：UI thread 通常就是main thread ，而Android 启动程序时会替它建立一个Message Queue 。</p>
<p>每一个线程里可含有一个Looper 对象以及一个MessageQueue <a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">数据结构</a></p>
<p>在你的Android 程序里，新诞生一个线程，或执行 (Thread) 时，并不会自动建立其Message Loop 。</p>
<p>Android 里并没有Global 的Message Queue 数据结构，例如，不同APK 里的对象不能透过Massage Queue来交换讯息(Message) 。 </p>
<p>Looper 类用来管理特定线程内对象之间的消息交换(Message Exchange) 。你的应用程序可以产生许多个线程。而一个线程可以有许多个组件，这些组件之间常常需要互相交换讯息。如果有这种需要，您可以替线程构造一个Looper 对象，来担任讯息交换的管理工作。Looper 对象会建立一个MessageQueue 数据结构来存放各对象传来的消息( 包括UI 事件或System 事件等) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Looper looper = Looper.myLooper();<span class="comment">//取得当前线程里的looper</span></span><br><span class="line"> MyHandler mHandler = <span class="keyword">new</span> MyHandler(looper);<span class="comment">//构造一个handler使之可与looper通信</span></span><br><span class="line"><span class="comment">//buton等组件可以由mHandler将消息传给looper后,再放入messageQueue中,同时mHandler也可以接受来自looper消息</span></span><br></pre></td></tr></table></figure>

<h2 id="使用IDEA创建第一个springboot应用"><a href="#使用IDEA创建第一个springboot应用" class="headerlink" title="使用IDEA创建第一个springboot应用"></a>使用IDEA创建第一个springboot应用</h2><p>步骤01 新建项目，选择Spring initializer</p>
<p><img src="https://i.loli.net/2020/03/30/lXZ9Q5vbAmr361J.png" alt="image-20200330203745540"></p>
<p>步骤02 输入项目的基本信息，包括Group(组织Id)、Artifact(模块名称)、Type(项目构建类型)、Language(开发语言)、Packaging(最终生成包的类型)、Java Version(Java版本)、Version(项目的版本号)、Name(项目名称)、Description(项目描述)、Package(项目的包)，各项基本信息输入完成后即可点击“Next”进入下一步；</p>
<p><img src="https://i.loli.net/2020/03/30/bqVSCJLEhHp5NWK.png" alt="image-20200330203252179"></p>
<blockquote>
<p>其中，“组织Id”一般为公司等组织域名的反写，而对于个人项目而言，建议采用“<strong>pers(个人发起、独自完成、可分享的项目)或priv(个人发起、独自完成、非公开的私人使用的项目)+个人名</strong>”的形式；“项目构建类型”表示是使用Maven还是Gradle构建项目；“最终生成包的类型”表示是使用Jar包还是War包作为项目的最终打包方式，此处选择Jar包，后续可以在项目的配置文件中进行修改；“项目的包”的包名则是根据“组织Id+模块名称”规则自动生成，一般情况下没有必要去进行修改</p>
</blockquote>
<p>步骤03 选择web–&gt;Spring Web </p>
<p><img src="https://i.loli.net/2020/03/30/XYruqbfnByJUecz.png" alt="image-20200330203343084"></p>
<blockquote>
<p>GA:General Availability,正式发布的版本，官方推荐使用此版本。在国外都是用GA来说明release版本的。</p>
<p>SNAPSHOT: 快照版，可以稳定使用，且仍在继续改进版本。</p>
</blockquote>
<p>步骤04 选择finish</p>
<p><img src="https://i.loli.net/2020/03/30/T5AEpBxr9SJ4DOC.png" alt="image-20200330203700464"></p>
<p>步骤05 在启动之前先熟悉一下文件结构</p>
<p><img src="https://i.loli.net/2020/03/30/9RuvL5kFCTrzZoQ.png" alt="image-20200330204009831"></p>
<ul>
<li>.idea文件夹：存放项目的一些配置信息，例如IDE的一些配置(主题、字体等)、缓存、版本控制和历史记录等信息；</li>
<li>.mvn文件夹：该文件夹展开有一个wrapper文件夹，其中存放maven-wrapper.jar和maven-wrapper.properties和MavenWrapperDownloader.java三个文件。在src文件夹下方的文件中，还有mvnw、mvnw.cmd两个文件。其实mvnw就是一个maven wrapper script,可以让你在没有安装maven或者maven版本不兼容的条件下运行maven的命令，mvn.cmd是执行mvnw命令的cmd入口。它的原理是在maven-wrapper.properties文件中记录你要使用的maven版本，当我们执行mvnw clean命令时，发现当前环境中的maven版本和期望的版本不一致，那么就下载期望的版本，然后用期望的版本来执行mvn命令。在实际的开发过程中，我们应该保证开发环境安装了maven且maven版本与期望版本保持一致。所以这个文件夹与下面的mvnw、mvnw.cmd两个文件均可以删除；</li>
<li>src文件夹：这个目录就比较熟悉了，就是用来存放源代码的文件夹。<br>  <strong>main</strong>是源文件夹，包括存放Java代码的“<strong>java</strong>”文件夹和存放静态资源的“<strong>resources</strong>”文件夹。在“java”文件夹中可以看到根据步骤03“输入项目的基本信息”时配置的包名而自动生成的一个包，其中含有自动生成的”StudySpringbootApplication”类，它是整个项目的入口类，通过其中的run方法启动项目；而“resources”文件夹中包含两个文件夹和一个文件，“static”文件夹默认存放静态资源也就是静态页面，“templates”文件夹默认存放视图模板也就是动态页面(需要引入官方推荐使用的Thymeleaf模板引擎组件或FreeMarker等第三方的模板引擎)。但是在目前的企业级Web应用中，前后端分离是大势所趋，视图层技术日渐式微，不过这两个文件夹Spring官方还是给予了提供;“application.properties”是一个配置文件，包含系统属性、环境变量、命令参数等信息，Spring Boot启动时默认加载该配置文件。此处建议将该配置文件由.properties格式改为.yml格式(虽然两者皆为官方推荐的格式)，因为相比较而言.yml比.properties更好用，后面我会写专文进行讨论；<br>  <strong>test</strong>是测试文件夹，存放我们编写的测试类；</li>
<li>mvnw、mvnw.cmd：这两个文件之前已经说过了，此处不再赘述；</li>
<li>pom.xml：Maven的配置文件，主要描述了项目的Maven坐标、依赖关系、开发者需要遵循的规则、缺陷管理系统、组织、licenses以及其他所有的项目相关因素，是项目级别的配置文件；</li>
<li>firstboot.iml：IDEA的工程配置文件，里面是当前项目的一些配置信息，例如历史记录、版本控制信息等；</li>
<li>External Libraries：即项目的外部依赖，此处的外部依赖由Maven自动导入，一般不需要操作和干预；</li>
<li>Scratches and Consoles：划痕和控制台，IDEA提供的一个临时的文件编辑环境，通过该环境你可以写一些临时注释和项目上下文之外的代码片段，相当于一个草稿本的功能。</li>
</ul>
<p>步骤06 启动FirstbootApplication，浏览器输入localhost:8080出现白页</p>
<p><img src="https://i.loli.net/2020/03/30/lf8N1UHFIZzGeqm.png" alt="image-20200330204614392"></p>
<p>Inspections 为最高等级检查，可以检查单词拼写，语法错误，变量使用，方法之间调用等<br>Syntax 可以检查单词拼写，简单语法错误<br>None 不设置检查<br>IntelliJ IDEA 对于编辑大文件并没有太大优势，很卡，原因就是它有各种检查，这样是非常耗内存和 CPU 的，所以为了能加快大文件的读写，可以考虑暂时性设置为 None</p>
<p><code>Power Save Mode</code> 省电模式，也可以通过<code>File -&gt; Power Save Mode</code>来设置，开启这种模式之后 IntelliJ IDEA 会关掉代码检查和代码提示等功能。如果在开发过程中遇到突然代码文件不能进行检查和提示可以来看看这里是否有开启该功能</p>
<p><img src="https://i.loli.net/2020/03/30/zdbRvZfIT743AD1.png" alt="image-20200330212055153"></p>
<h3 id="所谓Controller就是起一个路由的作用啊"><a href="#所谓Controller就是起一个路由的作用啊" class="headerlink" title="所谓Controller就是起一个路由的作用啊"></a>所谓Controller就是起一个路由的作用啊</h3><p><img src="https://i.loli.net/2020/03/30/STsVlKgZ5rUN1RW.png" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">acewzj</p>
              <p class="site-description motion-element" itemprop="description">acewzj</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">acewzj</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  





  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
